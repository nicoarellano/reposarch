var Ds = Object.defineProperty;
var Fs = (i, t, e) => t in i ? Ds(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e;
var ot = (i, t, e) => (Fs(i, typeof t != "symbol" ? t + "" : t, e), e);
const Rt = Math.min, K = Math.max, $e = Math.round, ct = (i) => ({
  x: i,
  y: i
}), Vs = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Us = {
  start: "end",
  end: "start"
};
function tn(i, t, e) {
  return K(i, Rt(t, e));
}
function ce(i, t) {
  return typeof i == "function" ? i(t) : i;
}
function X(i) {
  return i.split("-")[0];
}
function Be(i) {
  return i.split("-")[1];
}
function Bn(i) {
  return i === "x" ? "y" : "x";
}
function Nn(i) {
  return i === "y" ? "height" : "width";
}
function Et(i) {
  return ["top", "bottom"].includes(X(i)) ? "y" : "x";
}
function Hn(i) {
  return Bn(Et(i));
}
function qs(i, t, e) {
  e === void 0 && (e = !1);
  const s = Be(i), n = Hn(i), r = Nn(n);
  let o = n === "x" ? s === (e ? "end" : "start") ? "right" : "left" : s === "start" ? "bottom" : "top";
  return t.reference[r] > t.floating[r] && (o = Ce(o)), [o, Ce(o)];
}
function Ws(i) {
  const t = Ce(i);
  return [ni(i), t, ni(t)];
}
function ni(i) {
  return i.replace(/start|end/g, (t) => Us[t]);
}
function Qs(i, t, e) {
  const s = ["left", "right"], n = ["right", "left"], r = ["top", "bottom"], o = ["bottom", "top"];
  switch (i) {
    case "top":
    case "bottom":
      return e ? t ? n : s : t ? s : n;
    case "left":
    case "right":
      return t ? r : o;
    default:
      return [];
  }
}
function Ys(i, t, e, s) {
  const n = Be(i);
  let r = Qs(X(i), e === "start", s);
  return n && (r = r.map((o) => o + "-" + n), t && (r = r.concat(r.map(ni)))), r;
}
function Ce(i) {
  return i.replace(/left|right|bottom|top/g, (t) => Vs[t]);
}
function Gs(i) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...i
  };
}
function Dn(i) {
  return typeof i != "number" ? Gs(i) : {
    top: i,
    right: i,
    bottom: i,
    left: i
  };
}
function zt(i) {
  const {
    x: t,
    y: e,
    width: s,
    height: n
  } = i;
  return {
    width: s,
    height: n,
    top: e,
    left: t,
    right: t + s,
    bottom: e + n,
    x: t,
    y: e
  };
}
function en(i, t, e) {
  let {
    reference: s,
    floating: n
  } = i;
  const r = Et(t), o = Hn(t), a = Nn(o), l = X(t), c = r === "y", u = s.x + s.width / 2 - n.width / 2, d = s.y + s.height / 2 - n.height / 2, f = s[a] / 2 - n[a] / 2;
  let p;
  switch (l) {
    case "top":
      p = {
        x: u,
        y: s.y - n.height
      };
      break;
    case "bottom":
      p = {
        x: u,
        y: s.y + s.height
      };
      break;
    case "right":
      p = {
        x: s.x + s.width,
        y: d
      };
      break;
    case "left":
      p = {
        x: s.x - n.width,
        y: d
      };
      break;
    default:
      p = {
        x: s.x,
        y: s.y
      };
  }
  switch (Be(t)) {
    case "start":
      p[o] -= f * (e && c ? -1 : 1);
      break;
    case "end":
      p[o] += f * (e && c ? -1 : 1);
      break;
  }
  return p;
}
const Ks = async (i, t, e) => {
  const {
    placement: s = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: o
  } = e, a = r.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(t));
  let c = await o.getElementRects({
    reference: i,
    floating: t,
    strategy: n
  }), {
    x: u,
    y: d
  } = en(c, s, l), f = s, p = {}, b = 0;
  for (let v = 0; v < a.length; v++) {
    const {
      name: g,
      fn: S
    } = a[v], {
      x: E,
      y: x,
      data: $,
      reset: O
    } = await S({
      x: u,
      y: d,
      initialPlacement: s,
      placement: f,
      strategy: n,
      middlewareData: p,
      rects: c,
      platform: o,
      elements: {
        reference: i,
        floating: t
      }
    });
    u = E ?? u, d = x ?? d, p = {
      ...p,
      [g]: {
        ...p[g],
        ...$
      }
    }, O && b <= 50 && (b++, typeof O == "object" && (O.placement && (f = O.placement), O.rects && (c = O.rects === !0 ? await o.getElementRects({
      reference: i,
      floating: t,
      strategy: n
    }) : O.rects), {
      x: u,
      y: d
    } = en(c, f, l)), v = -1);
  }
  return {
    x: u,
    y: d,
    placement: f,
    strategy: n,
    middlewareData: p
  };
};
async function Fn(i, t) {
  var e;
  t === void 0 && (t = {});
  const {
    x: s,
    y: n,
    platform: r,
    rects: o,
    elements: a,
    strategy: l
  } = i, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: d = "floating",
    altBoundary: f = !1,
    padding: p = 0
  } = ce(t, i), b = Dn(p), g = a[f ? d === "floating" ? "reference" : "floating" : d], S = zt(await r.getClippingRect({
    element: (e = await (r.isElement == null ? void 0 : r.isElement(g))) == null || e ? g : g.contextElement || await (r.getDocumentElement == null ? void 0 : r.getDocumentElement(a.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: l
  })), E = d === "floating" ? {
    x: s,
    y: n,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, x = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(a.floating)), $ = await (r.isElement == null ? void 0 : r.isElement(x)) ? await (r.getScale == null ? void 0 : r.getScale(x)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, O = zt(r.convertOffsetParentRelativeRectToViewportRelativeRect ? await r.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: E,
    offsetParent: x,
    strategy: l
  }) : E);
  return {
    top: (S.top - O.top + b.top) / $.y,
    bottom: (O.bottom - S.bottom + b.bottom) / $.y,
    left: (S.left - O.left + b.left) / $.x,
    right: (O.right - S.right + b.right) / $.x
  };
}
const Xs = function(i) {
  return i === void 0 && (i = {}), {
    name: "flip",
    options: i,
    async fn(t) {
      var e, s;
      const {
        placement: n,
        middlewareData: r,
        rects: o,
        initialPlacement: a,
        platform: l,
        elements: c
      } = t, {
        mainAxis: u = !0,
        crossAxis: d = !0,
        fallbackPlacements: f,
        fallbackStrategy: p = "bestFit",
        fallbackAxisSideDirection: b = "none",
        flipAlignment: v = !0,
        ...g
      } = ce(i, t);
      if ((e = r.arrow) != null && e.alignmentOffset)
        return {};
      const S = X(n), E = Et(a), x = X(a) === a, $ = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), O = f || (x || !v ? [Ce(a)] : Ws(a)), _ = b !== "none";
      !f && _ && O.push(...Ys(a, v, b, $));
      const I = [a, ...O], D = await Fn(t, g), F = [];
      let A = ((s = r.flip) == null ? void 0 : s.overflows) || [];
      if (u && F.push(D[S]), d) {
        const W = qs(n, o, $);
        F.push(D[W[0]], D[W[1]]);
      }
      if (A = [...A, {
        placement: n,
        overflows: F
      }], !F.every((W) => W <= 0)) {
        var kt, Qt;
        const W = (((kt = r.flip) == null ? void 0 : kt.index) || 0) + 1, Tt = I[W];
        if (Tt)
          return {
            data: {
              index: W,
              overflows: A
            },
            reset: {
              placement: Tt
            }
          };
        let nt = (Qt = A.filter((st) => st.overflows[0] <= 0).sort((st, Q) => st.overflows[1] - Q.overflows[1])[0]) == null ? void 0 : Qt.placement;
        if (!nt)
          switch (p) {
            case "bestFit": {
              var Pt;
              const st = (Pt = A.filter((Q) => {
                if (_) {
                  const rt = Et(Q.placement);
                  return rt === E || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  rt === "y";
                }
                return !0;
              }).map((Q) => [Q.placement, Q.overflows.filter((rt) => rt > 0).reduce((rt, Hs) => rt + Hs, 0)]).sort((Q, rt) => Q[1] - rt[1])[0]) == null ? void 0 : Pt[0];
              st && (nt = st);
              break;
            }
            case "initialPlacement":
              nt = a;
              break;
          }
        if (n !== nt)
          return {
            reset: {
              placement: nt
            }
          };
      }
      return {};
    }
  };
};
function Vn(i) {
  const t = Rt(...i.map((r) => r.left)), e = Rt(...i.map((r) => r.top)), s = K(...i.map((r) => r.right)), n = K(...i.map((r) => r.bottom));
  return {
    x: t,
    y: e,
    width: s - t,
    height: n - e
  };
}
function Js(i) {
  const t = i.slice().sort((n, r) => n.y - r.y), e = [];
  let s = null;
  for (let n = 0; n < t.length; n++) {
    const r = t[n];
    !s || r.y - s.y > s.height / 2 ? e.push([r]) : e[e.length - 1].push(r), s = r;
  }
  return e.map((n) => zt(Vn(n)));
}
const Zs = function(i) {
  return i === void 0 && (i = {}), {
    name: "inline",
    options: i,
    async fn(t) {
      const {
        placement: e,
        elements: s,
        rects: n,
        platform: r,
        strategy: o
      } = t, {
        padding: a = 2,
        x: l,
        y: c
      } = ce(i, t), u = Array.from(await (r.getClientRects == null ? void 0 : r.getClientRects(s.reference)) || []), d = Js(u), f = zt(Vn(u)), p = Dn(a);
      function b() {
        if (d.length === 2 && d[0].left > d[1].right && l != null && c != null)
          return d.find((g) => l > g.left - p.left && l < g.right + p.right && c > g.top - p.top && c < g.bottom + p.bottom) || f;
        if (d.length >= 2) {
          if (Et(e) === "y") {
            const A = d[0], kt = d[d.length - 1], Qt = X(e) === "top", Pt = A.top, W = kt.bottom, Tt = Qt ? A.left : kt.left, nt = Qt ? A.right : kt.right, st = nt - Tt, Q = W - Pt;
            return {
              top: Pt,
              bottom: W,
              left: Tt,
              right: nt,
              width: st,
              height: Q,
              x: Tt,
              y: Pt
            };
          }
          const g = X(e) === "left", S = K(...d.map((A) => A.right)), E = Rt(...d.map((A) => A.left)), x = d.filter((A) => g ? A.left === E : A.right === S), $ = x[0].top, O = x[x.length - 1].bottom, _ = E, I = S, D = I - _, F = O - $;
          return {
            top: $,
            bottom: O,
            left: _,
            right: I,
            width: D,
            height: F,
            x: _,
            y: $
          };
        }
        return f;
      }
      const v = await r.getElementRects({
        reference: {
          getBoundingClientRect: b
        },
        floating: s.floating,
        strategy: o
      });
      return n.reference.x !== v.reference.x || n.reference.y !== v.reference.y || n.reference.width !== v.reference.width || n.reference.height !== v.reference.height ? {
        reset: {
          rects: v
        }
      } : {};
    }
  };
};
async function tr(i, t) {
  const {
    placement: e,
    platform: s,
    elements: n
  } = i, r = await (s.isRTL == null ? void 0 : s.isRTL(n.floating)), o = X(e), a = Be(e), l = Et(e) === "y", c = ["left", "top"].includes(o) ? -1 : 1, u = r && l ? -1 : 1, d = ce(t, i);
  let {
    mainAxis: f,
    crossAxis: p,
    alignmentAxis: b
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...d
  };
  return a && typeof b == "number" && (p = a === "end" ? b * -1 : b), l ? {
    x: p * u,
    y: f * c
  } : {
    x: f * c,
    y: p * u
  };
}
const Un = function(i) {
  return {
    name: "offset",
    options: i,
    async fn(t) {
      var e, s;
      const {
        x: n,
        y: r,
        placement: o,
        middlewareData: a
      } = t, l = await tr(t, i);
      return o === ((e = a.offset) == null ? void 0 : e.placement) && (s = a.arrow) != null && s.alignmentOffset ? {} : {
        x: n + l.x,
        y: r + l.y,
        data: {
          ...l,
          placement: o
        }
      };
    }
  };
}, er = function(i) {
  return i === void 0 && (i = {}), {
    name: "shift",
    options: i,
    async fn(t) {
      const {
        x: e,
        y: s,
        placement: n
      } = t, {
        mainAxis: r = !0,
        crossAxis: o = !1,
        limiter: a = {
          fn: (g) => {
            let {
              x: S,
              y: E
            } = g;
            return {
              x: S,
              y: E
            };
          }
        },
        ...l
      } = ce(i, t), c = {
        x: e,
        y: s
      }, u = await Fn(t, l), d = Et(X(n)), f = Bn(d);
      let p = c[f], b = c[d];
      if (r) {
        const g = f === "y" ? "top" : "left", S = f === "y" ? "bottom" : "right", E = p + u[g], x = p - u[S];
        p = tn(E, p, x);
      }
      if (o) {
        const g = d === "y" ? "top" : "left", S = d === "y" ? "bottom" : "right", E = b + u[g], x = b - u[S];
        b = tn(E, b, x);
      }
      const v = a.fn({
        ...t,
        [f]: p,
        [d]: b
      });
      return {
        ...v,
        data: {
          x: v.x - e,
          y: v.y - s
        }
      };
    }
  };
};
function ut(i) {
  return qn(i) ? (i.nodeName || "").toLowerCase() : "#document";
}
function M(i) {
  var t;
  return (i == null || (t = i.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function gt(i) {
  var t;
  return (t = (qn(i) ? i.ownerDocument : i.document) || window.document) == null ? void 0 : t.documentElement;
}
function qn(i) {
  return i instanceof Node || i instanceof M(i).Node;
}
function Y(i) {
  return i instanceof Element || i instanceof M(i).Element;
}
function G(i) {
  return i instanceof HTMLElement || i instanceof M(i).HTMLElement;
}
function nn(i) {
  return typeof ShadowRoot > "u" ? !1 : i instanceof ShadowRoot || i instanceof M(i).ShadowRoot;
}
function ue(i) {
  const {
    overflow: t,
    overflowX: e,
    overflowY: s,
    display: n
  } = j(i);
  return /auto|scroll|overlay|hidden|clip/.test(t + s + e) && !["inline", "contents"].includes(n);
}
function ir(i) {
  return ["table", "td", "th"].includes(ut(i));
}
function nr(i) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return i.matches(t);
    } catch {
      return !1;
    }
  });
}
function gi(i) {
  const t = vi(), e = Y(i) ? j(i) : i;
  return e.transform !== "none" || e.perspective !== "none" || (e.containerType ? e.containerType !== "normal" : !1) || !t && (e.backdropFilter ? e.backdropFilter !== "none" : !1) || !t && (e.filter ? e.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((s) => (e.willChange || "").includes(s)) || ["paint", "layout", "strict", "content"].some((s) => (e.contain || "").includes(s));
}
function sr(i) {
  let t = Mt(i);
  for (; G(t) && !Ne(t); ) {
    if (gi(t))
      return t;
    if (nr(t))
      return null;
    t = Mt(t);
  }
  return null;
}
function vi() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function Ne(i) {
  return ["html", "body", "#document"].includes(ut(i));
}
function j(i) {
  return M(i).getComputedStyle(i);
}
function He(i) {
  return Y(i) ? {
    scrollLeft: i.scrollLeft,
    scrollTop: i.scrollTop
  } : {
    scrollLeft: i.scrollX,
    scrollTop: i.scrollY
  };
}
function Mt(i) {
  if (ut(i) === "html")
    return i;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    i.assignedSlot || // DOM Element detected.
    i.parentNode || // ShadowRoot detected.
    nn(i) && i.host || // Fallback.
    gt(i)
  );
  return nn(t) ? t.host : t;
}
function Wn(i) {
  const t = Mt(i);
  return Ne(t) ? i.ownerDocument ? i.ownerDocument.body : i.body : G(t) && ue(t) ? t : Wn(t);
}
function si(i, t, e) {
  var s;
  t === void 0 && (t = []), e === void 0 && (e = !0);
  const n = Wn(i), r = n === ((s = i.ownerDocument) == null ? void 0 : s.body), o = M(n);
  if (r) {
    const a = rr(o);
    return t.concat(o, o.visualViewport || [], ue(n) ? n : [], a && e ? si(a) : []);
  }
  return t.concat(n, si(n, [], e));
}
function rr(i) {
  return i.parent && Object.getPrototypeOf(i.parent) ? i.frameElement : null;
}
function Qn(i) {
  const t = j(i);
  let e = parseFloat(t.width) || 0, s = parseFloat(t.height) || 0;
  const n = G(i), r = n ? i.offsetWidth : e, o = n ? i.offsetHeight : s, a = $e(e) !== r || $e(s) !== o;
  return a && (e = r, s = o), {
    width: e,
    height: s,
    $: a
  };
}
function Yn(i) {
  return Y(i) ? i : i.contextElement;
}
function Lt(i) {
  const t = Yn(i);
  if (!G(t))
    return ct(1);
  const e = t.getBoundingClientRect(), {
    width: s,
    height: n,
    $: r
  } = Qn(t);
  let o = (r ? $e(e.width) : e.width) / s, a = (r ? $e(e.height) : e.height) / n;
  return (!o || !Number.isFinite(o)) && (o = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: o,
    y: a
  };
}
const or = /* @__PURE__ */ ct(0);
function Gn(i) {
  const t = M(i);
  return !vi() || !t.visualViewport ? or : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function lr(i, t, e) {
  return t === void 0 && (t = !1), !e || t && e !== M(i) ? !1 : t;
}
function ee(i, t, e, s) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  const n = i.getBoundingClientRect(), r = Yn(i);
  let o = ct(1);
  t && (s ? Y(s) && (o = Lt(s)) : o = Lt(i));
  const a = lr(r, e, s) ? Gn(r) : ct(0);
  let l = (n.left + a.x) / o.x, c = (n.top + a.y) / o.y, u = n.width / o.x, d = n.height / o.y;
  if (r) {
    const f = M(r), p = s && Y(s) ? M(s) : s;
    let b = f, v = b.frameElement;
    for (; v && s && p !== b; ) {
      const g = Lt(v), S = v.getBoundingClientRect(), E = j(v), x = S.left + (v.clientLeft + parseFloat(E.paddingLeft)) * g.x, $ = S.top + (v.clientTop + parseFloat(E.paddingTop)) * g.y;
      l *= g.x, c *= g.y, u *= g.x, d *= g.y, l += x, c += $, b = M(v), v = b.frameElement;
    }
  }
  return zt({
    width: u,
    height: d,
    x: l,
    y: c
  });
}
const ar = [":popover-open", ":modal"];
function Kn(i) {
  return ar.some((t) => {
    try {
      return i.matches(t);
    } catch {
      return !1;
    }
  });
}
function cr(i) {
  let {
    elements: t,
    rect: e,
    offsetParent: s,
    strategy: n
  } = i;
  const r = n === "fixed", o = gt(s), a = t ? Kn(t.floating) : !1;
  if (s === o || a && r)
    return e;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = ct(1);
  const u = ct(0), d = G(s);
  if ((d || !d && !r) && ((ut(s) !== "body" || ue(o)) && (l = He(s)), G(s))) {
    const f = ee(s);
    c = Lt(s), u.x = f.x + s.clientLeft, u.y = f.y + s.clientTop;
  }
  return {
    width: e.width * c.x,
    height: e.height * c.y,
    x: e.x * c.x - l.scrollLeft * c.x + u.x,
    y: e.y * c.y - l.scrollTop * c.y + u.y
  };
}
function ur(i) {
  return Array.from(i.getClientRects());
}
function Xn(i) {
  return ee(gt(i)).left + He(i).scrollLeft;
}
function hr(i) {
  const t = gt(i), e = He(i), s = i.ownerDocument.body, n = K(t.scrollWidth, t.clientWidth, s.scrollWidth, s.clientWidth), r = K(t.scrollHeight, t.clientHeight, s.scrollHeight, s.clientHeight);
  let o = -e.scrollLeft + Xn(i);
  const a = -e.scrollTop;
  return j(s).direction === "rtl" && (o += K(t.clientWidth, s.clientWidth) - n), {
    width: n,
    height: r,
    x: o,
    y: a
  };
}
function dr(i, t) {
  const e = M(i), s = gt(i), n = e.visualViewport;
  let r = s.clientWidth, o = s.clientHeight, a = 0, l = 0;
  if (n) {
    r = n.width, o = n.height;
    const c = vi();
    (!c || c && t === "fixed") && (a = n.offsetLeft, l = n.offsetTop);
  }
  return {
    width: r,
    height: o,
    x: a,
    y: l
  };
}
function fr(i, t) {
  const e = ee(i, !0, t === "fixed"), s = e.top + i.clientTop, n = e.left + i.clientLeft, r = G(i) ? Lt(i) : ct(1), o = i.clientWidth * r.x, a = i.clientHeight * r.y, l = n * r.x, c = s * r.y;
  return {
    width: o,
    height: a,
    x: l,
    y: c
  };
}
function sn(i, t, e) {
  let s;
  if (t === "viewport")
    s = dr(i, e);
  else if (t === "document")
    s = hr(gt(i));
  else if (Y(t))
    s = fr(t, e);
  else {
    const n = Gn(i);
    s = {
      ...t,
      x: t.x - n.x,
      y: t.y - n.y
    };
  }
  return zt(s);
}
function Jn(i, t) {
  const e = Mt(i);
  return e === t || !Y(e) || Ne(e) ? !1 : j(e).position === "fixed" || Jn(e, t);
}
function pr(i, t) {
  const e = t.get(i);
  if (e)
    return e;
  let s = si(i, [], !1).filter((a) => Y(a) && ut(a) !== "body"), n = null;
  const r = j(i).position === "fixed";
  let o = r ? Mt(i) : i;
  for (; Y(o) && !Ne(o); ) {
    const a = j(o), l = gi(o);
    !l && a.position === "fixed" && (n = null), (r ? !l && !n : !l && a.position === "static" && !!n && ["absolute", "fixed"].includes(n.position) || ue(o) && !l && Jn(i, o)) ? s = s.filter((u) => u !== o) : n = a, o = Mt(o);
  }
  return t.set(i, s), s;
}
function mr(i) {
  let {
    element: t,
    boundary: e,
    rootBoundary: s,
    strategy: n
  } = i;
  const o = [...e === "clippingAncestors" ? pr(t, this._c) : [].concat(e), s], a = o[0], l = o.reduce((c, u) => {
    const d = sn(t, u, n);
    return c.top = K(d.top, c.top), c.right = Rt(d.right, c.right), c.bottom = Rt(d.bottom, c.bottom), c.left = K(d.left, c.left), c;
  }, sn(t, a, n));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function br(i) {
  const {
    width: t,
    height: e
  } = Qn(i);
  return {
    width: t,
    height: e
  };
}
function gr(i, t, e) {
  const s = G(t), n = gt(t), r = e === "fixed", o = ee(i, !0, r, t);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = ct(0);
  if (s || !s && !r)
    if ((ut(t) !== "body" || ue(n)) && (a = He(t)), s) {
      const d = ee(t, !0, r, t);
      l.x = d.x + t.clientLeft, l.y = d.y + t.clientTop;
    } else
      n && (l.x = Xn(n));
  const c = o.left + a.scrollLeft - l.x, u = o.top + a.scrollTop - l.y;
  return {
    x: c,
    y: u,
    width: o.width,
    height: o.height
  };
}
function rn(i, t) {
  return !G(i) || j(i).position === "fixed" ? null : t ? t(i) : i.offsetParent;
}
function Zn(i, t) {
  const e = M(i);
  if (!G(i) || Kn(i))
    return e;
  let s = rn(i, t);
  for (; s && ir(s) && j(s).position === "static"; )
    s = rn(s, t);
  return s && (ut(s) === "html" || ut(s) === "body" && j(s).position === "static" && !gi(s)) ? e : s || sr(i) || e;
}
const vr = async function(i) {
  const t = this.getOffsetParent || Zn, e = this.getDimensions;
  return {
    reference: gr(i.reference, await t(i.floating), i.strategy),
    floating: {
      x: 0,
      y: 0,
      ...await e(i.floating)
    }
  };
};
function yr(i) {
  return j(i).direction === "rtl";
}
const _r = {
  convertOffsetParentRelativeRectToViewportRelativeRect: cr,
  getDocumentElement: gt,
  getClippingRect: mr,
  getOffsetParent: Zn,
  getElementRects: vr,
  getClientRects: ur,
  getDimensions: br,
  getScale: Lt,
  isElement: Y,
  isRTL: yr
}, ts = er, es = Xs, is = Zs, ns = (i, t, e) => {
  const s = /* @__PURE__ */ new Map(), n = {
    platform: _r,
    ...e
  }, r = {
    ...n.platform,
    _c: s
  };
  return Ks(i, t, {
    ...n,
    platform: r
  });
};
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const _e = globalThis, yi = _e.ShadowRoot && (_e.ShadyCSS === void 0 || _e.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, _i = Symbol(), on = /* @__PURE__ */ new WeakMap();
let ss = class {
  constructor(t, e, s) {
    if (this._$cssResult$ = !0, s !== _i)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const e = this.t;
    if (yi && t === void 0) {
      const s = e !== void 0 && e.length === 1;
      s && (t = on.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), s && on.set(e, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
const xr = (i) => new ss(typeof i == "string" ? i : i + "", void 0, _i), C = (i, ...t) => {
  const e = i.length === 1 ? i[0] : t.reduce((s, n, r) => s + ((o) => {
    if (o._$cssResult$ === !0)
      return o.cssText;
    if (typeof o == "number")
      return o;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(n) + i[r + 1], i[0]);
  return new ss(e, i, _i);
}, wr = (i, t) => {
  if (yi)
    i.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet);
  else
    for (const e of t) {
      const s = document.createElement("style"), n = _e.litNonce;
      n !== void 0 && s.setAttribute("nonce", n), s.textContent = e.cssText, i.appendChild(s);
    }
}, ln = yi ? (i) => i : (i) => i instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const s of t.cssRules)
    e += s.cssText;
  return xr(e);
})(i) : i;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: $r, defineProperty: Cr, getOwnPropertyDescriptor: Er, getOwnPropertyNames: Sr, getOwnPropertySymbols: Ar, getPrototypeOf: Or } = Object, at = globalThis, an = at.trustedTypes, kr = an ? an.emptyScript : "", Ye = at.reactiveElementPolyfillSupport, Kt = (i, t) => i, Ee = { toAttribute(i, t) {
  switch (t) {
    case Boolean:
      i = i ? kr : null;
      break;
    case Object:
    case Array:
      i = i == null ? i : JSON.stringify(i);
  }
  return i;
}, fromAttribute(i, t) {
  let e = i;
  switch (t) {
    case Boolean:
      e = i !== null;
      break;
    case Number:
      e = i === null ? null : Number(i);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(i);
      } catch {
        e = null;
      }
  }
  return e;
} }, xi = (i, t) => !$r(i, t), cn = { attribute: !0, type: String, converter: Ee, reflect: !1, hasChanged: xi };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), at.litPropertyMetadata ?? (at.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
class It extends HTMLElement {
  static addInitializer(t) {
    this._$Ei(), (this.l ?? (this.l = [])).push(t);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t, e = cn) {
    if (e.state && (e.attribute = !1), this._$Ei(), this.elementProperties.set(t, e), !e.noAccessor) {
      const s = Symbol(), n = this.getPropertyDescriptor(t, s, e);
      n !== void 0 && Cr(this.prototype, t, n);
    }
  }
  static getPropertyDescriptor(t, e, s) {
    const { get: n, set: r } = Er(this.prototype, t) ?? { get() {
      return this[e];
    }, set(o) {
      this[e] = o;
    } };
    return { get() {
      return n == null ? void 0 : n.call(this);
    }, set(o) {
      const a = n == null ? void 0 : n.call(this);
      r.call(this, o), this.requestUpdate(t, a, s);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) ?? cn;
  }
  static _$Ei() {
    if (this.hasOwnProperty(Kt("elementProperties")))
      return;
    const t = Or(this);
    t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(Kt("finalized")))
      return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(Kt("properties"))) {
      const e = this.properties, s = [...Sr(e), ...Ar(e)];
      for (const n of s)
        this.createProperty(n, e[n]);
    }
    const t = this[Symbol.metadata];
    if (t !== null) {
      const e = litPropertyMetadata.get(t);
      if (e !== void 0)
        for (const [s, n] of e)
          this.elementProperties.set(s, n);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [e, s] of this.elementProperties) {
      const n = this._$Eu(e, s);
      n !== void 0 && this._$Eh.set(n, e);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const s = new Set(t.flat(1 / 0).reverse());
      for (const n of s)
        e.unshift(ln(n));
    } else
      t !== void 0 && e.push(ln(t));
    return e;
  }
  static _$Eu(t, e) {
    const s = e.attribute;
    return s === !1 ? void 0 : typeof s == "string" ? s : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var t;
    this._$ES = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (t = this.constructor.l) == null || t.forEach((e) => e(this));
  }
  addController(t) {
    var e;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t), this.renderRoot !== void 0 && this.isConnected && ((e = t.hostConnected) == null || e.call(t));
  }
  removeController(t) {
    var e;
    (e = this._$EO) == null || e.delete(t);
  }
  _$E_() {
    const t = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;
    for (const s of e.keys())
      this.hasOwnProperty(s) && (t.set(s, this[s]), delete this[s]);
    t.size > 0 && (this._$Ep = t);
  }
  createRenderRoot() {
    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return wr(t, this.constructor.elementStyles), t;
  }
  connectedCallback() {
    var t;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (t = this._$EO) == null || t.forEach((e) => {
      var s;
      return (s = e.hostConnected) == null ? void 0 : s.call(e);
    });
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    var t;
    (t = this._$EO) == null || t.forEach((e) => {
      var s;
      return (s = e.hostDisconnected) == null ? void 0 : s.call(e);
    });
  }
  attributeChangedCallback(t, e, s) {
    this._$AK(t, s);
  }
  _$EC(t, e) {
    var r;
    const s = this.constructor.elementProperties.get(t), n = this.constructor._$Eu(t, s);
    if (n !== void 0 && s.reflect === !0) {
      const o = (((r = s.converter) == null ? void 0 : r.toAttribute) !== void 0 ? s.converter : Ee).toAttribute(e, s.type);
      this._$Em = t, o == null ? this.removeAttribute(n) : this.setAttribute(n, o), this._$Em = null;
    }
  }
  _$AK(t, e) {
    var r;
    const s = this.constructor, n = s._$Eh.get(t);
    if (n !== void 0 && this._$Em !== n) {
      const o = s.getPropertyOptions(n), a = typeof o.converter == "function" ? { fromAttribute: o.converter } : ((r = o.converter) == null ? void 0 : r.fromAttribute) !== void 0 ? o.converter : Ee;
      this._$Em = n, this[n] = a.fromAttribute(e, o.type), this._$Em = null;
    }
  }
  requestUpdate(t, e, s) {
    if (t !== void 0) {
      if (s ?? (s = this.constructor.getPropertyOptions(t)), !(s.hasChanged ?? xi)(this[t], e))
        return;
      this.P(t, e, s);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$ET());
  }
  P(t, e, s) {
    this._$AL.has(t) || this._$AL.set(t, e), s.reflect === !0 && this._$Em !== t && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(t);
  }
  async _$ET() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (e) {
      Promise.reject(e);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var s;
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [r, o] of this._$Ep)
          this[r] = o;
        this._$Ep = void 0;
      }
      const n = this.constructor.elementProperties;
      if (n.size > 0)
        for (const [r, o] of n)
          o.wrapped !== !0 || this._$AL.has(r) || this[r] === void 0 || this.P(r, this[r], o);
    }
    let t = !1;
    const e = this._$AL;
    try {
      t = this.shouldUpdate(e), t ? (this.willUpdate(e), (s = this._$EO) == null || s.forEach((n) => {
        var r;
        return (r = n.hostUpdate) == null ? void 0 : r.call(n);
      }), this.update(e)) : this._$EU();
    } catch (n) {
      throw t = !1, this._$EU(), n;
    }
    t && this._$AE(e);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    var e;
    (e = this._$EO) == null || e.forEach((s) => {
      var n;
      return (n = s.hostUpdated) == null ? void 0 : n.call(s);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((e) => this._$EC(e, this[e]))), this._$EU();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
}
It.elementStyles = [], It.shadowRootOptions = { mode: "open" }, It[Kt("elementProperties")] = /* @__PURE__ */ new Map(), It[Kt("finalized")] = /* @__PURE__ */ new Map(), Ye == null || Ye({ ReactiveElement: It }), (at.reactiveElementVersions ?? (at.reactiveElementVersions = [])).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Xt = globalThis, Se = Xt.trustedTypes, un = Se ? Se.createPolicy("lit-html", { createHTML: (i) => i }) : void 0, rs = "$lit$", lt = `lit$${Math.random().toFixed(9).slice(2)}$`, os = "?" + lt, Pr = `<${os}>`, St = document, ie = () => St.createComment(""), ne = (i) => i === null || typeof i != "object" && typeof i != "function", wi = Array.isArray, Tr = (i) => wi(i) || typeof (i == null ? void 0 : i[Symbol.iterator]) == "function", Ge = `[ 	
\f\r]`, Yt = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, hn = /-->/g, dn = />/g, xt = RegExp(`>|${Ge}(?:([^\\s"'>=/]+)(${Ge}*=${Ge}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), fn = /'/g, pn = /"/g, ls = /^(?:script|style|textarea|title)$/i, Ir = (i) => (t, ...e) => ({ _$litType$: i, strings: t, values: e }), m = Ir(1), At = Symbol.for("lit-noChange"), k = Symbol.for("lit-nothing"), mn = /* @__PURE__ */ new WeakMap(), wt = St.createTreeWalker(St, 129);
function as(i, t) {
  if (!wi(i) || !i.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return un !== void 0 ? un.createHTML(t) : t;
}
const Lr = (i, t) => {
  const e = i.length - 1, s = [];
  let n, r = t === 2 ? "<svg>" : t === 3 ? "<math>" : "", o = Yt;
  for (let a = 0; a < e; a++) {
    const l = i[a];
    let c, u, d = -1, f = 0;
    for (; f < l.length && (o.lastIndex = f, u = o.exec(l), u !== null); )
      f = o.lastIndex, o === Yt ? u[1] === "!--" ? o = hn : u[1] !== void 0 ? o = dn : u[2] !== void 0 ? (ls.test(u[2]) && (n = RegExp("</" + u[2], "g")), o = xt) : u[3] !== void 0 && (o = xt) : o === xt ? u[0] === ">" ? (o = n ?? Yt, d = -1) : u[1] === void 0 ? d = -2 : (d = o.lastIndex - u[2].length, c = u[1], o = u[3] === void 0 ? xt : u[3] === '"' ? pn : fn) : o === pn || o === fn ? o = xt : o === hn || o === dn ? o = Yt : (o = xt, n = void 0);
    const p = o === xt && i[a + 1].startsWith("/>") ? " " : "";
    r += o === Yt ? l + Pr : d >= 0 ? (s.push(c), l.slice(0, d) + rs + l.slice(d) + lt + p) : l + lt + (d === -2 ? a : p);
  }
  return [as(i, r + (i[e] || "<?>") + (t === 2 ? "</svg>" : t === 3 ? "</math>" : "")), s];
};
class se {
  constructor({ strings: t, _$litType$: e }, s) {
    let n;
    this.parts = [];
    let r = 0, o = 0;
    const a = t.length - 1, l = this.parts, [c, u] = Lr(t, e);
    if (this.el = se.createElement(c, s), wt.currentNode = this.el.content, e === 2 || e === 3) {
      const d = this.el.content.firstChild;
      d.replaceWith(...d.childNodes);
    }
    for (; (n = wt.nextNode()) !== null && l.length < a; ) {
      if (n.nodeType === 1) {
        if (n.hasAttributes())
          for (const d of n.getAttributeNames())
            if (d.endsWith(rs)) {
              const f = u[o++], p = n.getAttribute(d).split(lt), b = /([.?@])?(.*)/.exec(f);
              l.push({ type: 1, index: r, name: b[2], strings: p, ctor: b[1] === "." ? zr : b[1] === "?" ? Mr : b[1] === "@" ? jr : De }), n.removeAttribute(d);
            } else
              d.startsWith(lt) && (l.push({ type: 6, index: r }), n.removeAttribute(d));
        if (ls.test(n.tagName)) {
          const d = n.textContent.split(lt), f = d.length - 1;
          if (f > 0) {
            n.textContent = Se ? Se.emptyScript : "";
            for (let p = 0; p < f; p++)
              n.append(d[p], ie()), wt.nextNode(), l.push({ type: 2, index: ++r });
            n.append(d[f], ie());
          }
        }
      } else if (n.nodeType === 8)
        if (n.data === os)
          l.push({ type: 2, index: r });
        else {
          let d = -1;
          for (; (d = n.data.indexOf(lt, d + 1)) !== -1; )
            l.push({ type: 7, index: r }), d += lt.length - 1;
        }
      r++;
    }
  }
  static createElement(t, e) {
    const s = St.createElement("template");
    return s.innerHTML = t, s;
  }
}
function jt(i, t, e = i, s) {
  var o, a;
  if (t === At)
    return t;
  let n = s !== void 0 ? (o = e.o) == null ? void 0 : o[s] : e.l;
  const r = ne(t) ? void 0 : t._$litDirective$;
  return (n == null ? void 0 : n.constructor) !== r && ((a = n == null ? void 0 : n._$AO) == null || a.call(n, !1), r === void 0 ? n = void 0 : (n = new r(i), n._$AT(i, e, s)), s !== void 0 ? (e.o ?? (e.o = []))[s] = n : e.l = n), n !== void 0 && (t = jt(i, n._$AS(i, t.values), n, s)), t;
}
class Rr {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    const { el: { content: e }, parts: s } = this._$AD, n = ((t == null ? void 0 : t.creationScope) ?? St).importNode(e, !0);
    wt.currentNode = n;
    let r = wt.nextNode(), o = 0, a = 0, l = s[0];
    for (; l !== void 0; ) {
      if (o === l.index) {
        let c;
        l.type === 2 ? c = new he(r, r.nextSibling, this, t) : l.type === 1 ? c = new l.ctor(r, l.name, l.strings, this, t) : l.type === 6 && (c = new Br(r, this, t)), this._$AV.push(c), l = s[++a];
      }
      o !== (l == null ? void 0 : l.index) && (r = wt.nextNode(), o++);
    }
    return wt.currentNode = St, n;
  }
  p(t) {
    let e = 0;
    for (const s of this._$AV)
      s !== void 0 && (s.strings !== void 0 ? (s._$AI(t, s, e), e += s.strings.length - 2) : s._$AI(t[e])), e++;
  }
}
class he {
  get _$AU() {
    var t;
    return ((t = this._$AM) == null ? void 0 : t._$AU) ?? this.v;
  }
  constructor(t, e, s, n) {
    this.type = 2, this._$AH = k, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = s, this.options = n, this.v = (n == null ? void 0 : n.isConnected) ?? !0;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = jt(this, t, e), ne(t) ? t === k || t == null || t === "" ? (this._$AH !== k && this._$AR(), this._$AH = k) : t !== this._$AH && t !== At && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : Tr(t) ? this.k(t) : this._(t);
  }
  O(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.O(t));
  }
  _(t) {
    this._$AH !== k && ne(this._$AH) ? this._$AA.nextSibling.data = t : this.T(St.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    var r;
    const { values: e, _$litType$: s } = t, n = typeof s == "number" ? this._$AC(t) : (s.el === void 0 && (s.el = se.createElement(as(s.h, s.h[0]), this.options)), s);
    if (((r = this._$AH) == null ? void 0 : r._$AD) === n)
      this._$AH.p(e);
    else {
      const o = new Rr(n, this), a = o.u(this.options);
      o.p(e), this.T(a), this._$AH = o;
    }
  }
  _$AC(t) {
    let e = mn.get(t.strings);
    return e === void 0 && mn.set(t.strings, e = new se(t)), e;
  }
  k(t) {
    wi(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let s, n = 0;
    for (const r of t)
      n === e.length ? e.push(s = new he(this.O(ie()), this.O(ie()), this, this.options)) : s = e[n], s._$AI(r), n++;
    n < e.length && (this._$AR(s && s._$AB.nextSibling, n), e.length = n);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    var s;
    for ((s = this._$AP) == null ? void 0 : s.call(this, !1, !0, e); t && t !== this._$AB; ) {
      const n = t.nextSibling;
      t.remove(), t = n;
    }
  }
  setConnected(t) {
    var e;
    this._$AM === void 0 && (this.v = t, (e = this._$AP) == null || e.call(this, t));
  }
}
class De {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, e, s, n, r) {
    this.type = 1, this._$AH = k, this._$AN = void 0, this.element = t, this.name = e, this._$AM = n, this.options = r, s.length > 2 || s[0] !== "" || s[1] !== "" ? (this._$AH = Array(s.length - 1).fill(new String()), this.strings = s) : this._$AH = k;
  }
  _$AI(t, e = this, s, n) {
    const r = this.strings;
    let o = !1;
    if (r === void 0)
      t = jt(this, t, e, 0), o = !ne(t) || t !== this._$AH && t !== At, o && (this._$AH = t);
    else {
      const a = t;
      let l, c;
      for (t = r[0], l = 0; l < r.length - 1; l++)
        c = jt(this, a[s + l], e, l), c === At && (c = this._$AH[l]), o || (o = !ne(c) || c !== this._$AH[l]), c === k ? t = k : t !== k && (t += (c ?? "") + r[l + 1]), this._$AH[l] = c;
    }
    o && !n && this.j(t);
  }
  j(t) {
    t === k ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
}
class zr extends De {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === k ? void 0 : t;
  }
}
class Mr extends De {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== k);
  }
}
class jr extends De {
  constructor(t, e, s, n, r) {
    super(t, e, s, n, r), this.type = 5;
  }
  _$AI(t, e = this) {
    if ((t = jt(this, t, e, 0) ?? k) === At)
      return;
    const s = this._$AH, n = t === k && s !== k || t.capture !== s.capture || t.once !== s.once || t.passive !== s.passive, r = t !== k && (s === k || n);
    n && this.element.removeEventListener(this.name, this, s), r && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var e;
    typeof this._$AH == "function" ? this._$AH.call(((e = this.options) == null ? void 0 : e.host) ?? this.element, t) : this._$AH.handleEvent(t);
  }
}
class Br {
  constructor(t, e, s) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = s;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    jt(this, t);
  }
}
const Ke = Xt.litHtmlPolyfillSupport;
Ke == null || Ke(se, he), (Xt.litHtmlVersions ?? (Xt.litHtmlVersions = [])).push("3.2.0");
const Bt = (i, t, e) => {
  const s = (e == null ? void 0 : e.renderBefore) ?? t;
  let n = s._$litPart$;
  if (n === void 0) {
    const r = (e == null ? void 0 : e.renderBefore) ?? null;
    s._$litPart$ = n = new he(t.insertBefore(ie(), r), r, void 0, e ?? {});
  }
  return n._$AI(i), n;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
class w extends It {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this.o = void 0;
  }
  createRenderRoot() {
    var e;
    const t = super.createRenderRoot();
    return (e = this.renderOptions).renderBefore ?? (e.renderBefore = t.firstChild), t;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this.o = Bt(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this.o) == null || t.setConnected(!0);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this.o) == null || t.setConnected(!1);
  }
  render() {
    return At;
  }
}
var jn;
w._$litElement$ = !0, w.finalized = !0, (jn = globalThis.litElementHydrateSupport) == null || jn.call(globalThis, { LitElement: w });
const Xe = globalThis.litElementPolyfillSupport;
Xe == null || Xe({ LitElement: w });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.1.0");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Nr = { attribute: !0, type: String, converter: Ee, reflect: !1, hasChanged: xi }, Hr = (i = Nr, t, e) => {
  const { kind: s, metadata: n } = e;
  let r = globalThis.litPropertyMetadata.get(n);
  if (r === void 0 && globalThis.litPropertyMetadata.set(n, r = /* @__PURE__ */ new Map()), r.set(e.name, i), s === "accessor") {
    const { name: o } = e;
    return { set(a) {
      const l = t.get.call(this);
      t.set.call(this, a), this.requestUpdate(o, l, i);
    }, init(a) {
      return a !== void 0 && this.P(o, void 0, i), a;
    } };
  }
  if (s === "setter") {
    const { name: o } = e;
    return function(a) {
      const l = this[o];
      t.call(this, a), this.requestUpdate(o, l, i);
    };
  }
  throw Error("Unsupported decorator location: " + s);
};
function h(i) {
  return (t, e) => typeof e == "object" ? Hr(i, t, e) : ((s, n, r) => {
    const o = n.hasOwnProperty(r);
    return n.constructor.createProperty(r, o ? { ...s, wrapped: !0 } : s), o ? Object.getOwnPropertyDescriptor(n, r) : void 0;
  })(i, t, e);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function Vt(i) {
  return h({ ...i, state: !0, attribute: !1 });
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Dr = (i) => i.strings === void 0;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const cs = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 }, us = (i) => (...t) => ({ _$litDirective$: i, values: t });
class hs {
  constructor(t) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, e, s) {
    this.t = t, this._$AM = e, this.i = s;
  }
  _$AS(t, e) {
    return this.update(t, e);
  }
  update(t, e) {
    return this.render(...e);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Jt = (i, t) => {
  var s;
  const e = i._$AN;
  if (e === void 0)
    return !1;
  for (const n of e)
    (s = n._$AO) == null || s.call(n, t, !1), Jt(n, t);
  return !0;
}, Ae = (i) => {
  let t, e;
  do {
    if ((t = i._$AM) === void 0)
      break;
    e = t._$AN, e.delete(i), i = t;
  } while ((e == null ? void 0 : e.size) === 0);
}, ds = (i) => {
  for (let t; t = i._$AM; i = t) {
    let e = t._$AN;
    if (e === void 0)
      t._$AN = e = /* @__PURE__ */ new Set();
    else if (e.has(i))
      break;
    e.add(i), Ur(t);
  }
};
function Fr(i) {
  this._$AN !== void 0 ? (Ae(this), this._$AM = i, ds(this)) : this._$AM = i;
}
function Vr(i, t = !1, e = 0) {
  const s = this._$AH, n = this._$AN;
  if (n !== void 0 && n.size !== 0)
    if (t)
      if (Array.isArray(s))
        for (let r = e; r < s.length; r++)
          Jt(s[r], !1), Ae(s[r]);
      else
        s != null && (Jt(s, !1), Ae(s));
    else
      Jt(this, i);
}
const Ur = (i) => {
  i.type == cs.CHILD && (i._$AP ?? (i._$AP = Vr), i._$AQ ?? (i._$AQ = Fr));
};
class qr extends hs {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(t, e, s) {
    super._$AT(t, e, s), ds(this), this.isConnected = t._$AU;
  }
  _$AO(t, e = !0) {
    var s, n;
    t !== this.isConnected && (this.isConnected = t, t ? (s = this.reconnected) == null || s.call(this) : (n = this.disconnected) == null || n.call(this)), e && (Jt(this, t), Ae(this));
  }
  setValue(t) {
    if (Dr(this.t))
      this.t._$AI(t, this);
    else {
      const e = [...this.t._$AH];
      e[this.i] = t, this.t._$AI(e, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Nt = () => new Wr();
class Wr {
}
const Je = /* @__PURE__ */ new WeakMap(), Ht = us(class extends qr {
  render(i) {
    return k;
  }
  update(i, [t]) {
    var s;
    const e = t !== this.Y;
    return e && this.Y !== void 0 && this.rt(void 0), (e || this.lt !== this.ct) && (this.Y = t, this.ht = (s = i.options) == null ? void 0 : s.host, this.rt(this.ct = i.element)), k;
  }
  rt(i) {
    if (this.isConnected || (i = void 0), typeof this.Y == "function") {
      const t = this.ht ?? globalThis;
      let e = Je.get(t);
      e === void 0 && (e = /* @__PURE__ */ new WeakMap(), Je.set(t, e)), e.get(this.Y) !== void 0 && this.Y.call(this.ht, void 0), e.set(this.Y, i), i !== void 0 && this.Y.call(this.ht, i);
    } else
      this.Y.value = i;
  }
  get lt() {
    var i, t;
    return typeof this.Y == "function" ? (i = Je.get(this.ht ?? globalThis)) == null ? void 0 : i.get(this.Y) : (t = this.Y) == null ? void 0 : t.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
/**
* (c) Iconify
*
* For the full copyright and license information, please view the license.txt
* files at https://github.com/iconify/iconify
*
* Licensed under MIT.
*
* @license MIT
* @version 2.0.0
*/
const fs = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
), Oe = Object.freeze({
  rotate: 0,
  vFlip: !1,
  hFlip: !1
}), de = Object.freeze({
  ...fs,
  ...Oe
}), ri = Object.freeze({
  ...de,
  body: "",
  hidden: !1
}), Qr = Object.freeze({
  width: null,
  height: null
}), ps = Object.freeze({
  // Dimensions
  ...Qr,
  // Transformations
  ...Oe
});
function Yr(i, t = 0) {
  const e = i.replace(/^-?[0-9.]*/, "");
  function s(n) {
    for (; n < 0; )
      n += 4;
    return n % 4;
  }
  if (e === "") {
    const n = parseInt(i);
    return isNaN(n) ? 0 : s(n);
  } else if (e !== i) {
    let n = 0;
    switch (e) {
      case "%":
        n = 25;
        break;
      case "deg":
        n = 90;
    }
    if (n) {
      let r = parseFloat(i.slice(0, i.length - e.length));
      return isNaN(r) ? 0 : (r = r / n, r % 1 === 0 ? s(r) : 0);
    }
  }
  return t;
}
const Gr = /[\s,]+/;
function Kr(i, t) {
  t.split(Gr).forEach((e) => {
    switch (e.trim()) {
      case "horizontal":
        i.hFlip = !0;
        break;
      case "vertical":
        i.vFlip = !0;
        break;
    }
  });
}
const ms = {
  ...ps,
  preserveAspectRatio: ""
};
function bn(i) {
  const t = {
    ...ms
  }, e = (s, n) => i.getAttribute(s) || n;
  return t.width = e("width", null), t.height = e("height", null), t.rotate = Yr(e("rotate", "")), Kr(t, e("flip", "")), t.preserveAspectRatio = e("preserveAspectRatio", e("preserveaspectratio", "")), t;
}
function Xr(i, t) {
  for (const e in ms)
    if (i[e] !== t[e])
      return !0;
  return !1;
}
const Zt = /^[a-z0-9]+(-[a-z0-9]+)*$/, fe = (i, t, e, s = "") => {
  const n = i.split(":");
  if (i.slice(0, 1) === "@") {
    if (n.length < 2 || n.length > 3)
      return null;
    s = n.shift().slice(1);
  }
  if (n.length > 3 || !n.length)
    return null;
  if (n.length > 1) {
    const a = n.pop(), l = n.pop(), c = {
      // Allow provider without '@': "provider:prefix:name"
      provider: n.length > 0 ? n[0] : s,
      prefix: l,
      name: a
    };
    return t && !xe(c) ? null : c;
  }
  const r = n[0], o = r.split("-");
  if (o.length > 1) {
    const a = {
      provider: s,
      prefix: o.shift(),
      name: o.join("-")
    };
    return t && !xe(a) ? null : a;
  }
  if (e && s === "") {
    const a = {
      provider: s,
      prefix: "",
      name: r
    };
    return t && !xe(a, e) ? null : a;
  }
  return null;
}, xe = (i, t) => i ? !!((i.provider === "" || i.provider.match(Zt)) && (t && i.prefix === "" || i.prefix.match(Zt)) && i.name.match(Zt)) : !1;
function Jr(i, t) {
  const e = {};
  !i.hFlip != !t.hFlip && (e.hFlip = !0), !i.vFlip != !t.vFlip && (e.vFlip = !0);
  const s = ((i.rotate || 0) + (t.rotate || 0)) % 4;
  return s && (e.rotate = s), e;
}
function gn(i, t) {
  const e = Jr(i, t);
  for (const s in ri)
    s in Oe ? s in i && !(s in e) && (e[s] = Oe[s]) : s in t ? e[s] = t[s] : s in i && (e[s] = i[s]);
  return e;
}
function Zr(i, t) {
  const e = i.icons, s = i.aliases || /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
  function r(o) {
    if (e[o])
      return n[o] = [];
    if (!(o in n)) {
      n[o] = null;
      const a = s[o] && s[o].parent, l = a && r(a);
      l && (n[o] = [a].concat(l));
    }
    return n[o];
  }
  return Object.keys(e).concat(Object.keys(s)).forEach(r), n;
}
function to(i, t, e) {
  const s = i.icons, n = i.aliases || /* @__PURE__ */ Object.create(null);
  let r = {};
  function o(a) {
    r = gn(
      s[a] || n[a],
      r
    );
  }
  return o(t), e.forEach(o), gn(i, r);
}
function bs(i, t) {
  const e = [];
  if (typeof i != "object" || typeof i.icons != "object")
    return e;
  i.not_found instanceof Array && i.not_found.forEach((n) => {
    t(n, null), e.push(n);
  });
  const s = Zr(i);
  for (const n in s) {
    const r = s[n];
    r && (t(n, to(i, n, r)), e.push(n));
  }
  return e;
}
const eo = {
  provider: "",
  aliases: {},
  not_found: {},
  ...fs
};
function Ze(i, t) {
  for (const e in t)
    if (e in i && typeof i[e] != typeof t[e])
      return !1;
  return !0;
}
function gs(i) {
  if (typeof i != "object" || i === null)
    return null;
  const t = i;
  if (typeof t.prefix != "string" || !i.icons || typeof i.icons != "object" || !Ze(i, eo))
    return null;
  const e = t.icons;
  for (const n in e) {
    const r = e[n];
    if (!n.match(Zt) || typeof r.body != "string" || !Ze(
      r,
      ri
    ))
      return null;
  }
  const s = t.aliases || /* @__PURE__ */ Object.create(null);
  for (const n in s) {
    const r = s[n], o = r.parent;
    if (!n.match(Zt) || typeof o != "string" || !e[o] && !s[o] || !Ze(
      r,
      ri
    ))
      return null;
  }
  return t;
}
const ke = /* @__PURE__ */ Object.create(null);
function io(i, t) {
  return {
    provider: i,
    prefix: t,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function ht(i, t) {
  const e = ke[i] || (ke[i] = /* @__PURE__ */ Object.create(null));
  return e[t] || (e[t] = io(i, t));
}
function $i(i, t) {
  return gs(t) ? bs(t, (e, s) => {
    s ? i.icons[e] = s : i.missing.add(e);
  }) : [];
}
function no(i, t, e) {
  try {
    if (typeof e.body == "string")
      return i.icons[t] = { ...e }, !0;
  } catch {
  }
  return !1;
}
function so(i, t) {
  let e = [];
  return (typeof i == "string" ? [i] : Object.keys(ke)).forEach((n) => {
    (typeof n == "string" && typeof t == "string" ? [t] : Object.keys(ke[n] || {})).forEach((o) => {
      const a = ht(n, o);
      e = e.concat(
        Object.keys(a.icons).map(
          (l) => (n !== "" ? "@" + n + ":" : "") + o + ":" + l
        )
      );
    });
  }), e;
}
let re = !1;
function vs(i) {
  return typeof i == "boolean" && (re = i), re;
}
function oe(i) {
  const t = typeof i == "string" ? fe(i, !0, re) : i;
  if (t) {
    const e = ht(t.provider, t.prefix), s = t.name;
    return e.icons[s] || (e.missing.has(s) ? null : void 0);
  }
}
function ys(i, t) {
  const e = fe(i, !0, re);
  if (!e)
    return !1;
  const s = ht(e.provider, e.prefix);
  return no(s, e.name, t);
}
function vn(i, t) {
  if (typeof i != "object")
    return !1;
  if (typeof t != "string" && (t = i.provider || ""), re && !t && !i.prefix) {
    let n = !1;
    return gs(i) && (i.prefix = "", bs(i, (r, o) => {
      o && ys(r, o) && (n = !0);
    })), n;
  }
  const e = i.prefix;
  if (!xe({
    provider: t,
    prefix: e,
    name: "a"
  }))
    return !1;
  const s = ht(t, e);
  return !!$i(s, i);
}
function yn(i) {
  return !!oe(i);
}
function ro(i) {
  const t = oe(i);
  return t ? {
    ...de,
    ...t
  } : null;
}
function oo(i) {
  const t = {
    loaded: [],
    missing: [],
    pending: []
  }, e = /* @__PURE__ */ Object.create(null);
  i.sort((n, r) => n.provider !== r.provider ? n.provider.localeCompare(r.provider) : n.prefix !== r.prefix ? n.prefix.localeCompare(r.prefix) : n.name.localeCompare(r.name));
  let s = {
    provider: "",
    prefix: "",
    name: ""
  };
  return i.forEach((n) => {
    if (s.name === n.name && s.prefix === n.prefix && s.provider === n.provider)
      return;
    s = n;
    const r = n.provider, o = n.prefix, a = n.name, l = e[r] || (e[r] = /* @__PURE__ */ Object.create(null)), c = l[o] || (l[o] = ht(r, o));
    let u;
    a in c.icons ? u = t.loaded : o === "" || c.missing.has(a) ? u = t.missing : u = t.pending;
    const d = {
      provider: r,
      prefix: o,
      name: a
    };
    u.push(d);
  }), t;
}
function _s(i, t) {
  i.forEach((e) => {
    const s = e.loaderCallbacks;
    s && (e.loaderCallbacks = s.filter((n) => n.id !== t));
  });
}
function lo(i) {
  i.pendingCallbacksFlag || (i.pendingCallbacksFlag = !0, setTimeout(() => {
    i.pendingCallbacksFlag = !1;
    const t = i.loaderCallbacks ? i.loaderCallbacks.slice(0) : [];
    if (!t.length)
      return;
    let e = !1;
    const s = i.provider, n = i.prefix;
    t.forEach((r) => {
      const o = r.icons, a = o.pending.length;
      o.pending = o.pending.filter((l) => {
        if (l.prefix !== n)
          return !0;
        const c = l.name;
        if (i.icons[c])
          o.loaded.push({
            provider: s,
            prefix: n,
            name: c
          });
        else if (i.missing.has(c))
          o.missing.push({
            provider: s,
            prefix: n,
            name: c
          });
        else
          return e = !0, !0;
        return !1;
      }), o.pending.length !== a && (e || _s([i], r.id), r.callback(
        o.loaded.slice(0),
        o.missing.slice(0),
        o.pending.slice(0),
        r.abort
      ));
    });
  }));
}
let ao = 0;
function co(i, t, e) {
  const s = ao++, n = _s.bind(null, e, s);
  if (!t.pending.length)
    return n;
  const r = {
    id: s,
    icons: t,
    callback: i,
    abort: n
  };
  return e.forEach((o) => {
    (o.loaderCallbacks || (o.loaderCallbacks = [])).push(r);
  }), n;
}
const oi = /* @__PURE__ */ Object.create(null);
function _n(i, t) {
  oi[i] = t;
}
function li(i) {
  return oi[i] || oi[""];
}
function uo(i, t = !0, e = !1) {
  const s = [];
  return i.forEach((n) => {
    const r = typeof n == "string" ? fe(n, t, e) : n;
    r && s.push(r);
  }), s;
}
var ho = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: !1,
  dataAfterTimeout: !1
};
function fo(i, t, e, s) {
  const n = i.resources.length, r = i.random ? Math.floor(Math.random() * n) : i.index;
  let o;
  if (i.random) {
    let _ = i.resources.slice(0);
    for (o = []; _.length > 1; ) {
      const I = Math.floor(Math.random() * _.length);
      o.push(_[I]), _ = _.slice(0, I).concat(_.slice(I + 1));
    }
    o = o.concat(_);
  } else
    o = i.resources.slice(r).concat(i.resources.slice(0, r));
  const a = Date.now();
  let l = "pending", c = 0, u, d = null, f = [], p = [];
  typeof s == "function" && p.push(s);
  function b() {
    d && (clearTimeout(d), d = null);
  }
  function v() {
    l === "pending" && (l = "aborted"), b(), f.forEach((_) => {
      _.status === "pending" && (_.status = "aborted");
    }), f = [];
  }
  function g(_, I) {
    I && (p = []), typeof _ == "function" && p.push(_);
  }
  function S() {
    return {
      startTime: a,
      payload: t,
      status: l,
      queriesSent: c,
      queriesPending: f.length,
      subscribe: g,
      abort: v
    };
  }
  function E() {
    l = "failed", p.forEach((_) => {
      _(void 0, u);
    });
  }
  function x() {
    f.forEach((_) => {
      _.status === "pending" && (_.status = "aborted");
    }), f = [];
  }
  function $(_, I, D) {
    const F = I !== "success";
    switch (f = f.filter((A) => A !== _), l) {
      case "pending":
        break;
      case "failed":
        if (F || !i.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (I === "abort") {
      u = D, E();
      return;
    }
    if (F) {
      u = D, f.length || (o.length ? O() : E());
      return;
    }
    if (b(), x(), !i.random) {
      const A = i.resources.indexOf(_.resource);
      A !== -1 && A !== i.index && (i.index = A);
    }
    l = "completed", p.forEach((A) => {
      A(D);
    });
  }
  function O() {
    if (l !== "pending")
      return;
    b();
    const _ = o.shift();
    if (_ === void 0) {
      if (f.length) {
        d = setTimeout(() => {
          b(), l === "pending" && (x(), E());
        }, i.timeout);
        return;
      }
      E();
      return;
    }
    const I = {
      status: "pending",
      resource: _,
      callback: (D, F) => {
        $(I, D, F);
      }
    };
    f.push(I), c++, d = setTimeout(O, i.rotate), e(_, t, I.callback);
  }
  return setTimeout(O), S;
}
function xs(i) {
  const t = {
    ...ho,
    ...i
  };
  let e = [];
  function s() {
    e = e.filter((a) => a().status === "pending");
  }
  function n(a, l, c) {
    const u = fo(
      t,
      a,
      l,
      (d, f) => {
        s(), c && c(d, f);
      }
    );
    return e.push(u), u;
  }
  function r(a) {
    return e.find((l) => a(l)) || null;
  }
  return {
    query: n,
    find: r,
    setIndex: (a) => {
      t.index = a;
    },
    getIndex: () => t.index,
    cleanup: s
  };
}
function Ci(i) {
  let t;
  if (typeof i.resources == "string")
    t = [i.resources];
  else if (t = i.resources, !(t instanceof Array) || !t.length)
    return null;
  return {
    // API hosts
    resources: t,
    // Root path
    path: i.path || "/",
    // URL length limit
    maxURL: i.maxURL || 500,
    // Timeout before next host is used.
    rotate: i.rotate || 750,
    // Timeout before failing query.
    timeout: i.timeout || 5e3,
    // Randomise default API end point.
    random: i.random === !0,
    // Start index
    index: i.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: i.dataAfterTimeout !== !1
  };
}
const Fe = /* @__PURE__ */ Object.create(null), Gt = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
], we = [];
for (; Gt.length > 0; )
  Gt.length === 1 || Math.random() > 0.5 ? we.push(Gt.shift()) : we.push(Gt.pop());
Fe[""] = Ci({
  resources: ["https://api.iconify.design"].concat(we)
});
function xn(i, t) {
  const e = Ci(t);
  return e === null ? !1 : (Fe[i] = e, !0);
}
function Ve(i) {
  return Fe[i];
}
function po() {
  return Object.keys(Fe);
}
function wn() {
}
const ti = /* @__PURE__ */ Object.create(null);
function mo(i) {
  if (!ti[i]) {
    const t = Ve(i);
    if (!t)
      return;
    const e = xs(t), s = {
      config: t,
      redundancy: e
    };
    ti[i] = s;
  }
  return ti[i];
}
function ws(i, t, e) {
  let s, n;
  if (typeof i == "string") {
    const r = li(i);
    if (!r)
      return e(void 0, 424), wn;
    n = r.send;
    const o = mo(i);
    o && (s = o.redundancy);
  } else {
    const r = Ci(i);
    if (r) {
      s = xs(r);
      const o = i.resources ? i.resources[0] : "", a = li(o);
      a && (n = a.send);
    }
  }
  return !s || !n ? (e(void 0, 424), wn) : s.query(t, n, e)().abort;
}
const $n = "iconify2", le = "iconify", $s = le + "-count", Cn = le + "-version", Cs = 36e5, bo = 168, go = 50;
function ai(i, t) {
  try {
    return i.getItem(t);
  } catch {
  }
}
function Ei(i, t, e) {
  try {
    return i.setItem(t, e), !0;
  } catch {
  }
}
function En(i, t) {
  try {
    i.removeItem(t);
  } catch {
  }
}
function ci(i, t) {
  return Ei(i, $s, t.toString());
}
function ui(i) {
  return parseInt(ai(i, $s)) || 0;
}
const $t = {
  local: !0,
  session: !0
}, Es = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
let Si = !1;
function vo(i) {
  Si = i;
}
let ye = typeof window > "u" ? {} : window;
function Ss(i) {
  const t = i + "Storage";
  try {
    if (ye && ye[t] && typeof ye[t].length == "number")
      return ye[t];
  } catch {
  }
  $t[i] = !1;
}
function As(i, t) {
  const e = Ss(i);
  if (!e)
    return;
  const s = ai(e, Cn);
  if (s !== $n) {
    if (s) {
      const a = ui(e);
      for (let l = 0; l < a; l++)
        En(e, le + l.toString());
    }
    Ei(e, Cn, $n), ci(e, 0);
    return;
  }
  const n = Math.floor(Date.now() / Cs) - bo, r = (a) => {
    const l = le + a.toString(), c = ai(e, l);
    if (typeof c == "string") {
      try {
        const u = JSON.parse(c);
        if (typeof u == "object" && typeof u.cached == "number" && u.cached > n && typeof u.provider == "string" && typeof u.data == "object" && typeof u.data.prefix == "string" && // Valid item: run callback
        t(u, a))
          return !0;
      } catch {
      }
      En(e, l);
    }
  };
  let o = ui(e);
  for (let a = o - 1; a >= 0; a--)
    r(a) || (a === o - 1 ? (o--, ci(e, o)) : Es[i].add(a));
}
function Os() {
  if (!Si) {
    vo(!0);
    for (const i in $t)
      As(i, (t) => {
        const e = t.data, s = t.provider, n = e.prefix, r = ht(
          s,
          n
        );
        if (!$i(r, e).length)
          return !1;
        const o = e.lastModified || -1;
        return r.lastModifiedCached = r.lastModifiedCached ? Math.min(r.lastModifiedCached, o) : o, !0;
      });
  }
}
function yo(i, t) {
  const e = i.lastModifiedCached;
  if (
    // Matches or newer
    e && e >= t
  )
    return e === t;
  if (i.lastModifiedCached = t, e)
    for (const s in $t)
      As(s, (n) => {
        const r = n.data;
        return n.provider !== i.provider || r.prefix !== i.prefix || r.lastModified === t;
      });
  return !0;
}
function _o(i, t) {
  Si || Os();
  function e(s) {
    let n;
    if (!$t[s] || !(n = Ss(s)))
      return;
    const r = Es[s];
    let o;
    if (r.size)
      r.delete(o = Array.from(r).shift());
    else if (o = ui(n), o >= go || !ci(n, o + 1))
      return;
    const a = {
      cached: Math.floor(Date.now() / Cs),
      provider: i.provider,
      data: t
    };
    return Ei(
      n,
      le + o.toString(),
      JSON.stringify(a)
    );
  }
  t.lastModified && !yo(i, t.lastModified) || Object.keys(t.icons).length && (t.not_found && (t = Object.assign({}, t), delete t.not_found), e("local") || e("session"));
}
function Sn() {
}
function xo(i) {
  i.iconsLoaderFlag || (i.iconsLoaderFlag = !0, setTimeout(() => {
    i.iconsLoaderFlag = !1, lo(i);
  }));
}
function wo(i, t) {
  i.iconsToLoad ? i.iconsToLoad = i.iconsToLoad.concat(t).sort() : i.iconsToLoad = t, i.iconsQueueFlag || (i.iconsQueueFlag = !0, setTimeout(() => {
    i.iconsQueueFlag = !1;
    const { provider: e, prefix: s } = i, n = i.iconsToLoad;
    delete i.iconsToLoad;
    let r;
    if (!n || !(r = li(e)))
      return;
    r.prepare(e, s, n).forEach((a) => {
      ws(e, a, (l) => {
        if (typeof l != "object")
          a.icons.forEach((c) => {
            i.missing.add(c);
          });
        else
          try {
            const c = $i(
              i,
              l
            );
            if (!c.length)
              return;
            const u = i.pendingIcons;
            u && c.forEach((d) => {
              u.delete(d);
            }), _o(i, l);
          } catch (c) {
            console.error(c);
          }
        xo(i);
      });
    });
  }));
}
const Ai = (i, t) => {
  const e = uo(i, !0, vs()), s = oo(e);
  if (!s.pending.length) {
    let l = !0;
    return t && setTimeout(() => {
      l && t(
        s.loaded,
        s.missing,
        s.pending,
        Sn
      );
    }), () => {
      l = !1;
    };
  }
  const n = /* @__PURE__ */ Object.create(null), r = [];
  let o, a;
  return s.pending.forEach((l) => {
    const { provider: c, prefix: u } = l;
    if (u === a && c === o)
      return;
    o = c, a = u, r.push(ht(c, u));
    const d = n[c] || (n[c] = /* @__PURE__ */ Object.create(null));
    d[u] || (d[u] = []);
  }), s.pending.forEach((l) => {
    const { provider: c, prefix: u, name: d } = l, f = ht(c, u), p = f.pendingIcons || (f.pendingIcons = /* @__PURE__ */ new Set());
    p.has(d) || (p.add(d), n[c][u].push(d));
  }), r.forEach((l) => {
    const { provider: c, prefix: u } = l;
    n[c][u].length && wo(l, n[c][u]);
  }), t ? co(t, s, r) : Sn;
}, $o = (i) => new Promise((t, e) => {
  const s = typeof i == "string" ? fe(i, !0) : i;
  if (!s) {
    e(i);
    return;
  }
  Ai([s || i], (n) => {
    if (n.length && s) {
      const r = oe(s);
      if (r) {
        t({
          ...de,
          ...r
        });
        return;
      }
    }
    e(i);
  });
});
function Co(i) {
  try {
    const t = typeof i == "string" ? JSON.parse(i) : i;
    if (typeof t.body == "string")
      return {
        ...t
      };
  } catch {
  }
}
function Eo(i, t) {
  const e = typeof i == "string" ? fe(i, !0, !0) : null;
  if (!e) {
    const r = Co(i);
    return {
      value: i,
      data: r
    };
  }
  const s = oe(e);
  if (s !== void 0 || !e.prefix)
    return {
      value: i,
      name: e,
      data: s
      // could be 'null' -> icon is missing
    };
  const n = Ai([e], () => t(i, e, oe(e)));
  return {
    value: i,
    name: e,
    loading: n
  };
}
function ei(i) {
  return i.hasAttribute("inline");
}
let ks = !1;
try {
  ks = navigator.vendor.indexOf("Apple") === 0;
} catch {
}
function So(i, t) {
  switch (t) {
    case "svg":
    case "bg":
    case "mask":
      return t;
  }
  return t !== "style" && (ks || i.indexOf("<a") === -1) ? "svg" : i.indexOf("currentColor") === -1 ? "bg" : "mask";
}
const Ao = /(-?[0-9.]*[0-9]+[0-9.]*)/g, Oo = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function hi(i, t, e) {
  if (t === 1)
    return i;
  if (e = e || 100, typeof i == "number")
    return Math.ceil(i * t * e) / e;
  if (typeof i != "string")
    return i;
  const s = i.split(Ao);
  if (s === null || !s.length)
    return i;
  const n = [];
  let r = s.shift(), o = Oo.test(r);
  for (; ; ) {
    if (o) {
      const a = parseFloat(r);
      isNaN(a) ? n.push(r) : n.push(Math.ceil(a * t * e) / e);
    } else
      n.push(r);
    if (r = s.shift(), r === void 0)
      return n.join("");
    o = !o;
  }
}
function ko(i, t = "defs") {
  let e = "";
  const s = i.indexOf("<" + t);
  for (; s >= 0; ) {
    const n = i.indexOf(">", s), r = i.indexOf("</" + t);
    if (n === -1 || r === -1)
      break;
    const o = i.indexOf(">", r);
    if (o === -1)
      break;
    e += i.slice(n + 1, r).trim(), i = i.slice(0, s).trim() + i.slice(o + 1);
  }
  return {
    defs: e,
    content: i
  };
}
function Po(i, t) {
  return i ? "<defs>" + i + "</defs>" + t : t;
}
function To(i, t, e) {
  const s = ko(i);
  return Po(s.defs, t + s.content + e);
}
const Io = (i) => i === "unset" || i === "undefined" || i === "none";
function Ps(i, t) {
  const e = {
    ...de,
    ...i
  }, s = {
    ...ps,
    ...t
  }, n = {
    left: e.left,
    top: e.top,
    width: e.width,
    height: e.height
  };
  let r = e.body;
  [e, s].forEach((v) => {
    const g = [], S = v.hFlip, E = v.vFlip;
    let x = v.rotate;
    S ? E ? x += 2 : (g.push(
      "translate(" + (n.width + n.left).toString() + " " + (0 - n.top).toString() + ")"
    ), g.push("scale(-1 1)"), n.top = n.left = 0) : E && (g.push(
      "translate(" + (0 - n.left).toString() + " " + (n.height + n.top).toString() + ")"
    ), g.push("scale(1 -1)"), n.top = n.left = 0);
    let $;
    switch (x < 0 && (x -= Math.floor(x / 4) * 4), x = x % 4, x) {
      case 1:
        $ = n.height / 2 + n.top, g.unshift(
          "rotate(90 " + $.toString() + " " + $.toString() + ")"
        );
        break;
      case 2:
        g.unshift(
          "rotate(180 " + (n.width / 2 + n.left).toString() + " " + (n.height / 2 + n.top).toString() + ")"
        );
        break;
      case 3:
        $ = n.width / 2 + n.left, g.unshift(
          "rotate(-90 " + $.toString() + " " + $.toString() + ")"
        );
        break;
    }
    x % 2 === 1 && (n.left !== n.top && ($ = n.left, n.left = n.top, n.top = $), n.width !== n.height && ($ = n.width, n.width = n.height, n.height = $)), g.length && (r = To(
      r,
      '<g transform="' + g.join(" ") + '">',
      "</g>"
    ));
  });
  const o = s.width, a = s.height, l = n.width, c = n.height;
  let u, d;
  o === null ? (d = a === null ? "1em" : a === "auto" ? c : a, u = hi(d, l / c)) : (u = o === "auto" ? l : o, d = a === null ? hi(u, c / l) : a === "auto" ? c : a);
  const f = {}, p = (v, g) => {
    Io(g) || (f[v] = g.toString());
  };
  p("width", u), p("height", d);
  const b = [n.left, n.top, l, c];
  return f.viewBox = b.join(" "), {
    attributes: f,
    viewBox: b,
    body: r
  };
}
function Oi(i, t) {
  let e = i.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const s in t)
    e += " " + s + '="' + t[s] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + e + ">" + i + "</svg>";
}
function Lo(i) {
  return i.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function Ro(i) {
  return "data:image/svg+xml," + Lo(i);
}
function Ts(i) {
  return 'url("' + Ro(i) + '")';
}
const zo = () => {
  let i;
  try {
    if (i = fetch, typeof i == "function")
      return i;
  } catch {
  }
};
let Pe = zo();
function Mo(i) {
  Pe = i;
}
function jo() {
  return Pe;
}
function Bo(i, t) {
  const e = Ve(i);
  if (!e)
    return 0;
  let s;
  if (!e.maxURL)
    s = 0;
  else {
    let n = 0;
    e.resources.forEach((o) => {
      n = Math.max(n, o.length);
    });
    const r = t + ".json?icons=";
    s = e.maxURL - n - e.path.length - r.length;
  }
  return s;
}
function No(i) {
  return i === 404;
}
const Ho = (i, t, e) => {
  const s = [], n = Bo(i, t), r = "icons";
  let o = {
    type: r,
    provider: i,
    prefix: t,
    icons: []
  }, a = 0;
  return e.forEach((l, c) => {
    a += l.length + 1, a >= n && c > 0 && (s.push(o), o = {
      type: r,
      provider: i,
      prefix: t,
      icons: []
    }, a = l.length), o.icons.push(l);
  }), s.push(o), s;
};
function Do(i) {
  if (typeof i == "string") {
    const t = Ve(i);
    if (t)
      return t.path;
  }
  return "/";
}
const Fo = (i, t, e) => {
  if (!Pe) {
    e("abort", 424);
    return;
  }
  let s = Do(t.provider);
  switch (t.type) {
    case "icons": {
      const r = t.prefix, a = t.icons.join(","), l = new URLSearchParams({
        icons: a
      });
      s += r + ".json?" + l.toString();
      break;
    }
    case "custom": {
      const r = t.uri;
      s += r.slice(0, 1) === "/" ? r.slice(1) : r;
      break;
    }
    default:
      e("abort", 400);
      return;
  }
  let n = 503;
  Pe(i + s).then((r) => {
    const o = r.status;
    if (o !== 200) {
      setTimeout(() => {
        e(No(o) ? "abort" : "next", o);
      });
      return;
    }
    return n = 501, r.json();
  }).then((r) => {
    if (typeof r != "object" || r === null) {
      setTimeout(() => {
        r === 404 ? e("abort", r) : e("next", n);
      });
      return;
    }
    setTimeout(() => {
      e("success", r);
    });
  }).catch(() => {
    e("next", n);
  });
}, Vo = {
  prepare: Ho,
  send: Fo
};
function An(i, t) {
  switch (i) {
    case "local":
    case "session":
      $t[i] = t;
      break;
    case "all":
      for (const e in $t)
        $t[e] = t;
      break;
  }
}
const ii = "data-style";
let Is = "";
function Uo(i) {
  Is = i;
}
function On(i, t) {
  let e = Array.from(i.childNodes).find((s) => s.hasAttribute && s.hasAttribute(ii));
  e || (e = document.createElement("style"), e.setAttribute(ii, ii), i.appendChild(e)), e.textContent = ":host{display:inline-block;vertical-align:" + (t ? "-0.125em" : "0") + "}span,svg{display:block}" + Is;
}
function Ls() {
  _n("", Vo), vs(!0);
  let i;
  try {
    i = window;
  } catch {
  }
  if (i) {
    if (Os(), i.IconifyPreload !== void 0) {
      const e = i.IconifyPreload, s = "Invalid IconifyPreload syntax.";
      typeof e == "object" && e !== null && (e instanceof Array ? e : [e]).forEach((n) => {
        try {
          // Check if item is an object and not null/array
          (typeof n != "object" || n === null || n instanceof Array || // Check for 'icons' and 'prefix'
          typeof n.icons != "object" || typeof n.prefix != "string" || // Add icon set
          !vn(n)) && console.error(s);
        } catch {
          console.error(s);
        }
      });
    }
    if (i.IconifyProviders !== void 0) {
      const e = i.IconifyProviders;
      if (typeof e == "object" && e !== null)
        for (const s in e) {
          const n = "IconifyProviders[" + s + "] is invalid.";
          try {
            const r = e[s];
            if (typeof r != "object" || !r || r.resources === void 0)
              continue;
            xn(s, r) || console.error(n);
          } catch {
            console.error(n);
          }
        }
    }
  }
  return {
    enableCache: (e) => An(e, !0),
    disableCache: (e) => An(e, !1),
    iconLoaded: yn,
    iconExists: yn,
    getIcon: ro,
    listIcons: so,
    addIcon: ys,
    addCollection: vn,
    calculateSize: hi,
    buildIcon: Ps,
    iconToHTML: Oi,
    svgToURL: Ts,
    loadIcons: Ai,
    loadIcon: $o,
    addAPIProvider: xn,
    appendCustomStyle: Uo,
    _api: {
      getAPIConfig: Ve,
      setAPIModule: _n,
      sendAPIQuery: ws,
      setFetch: Mo,
      getFetch: jo,
      listAPIProviders: po
    }
  };
}
const di = {
  "background-color": "currentColor"
}, Rs = {
  "background-color": "transparent"
}, kn = {
  image: "var(--svg)",
  repeat: "no-repeat",
  size: "100% 100%"
}, Pn = {
  "-webkit-mask": di,
  mask: di,
  background: Rs
};
for (const i in Pn) {
  const t = Pn[i];
  for (const e in kn)
    t[i + "-" + e] = kn[e];
}
function Tn(i) {
  return i ? i + (i.match(/^[-0-9.]+$/) ? "px" : "") : "inherit";
}
function qo(i, t, e) {
  const s = document.createElement("span");
  let n = i.body;
  n.indexOf("<a") !== -1 && (n += "<!-- " + Date.now() + " -->");
  const r = i.attributes, o = Oi(n, {
    ...r,
    width: t.width + "",
    height: t.height + ""
  }), a = Ts(o), l = s.style, c = {
    "--svg": a,
    width: Tn(r.width),
    height: Tn(r.height),
    ...e ? di : Rs
  };
  for (const u in c)
    l.setProperty(u, c[u]);
  return s;
}
let te;
function Wo() {
  try {
    te = window.trustedTypes.createPolicy("iconify", {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      createHTML: (i) => i
    });
  } catch {
    te = null;
  }
}
function Qo(i) {
  return te === void 0 && Wo(), te ? te.createHTML(i) : i;
}
function Yo(i) {
  const t = document.createElement("span"), e = i.attributes;
  let s = "";
  e.width || (s = "width: inherit;"), e.height || (s += "height: inherit;"), s && (e.style = s);
  const n = Oi(i.body, e);
  return t.innerHTML = Qo(n), t.firstChild;
}
function fi(i) {
  return Array.from(i.childNodes).find((t) => {
    const e = t.tagName && t.tagName.toUpperCase();
    return e === "SPAN" || e === "SVG";
  });
}
function In(i, t) {
  const e = t.icon.data, s = t.customisations, n = Ps(e, s);
  s.preserveAspectRatio && (n.attributes.preserveAspectRatio = s.preserveAspectRatio);
  const r = t.renderedMode;
  let o;
  switch (r) {
    case "svg":
      o = Yo(n);
      break;
    default:
      o = qo(n, {
        ...de,
        ...e
      }, r === "mask");
  }
  const a = fi(i);
  a ? o.tagName === "SPAN" && a.tagName === o.tagName ? a.setAttribute("style", o.getAttribute("style")) : i.replaceChild(o, a) : i.appendChild(o);
}
function Ln(i, t, e) {
  const s = e && (e.rendered ? e : e.lastRender);
  return {
    rendered: !1,
    inline: t,
    icon: i,
    lastRender: s
  };
}
function Go(i = "iconify-icon") {
  let t, e;
  try {
    t = window.customElements, e = window.HTMLElement;
  } catch {
    return;
  }
  if (!t || !e)
    return;
  const s = t.get(i);
  if (s)
    return s;
  const n = [
    // Icon
    "icon",
    // Mode
    "mode",
    "inline",
    "observe",
    // Customisations
    "width",
    "height",
    "rotate",
    "flip"
  ], r = class extends e {
    /**
     * Constructor
     */
    constructor() {
      super();
      // Root
      ot(this, "_shadowRoot");
      // Initialised
      ot(this, "_initialised", !1);
      // Icon state
      ot(this, "_state");
      // Attributes check queued
      ot(this, "_checkQueued", !1);
      // Connected
      ot(this, "_connected", !1);
      // Observer
      ot(this, "_observer", null);
      ot(this, "_visible", !0);
      const l = this._shadowRoot = this.attachShadow({
        mode: "open"
      }), c = ei(this);
      On(l, c), this._state = Ln({
        value: ""
      }, c), this._queueCheck();
    }
    /**
     * Connected to DOM
     */
    connectedCallback() {
      this._connected = !0, this.startObserver();
    }
    /**
     * Disconnected from DOM
     */
    disconnectedCallback() {
      this._connected = !1, this.stopObserver();
    }
    /**
     * Observed attributes
     */
    static get observedAttributes() {
      return n.slice(0);
    }
    /**
     * Observed properties that are different from attributes
     *
     * Experimental! Need to test with various frameworks that support it
     */
    /*
    static get properties() {
        return {
            inline: {
                type: Boolean,
                reflect: true,
            },
            // Not listing other attributes because they are strings or combination
            // of string and another type. Cannot have multiple types
        };
    }
    */
    /**
     * Attribute has changed
     */
    attributeChangedCallback(l) {
      switch (l) {
        case "inline": {
          const c = ei(this), u = this._state;
          c !== u.inline && (u.inline = c, On(this._shadowRoot, c));
          break;
        }
        case "observer": {
          this.observer ? this.startObserver() : this.stopObserver();
          break;
        }
        default:
          this._queueCheck();
      }
    }
    /**
     * Get/set icon
     */
    get icon() {
      const l = this.getAttribute("icon");
      if (l && l.slice(0, 1) === "{")
        try {
          return JSON.parse(l);
        } catch {
        }
      return l;
    }
    set icon(l) {
      typeof l == "object" && (l = JSON.stringify(l)), this.setAttribute("icon", l);
    }
    /**
     * Get/set inline
     */
    get inline() {
      return ei(this);
    }
    set inline(l) {
      l ? this.setAttribute("inline", "true") : this.removeAttribute("inline");
    }
    /**
     * Get/set observer
     */
    get observer() {
      return this.hasAttribute("observer");
    }
    set observer(l) {
      l ? this.setAttribute("observer", "true") : this.removeAttribute("observer");
    }
    /**
     * Restart animation
     */
    restartAnimation() {
      const l = this._state;
      if (l.rendered) {
        const c = this._shadowRoot;
        if (l.renderedMode === "svg")
          try {
            c.lastChild.setCurrentTime(0);
            return;
          } catch {
          }
        In(c, l);
      }
    }
    /**
     * Get status
     */
    get status() {
      const l = this._state;
      return l.rendered ? "rendered" : l.icon.data === null ? "failed" : "loading";
    }
    /**
     * Queue attributes re-check
     */
    _queueCheck() {
      this._checkQueued || (this._checkQueued = !0, setTimeout(() => {
        this._check();
      }));
    }
    /**
     * Check for changes
     */
    _check() {
      if (!this._checkQueued)
        return;
      this._checkQueued = !1;
      const l = this._state, c = this.getAttribute("icon");
      if (c !== l.icon.value) {
        this._iconChanged(c);
        return;
      }
      if (!l.rendered || !this._visible)
        return;
      const u = this.getAttribute("mode"), d = bn(this);
      (l.attrMode !== u || Xr(l.customisations, d) || !fi(this._shadowRoot)) && this._renderIcon(l.icon, d, u);
    }
    /**
     * Icon value has changed
     */
    _iconChanged(l) {
      const c = Eo(l, (u, d, f) => {
        const p = this._state;
        if (p.rendered || this.getAttribute("icon") !== u)
          return;
        const b = {
          value: u,
          name: d,
          data: f
        };
        b.data ? this._gotIconData(b) : p.icon = b;
      });
      c.data ? this._gotIconData(c) : this._state = Ln(c, this._state.inline, this._state);
    }
    /**
     * Force render icon on state change
     */
    _forceRender() {
      if (!this._visible) {
        const l = fi(this._shadowRoot);
        l && this._shadowRoot.removeChild(l);
        return;
      }
      this._queueCheck();
    }
    /**
     * Got new icon data, icon is ready to (re)render
     */
    _gotIconData(l) {
      this._checkQueued = !1, this._renderIcon(l, bn(this), this.getAttribute("mode"));
    }
    /**
     * Re-render based on icon data
     */
    _renderIcon(l, c, u) {
      const d = So(l.data.body, u), f = this._state.inline;
      In(this._shadowRoot, this._state = {
        rendered: !0,
        icon: l,
        inline: f,
        customisations: c,
        attrMode: u,
        renderedMode: d
      });
    }
    /**
     * Start observer
     */
    startObserver() {
      if (!this._observer)
        try {
          this._observer = new IntersectionObserver((l) => {
            const c = l.some((u) => u.isIntersecting);
            c !== this._visible && (this._visible = c, this._forceRender());
          }), this._observer.observe(this);
        } catch {
          if (this._observer) {
            try {
              this._observer.disconnect();
            } catch {
            }
            this._observer = null;
          }
        }
    }
    /**
     * Stop observer
     */
    stopObserver() {
      this._observer && (this._observer.disconnect(), this._observer = null, this._visible = !0, this._connected && this._forceRender());
    }
  };
  n.forEach((a) => {
    a in r.prototype || Object.defineProperty(r.prototype, a, {
      get: function() {
        return this.getAttribute(a);
      },
      set: function(l) {
        l !== null ? this.setAttribute(a, l) : this.removeAttribute(a);
      }
    });
  });
  const o = Ls();
  for (const a in o)
    r[a] = r.prototype[a] = o[a];
  return t.define(i, r), r;
}
Go() || Ls();
const Ko = C`
  ::-webkit-scrollbar {
    width: 0.4rem;
    height: 0.4rem;
    overflow: hidden;
  }

  ::-webkit-scrollbar-thumb {
    border-radius: 0.25rem;
    background-color: var(
      --bim-scrollbar--c,
      color-mix(in lab, var(--bim-ui_main-base), white 15%)
    );
  }

  ::-webkit-scrollbar-track {
    background-color: var(--bim-scrollbar--bgc, var(--bim-ui_bg-base));
  }
`, Xo = C`
  :root {
    /* Grayscale Colors */
    --bim-ui_gray-0: hsl(210 10% 5%);
    --bim-ui_gray-1: hsl(210 10% 10%);
    --bim-ui_gray-2: hsl(210 10% 20%);
    --bim-ui_gray-3: hsl(210 10% 30%);
    --bim-ui_gray-4: hsl(210 10% 40%);
    --bim-ui_gray-6: hsl(210 10% 60%);
    --bim-ui_gray-7: hsl(210 10% 70%);
    --bim-ui_gray-8: hsl(210 10% 80%);
    --bim-ui_gray-9: hsl(210 10% 90%);
    --bim-ui_gray-10: hsl(210 10% 95%);

    /* Brand Colors */
    --bim-ui_main-base: #6528d7;
    --bim-ui_accent-base: #bcf124;

    /* Brand Colors Contrasts */
    --bim-ui_main-contrast: var(--bim-ui_gray-10);
    --bim-ui_accent-contrast: var(--bim-ui_gray-0);

    /* Sizes */
    --bim-ui_size-4xs: 0.375rem;
    --bim-ui_size-3xs: 0.5rem;
    --bim-ui_size-2xs: 0.625rem;
    --bim-ui_size-xs: 0.75rem;
    --bim-ui_size-sm: 0.875rem;
    --bim-ui_size-base: 1rem;
    --bim-ui_size-lg: 1.125rem;
    --bim-ui_size-xl: 1.25rem;
    --bim-ui_size-2xl: 1.375rem;
    --bim-ui_size-3xl: 1.5rem;
    --bim-ui_size-4xl: 1.625rem;
    --bim-ui_size-5xl: 1.75rem;
    --bim-ui_size-6xl: 1.875rem;
    --bim-ui_size-7xl: 2rem;
    --bim-ui_size-8xl: 2.125rem;
    --bim-ui_size-9xl: 2.25rem;
  }

  /* Background Colors */
  @media (prefers-color-scheme: dark) {
    :root {
      --bim-ui_bg-base: var(--bim-ui_gray-0);
      --bim-ui_bg-contrast-10: var(--bim-ui_gray-1);
      --bim-ui_bg-contrast-20: var(--bim-ui_gray-2);
      --bim-ui_bg-contrast-30: var(--bim-ui_gray-3);
      --bim-ui_bg-contrast-40: var(--bim-ui_gray-4);
      --bim-ui_bg-contrast-60: var(--bim-ui_gray-6);
      --bim-ui_bg-contrast-80: var(--bim-ui_gray-8);
      --bim-ui_bg-contrast-100: var(--bim-ui_gray-10);
    }
  }

  @media (prefers-color-scheme: light) {
    :root {
      --bim-ui_bg-base: var(--bim-ui_gray-10);
      --bim-ui_bg-contrast-10: var(--bim-ui_gray-9);
      --bim-ui_bg-contrast-20: var(--bim-ui_gray-8);
      --bim-ui_bg-contrast-30: var(--bim-ui_gray-7);
      --bim-ui_bg-contrast-40: var(--bim-ui_gray-6);
      --bim-ui_bg-contrast-60: var(--bim-ui_gray-4);
      --bim-ui_bg-contrast-80: var(--bim-ui_gray-2);
      --bim-ui_bg-contrast-100: var(--bim-ui_gray-0);
      --bim-ui_accent-base: #6528d7;
    }
  }

  html.bim-ui-dark {
    --bim-ui_bg-base: var(--bim-ui_gray-0);
    --bim-ui_bg-contrast-10: var(--bim-ui_gray-1);
    --bim-ui_bg-contrast-20: var(--bim-ui_gray-2);
    --bim-ui_bg-contrast-30: var(--bim-ui_gray-3);
    --bim-ui_bg-contrast-40: var(--bim-ui_gray-4);
    --bim-ui_bg-contrast-60: var(--bim-ui_gray-6);
    --bim-ui_bg-contrast-80: var(--bim-ui_gray-8);
    --bim-ui_bg-contrast-100: var(--bim-ui_gray-10);
  }

  html.bim-ui-light {
    --bim-ui_bg-base: var(--bim-ui_gray-10);
    --bim-ui_bg-contrast-10: var(--bim-ui_gray-9);
    --bim-ui_bg-contrast-20: var(--bim-ui_gray-8);
    --bim-ui_bg-contrast-30: var(--bim-ui_gray-7);
    --bim-ui_bg-contrast-40: var(--bim-ui_gray-6);
    --bim-ui_bg-contrast-60: var(--bim-ui_gray-4);
    --bim-ui_bg-contrast-80: var(--bim-ui_gray-2);
    --bim-ui_bg-contrast-100: var(--bim-ui_gray-0);
    --bim-ui_accent-base: #6528d7;
  }

  [data-context-dialog]::backdrop {
    background-color: transparent;
  }
`, vt = {
  scrollbar: Ko,
  globalStyles: Xo
}, y = class y {
  static set config(t) {
    this._config = { ...y._config, ...t };
  }
  static get config() {
    return y._config;
  }
  static addGlobalStyles() {
    let t = document.querySelector("style[id='bim-ui']");
    if (t)
      return;
    t = document.createElement("style"), t.id = "bim-ui", t.textContent = vt.globalStyles.cssText;
    const e = document.head.firstChild;
    e ? document.head.insertBefore(t, e) : document.head.append(t);
  }
  static defineCustomElement(t, e) {
    customElements.get(t) || customElements.define(t, e);
  }
  /**
   * @deprecated Use `Manager.init()` instead.
   */
  static registerComponents() {
    y.init();
  }
  /**
   * Initializes the BIM UI library by defining custom elements.
   * It ensures that all necessary styles and custom elements are registered for use in BIM UI components.
   *
   * @example
   * ```typescript
   * import { Manager } from "@thatopen/ui";
   * Manager.init();
   * ```
   */
  static init() {
    y.addGlobalStyles(), y.defineCustomElement("bim-button", il), y.defineCustomElement("bim-checkbox", dt), y.defineCustomElement("bim-color-input", J), y.defineCustomElement("bim-context-menu", pi), y.defineCustomElement("bim-dropdown", V), y.defineCustomElement("bim-grid", ae), y.defineCustomElement("bim-icon", bi), y.defineCustomElement("bim-input", Ot), y.defineCustomElement("bim-label", ft), y.defineCustomElement("bim-number-input", L), y.defineCustomElement("bim-option", T), y.defineCustomElement("bim-panel", Z), y.defineCustomElement("bim-panel-section", pt), y.defineCustomElement("bim-selector", mt), y.defineCustomElement("bim-table", z), y.defineCustomElement("bim-tabs", et), y.defineCustomElement("bim-tab", R), y.defineCustomElement("bim-table-cell", Le), y.defineCustomElement("bim-table-children", Re), y.defineCustomElement("bim-table-group", ze), y.defineCustomElement("bim-table-row", tt), y.defineCustomElement("bim-text-input", B), y.defineCustomElement("bim-toolbar", Ft), y.defineCustomElement("bim-toolbar-group", Dt), y.defineCustomElement(
      "bim-toolbar-section",
      bt
    ), y.defineCustomElement("bim-viewport", Me);
  }
  static newRandomId() {
    const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let e = "";
    for (let s = 0; s < 10; s++) {
      const n = Math.floor(Math.random() * t.length);
      e += t.charAt(n);
    }
    return e;
  }
};
y._config = {
  sectionLabelOnVerticalToolbar: !1
  // draggableToolbars: true,
  // draggablePanels: true,
};
let Te = y;
class zs extends w {
  constructor() {
    super(...arguments), this._lazyLoadObserver = null, this._visibleElements = [], this.ELEMENTS_BEFORE_OBSERVER = 20, this.useObserver = !1, this.elements = /* @__PURE__ */ new Set(), this.observe = (t) => {
      if (!this.useObserver)
        return;
      for (const s of t)
        this.elements.add(s);
      const e = t.slice(this.ELEMENTS_BEFORE_OBSERVER);
      for (const s of e)
        s.remove();
      this.observeLastElement();
    };
  }
  set visibleElements(t) {
    this._visibleElements = this.useObserver ? t : [], this.requestUpdate();
  }
  get visibleElements() {
    return this._visibleElements;
  }
  getLazyObserver() {
    if (!this.useObserver)
      return null;
    if (this._lazyLoadObserver)
      return this._lazyLoadObserver;
    const t = new IntersectionObserver(
      (e) => {
        const s = e[0];
        if (!s.isIntersecting)
          return;
        const n = s.target;
        t.unobserve(n);
        const r = this.ELEMENTS_BEFORE_OBSERVER + this.visibleElements.length, o = [...this.elements][r];
        o && (this.visibleElements = [...this.visibleElements, o], t.observe(o));
      },
      { threshold: 0.5 }
    );
    return t;
  }
  observeLastElement() {
    const t = this.getLazyObserver();
    if (!t)
      return;
    const e = this.ELEMENTS_BEFORE_OBSERVER + this.visibleElements.length - 1, s = [...this.elements][e];
    s && t.observe(s);
  }
  resetVisibleElements() {
    const t = this.getLazyObserver();
    if (t) {
      for (const e of this.elements)
        t.unobserve(e);
      this.visibleElements = [], this.observeLastElement();
    }
  }
  /**
   * Creates a new UI component instance based on the provided template and initial state.
   *
   * @template T - The type of the UI component element.
   * @template S - The type of the component state.
   *
   * @param template - The component template function (stateless or stateful).
   * @param initialState - The initial state of the component (optional for stateless components).
   * @returns The created UI component element or an array containing the element and a function to update its state.
   */
  static create(t, e) {
    const s = document.createDocumentFragment();
    if (t.length === 0)
      return Bt(t(), s), s.firstElementChild;
    if (!e)
      throw new Error(
        "UIComponent: Initial state is required for statefull components."
      );
    let n = e;
    const r = t, o = (c) => (n = { ...n, ...c }, Bt(r(n), s), n);
    o(e);
    const a = () => n;
    return [s.firstElementChild, o, a];
  }
}
var Jo = Object.defineProperty, Zo = Object.getOwnPropertyDescriptor, Ms = (i, t, e, s) => {
  for (var n = Zo(t, e), r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && Jo(t, e, n), n;
}, P;
const ki = (P = class extends w {
  constructor() {
    super(...arguments), this._previousContainer = null, this._visible = !1;
  }
  get placement() {
    return this._placement;
  }
  set placement(t) {
    this._placement = t, this.updatePosition();
  }
  static removeMenus() {
    for (const t of P.menus)
      t instanceof P && (t.visible = !1);
    P.dialog.close(), P.dialog.remove();
  }
  get visible() {
    return this._visible;
  }
  set visible(t) {
    var e;
    this._visible = t, t ? (P.dialog.parentElement || document.body.append(P.dialog), this._previousContainer = this.parentElement, P.dialog.style.top = `${window.scrollY || document.documentElement.scrollTop}px`, P.dialog.append(this), P.dialog.showModal(), this.updatePosition(), this.dispatchEvent(new Event("visible"))) : ((e = this._previousContainer) == null || e.append(this), this._previousContainer = null, this.dispatchEvent(new Event("hidden")));
  }
  /**
   * Asynchronously updates the position of the context menu relative to a target element.
   * If no target element is provided, it attempts to use the parent node as the target.
   * The position is calculated using the `computePosition` function from `@floating-ui/dom`,
   * which considers various adjustments like offset, inline positioning, flipping, and shifting
   * to ensure the context menu is properly placed relative to the target element.
   *
   * @param [target] - The target element relative to which the context menu should be positioned.
   *                                 If not provided, the parent node is used as the target.
   * @returns A promise that resolves once the position has been updated. This method
   *                          does not explicitly return a value but updates the context menu's style
   *                          properties to position it on the screen.
   */
  async updatePosition() {
    if (!(this.visible && this._previousContainer))
      return;
    const t = this.placement ?? "right", e = await ns(this._previousContainer, this, {
      placement: t,
      middleware: [Un(10), is(), es(), ts({ padding: 5 })]
    }), { x: s, y: n } = e;
    this.style.left = `${s}px`, this.style.top = `${n}px`;
  }
  connectedCallback() {
    super.connectedCallback(), P.menus.push(this);
  }
  render() {
    return m` <slot></slot> `;
  }
}, P.styles = [
  vt.scrollbar,
  C`
      :host {
        pointer-events: auto;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 999;
        overflow: auto;
        max-height: 20rem;
        min-width: 3rem;
        flex-direction: column;
        box-shadow: 1px 2px 8px 2px rgba(0, 0, 0, 0.15);
        padding: 0.5rem;
        border-radius: var(--bim-ui_size-4xs);
        display: flex;
        background-color: var(
          --bim-context-menu--bgc,
          var(--bim-ui_bg-contrast-20)
        );
      }

      :host(:not([visible])) {
        display: none;
      }
    `
], P.dialog = zs.create(() => m` <dialog
      @click=${(e) => {
  e.target === P.dialog && P.removeMenus();
}}
      @cancel=${() => P.removeMenus()}
      data-context-dialog
      style="
      width: 0;
      height: 0;
      position: relative;
      padding: 0;
      border: none;
      outline: none;
      margin: none;
      overflow: visible;
      background-color: transparent;
    "
    ></dialog>`), P.menus = [], P);
Ms([
  h({ type: String, reflect: !0 })
], ki.prototype, "placement");
Ms([
  h({ type: Boolean, reflect: !0 })
], ki.prototype, "visible");
let pi = ki;
var tl = Object.defineProperty, el = Object.getOwnPropertyDescriptor, U = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? el(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && tl(t, e, n), n;
}, Ct;
const N = (Ct = class extends w {
  constructor() {
    super(), this.labelHidden = !1, this.active = !1, this.disabled = !1, this.vertical = !1, this.tooltipVisible = !1, this._stateBeforeLoading = {
      disabled: !1,
      icon: ""
    }, this._loading = !1, this._parent = Nt(), this._tooltip = Nt(), this._mouseLeave = !1, this.onClick = (t) => {
      t.stopPropagation(), this.disabled || this.dispatchEvent(new Event("click"));
    }, this.showContextMenu = () => {
      const t = this._contextMenu;
      if (t) {
        const e = this.getAttribute("data-context-group");
        e && t.setAttribute("data-context-group", e), this.closeNestedContexts();
        const s = Te.newRandomId();
        for (const n of t.children)
          n instanceof Ct && n.setAttribute("data-context-group", s);
        t.visible = !0;
      }
    }, this.mouseLeave = !0;
  }
  set loading(t) {
    if (this._loading = t, t)
      this._stateBeforeLoading = {
        disabled: this.disabled,
        icon: this.icon
      }, this.disabled = t, this.icon = "eos-icons:loading";
    else {
      const { disabled: e, icon: s } = this._stateBeforeLoading;
      this.disabled = e, this.icon = s;
    }
  }
  get loading() {
    return this._loading;
  }
  set mouseLeave(t) {
    this._mouseLeave = t, t && (this.tooltipVisible = !1, clearTimeout(this.timeoutID));
  }
  get mouseLeave() {
    return this._mouseLeave;
  }
  computeTooltipPosition() {
    const { value: t } = this._parent, { value: e } = this._tooltip;
    t && e && ns(t, e, {
      placement: "bottom",
      middleware: [Un(10), is(), es(), ts({ padding: 5 })]
    }).then((s) => {
      const { x: n, y: r } = s;
      Object.assign(e.style, {
        left: `${n}px`,
        top: `${r}px`
      });
    });
  }
  onMouseEnter() {
    if (!(this.tooltipTitle || this.tooltipText))
      return;
    this.mouseLeave = !1;
    const t = this.tooltipTime ?? 700;
    this.timeoutID = setTimeout(() => {
      this.mouseLeave || (this.computeTooltipPosition(), this.tooltipVisible = !0);
    }, t);
  }
  closeNestedContexts() {
    const t = this.getAttribute("data-context-group");
    if (t)
      for (const e of pi.dialog.children) {
        const s = e.getAttribute("data-context-group");
        if (e instanceof pi && s === t) {
          e.visible = !1, e.removeAttribute("data-context-group");
          for (const n of e.children)
            n instanceof Ct && (n.closeNestedContexts(), n.removeAttribute("data-context-group"));
        }
      }
  }
  click() {
    this.disabled || super.click();
  }
  get _contextMenu() {
    return this.querySelector("bim-context-menu");
  }
  connectedCallback() {
    super.connectedCallback(), this.addEventListener("click", this.showContextMenu);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.removeEventListener("click", this.showContextMenu);
  }
  render() {
    const t = m`
      <div ${Ht(this._tooltip)} class="tooltip">
        ${this.tooltipTitle ? m`<p style="text-wrap: nowrap;">
              <strong>${this.tooltipTitle}</strong>
            </p>` : null}
        ${this.tooltipText ? m`<p style="width: 9rem;">${this.tooltipText}</p>` : null}
      </div>
    `, e = m`<svg
      xmlns="http://www.w3.org/2000/svg"
      height="1.125rem"
      viewBox="0 0 24 24"
      width="1.125rem"
      style="fill: var(--bim-label--c)"
    >
      <path d="M0 0h24v24H0V0z" fill="none" />
      <path d="M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" />
    </svg>`;
    return m`
      <div ${Ht(this._parent)} class="parent" @click=${this.onClick}>
        ${this.label || this.icon ? m`
              <div
                class="button"
                @mouseenter=${this.onMouseEnter}
                @mouseleave=${() => this.mouseLeave = !0}
              >
                <bim-label
                  .icon=${this.icon}
                  .vertical=${this.vertical}
                  .labelHidden=${this.labelHidden}
                  >${this.label}${this.label && this._contextMenu ? e : null}</bim-label
                >
              </div>
            ` : null}
        ${this.tooltipTitle || this.tooltipText ? t : null}
      </div>
      <slot></slot>
    `;
  }
}, Ct.styles = C`
    :host {
      --bim-label--c: var(--bim-ui_bg-contrast-100, white);
      display: block;
      flex: 1;
      pointer-events: none;
      background-color: var(--bim-button--bgc, var(--bim-ui_bg-contrast-20));
      border-radius: var(--bim-ui_size-4xs);
      transition: all 0.15s;
    }

    :host(:not([disabled]):hover) {
      cursor: pointer;
    }

    bim-label {
      pointer-events: none;
    }

    .parent {
      --bim-icon--c: var(--bim-label--c);
      position: relative;
      display: flex;
      height: 100%;
      user-select: none;
      row-gap: 0.125rem;
      min-height: var(--bim-ui_size-5xl);
      min-width: var(--bim-ui_size-5xl);
    }

    .button,
    .children {
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
    }

    .children {
      padding: 0 0.375rem;
      position: absolute;
      height: 100%;
      right: 0;
    }

    :host(:not([label-hidden])[icon][vertical]) .parent {
      min-height: 2.5rem;
    }

    .button {
      flex-grow: 1;
    }

    :host(:not([label-hidden])[label]) .button {
      justify-content: var(--bim-button--jc, center);
    }

    :host(:hover),
    :host([active]) {
      --bim-label--c: var(--bim-ui_main-contrast);
      background-color: var(--bim-ui_main-base);
    }

    :host(:not([label]):not([icon])) .children {
      flex: 1;
    }

    :host([vertical]) .parent {
      justify-content: center;
    }

    :host(:not([label-hidden])[label]) .button {
      padding: 0 0.5rem;
    }

    :host([disabled]) {
      --bim-label--c: var(--bim-ui_bg-contrast-80) !important;
      background-color: gray !important;
    }

    ::slotted(bim-button) {
      --bim-icon--fz: var(--bim-ui_size-base);
      --bim-button--bdrs: var(--bim-ui_size-4xs);
      --bim-button--olw: 0;
      --bim-button--olc: transparent;
    }

    .tooltip {
      position: absolute;
      padding: 0.75rem;
      z-index: 99;
      display: flex;
      flex-flow: column;
      row-gap: 0.375rem;
      box-shadow: 0 0 10px 3px rgba(0 0 0 / 20%);
      outline: 1px solid var(--bim-ui_bg-contrast-40);
      font-size: var(--bim-ui_size-xs);
      border-radius: var(--bim-ui_size-4xs);
      background-color: var(--bim-ui_bg-contrast-20);
      color: var(--bim-ui_bg-contrast-100);
    }

    .tooltip p {
      margin: 0;
      padding: 0;
    }

    :host(:not([tooltip-visible])) .tooltip {
      display: none;
    }
  `, Ct);
U([
  h({ type: String, reflect: !0 })
], N.prototype, "label", 2);
U([
  h({ type: Boolean, attribute: "label-hidden", reflect: !0 })
], N.prototype, "labelHidden", 2);
U([
  h({ type: Boolean, reflect: !0 })
], N.prototype, "active", 2);
U([
  h({ type: Boolean, reflect: !0, attribute: "disabled" })
], N.prototype, "disabled", 2);
U([
  h({ type: String, reflect: !0 })
], N.prototype, "icon", 2);
U([
  h({ type: Boolean, reflect: !0 })
], N.prototype, "vertical", 2);
U([
  h({ type: Number, attribute: "tooltip-time", reflect: !0 })
], N.prototype, "tooltipTime", 2);
U([
  h({ type: Boolean, attribute: "tooltip-visible", reflect: !0 })
], N.prototype, "tooltipVisible", 2);
U([
  h({ type: String, attribute: "tooltip-title", reflect: !0 })
], N.prototype, "tooltipTitle", 2);
U([
  h({ type: String, attribute: "tooltip-text", reflect: !0 })
], N.prototype, "tooltipText", 2);
U([
  h({ type: Boolean, reflect: !0 })
], N.prototype, "loading", 1);
let il = N;
var nl = Object.defineProperty, pe = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && nl(t, e, n), n;
};
const Ti = class Ti extends w {
  constructor() {
    super(...arguments), this.checked = !1, this.inverted = !1, this.onValueChange = new Event("change");
  }
  /**
   * A getter that returns the current checked state of the checkbox. This is useful for retrieving the checkbox's value in form submissions or JavaScript interactions as it provides a consistent `value` property as many other components.
   * @type {boolean}
   * @default false
   * @example <script>console.log(document.querySelector('bim-checkbox').value);<\/script>
   * @example
   * const checkbox = document.createElement('bim-checkbox');
   * document.body.appendChild(checkbox);
   * console.log(checkbox.value); // false initially
   */
  get value() {
    return this.checked;
  }
  onChange(t) {
    t.stopPropagation(), this.checked = t.target.checked, this.dispatchEvent(this.onValueChange);
  }
  render() {
    return m`
      <div class="parent">
        ${this.label ? m`<bim-label .icon="${this.icon}">${this.label}</bim-label> ` : null}
        <input
          type="checkbox"
          aria-label=${this.label || this.name || "Checkbox Input"}
          @change="${this.onChange}"
          .checked="${this.checked}"
        />
      </div>
    `;
  }
};
Ti.styles = C`
    :host {
      display: block;
    }

    .parent {
      display: flex;
      justify-content: space-between;
      height: 1.75rem;
      column-gap: 0.25rem;
      width: 100%;
      align-items: center;
      transition: all 0.15s;
    }

    :host([inverted]) .parent {
      flex-direction: row-reverse;
      justify-content: start;
    }

    input {
      height: 1rem;
      width: 1rem;
      cursor: pointer;
      border: none;
      outline: none;
      accent-color: var(--bim-checkbox--c, var(--bim-ui_main-base));
      transition: all 0.15s;
    }

    input:focus {
      outline: var(--bim-checkbox--olw, 2px) solid
        var(--bim-checkbox--olc, var(--bim-ui_accent-base));
    }
  `;
let dt = Ti;
pe([
  h({ type: String, reflect: !0 })
], dt.prototype, "icon");
pe([
  h({ type: String, reflect: !0 })
], dt.prototype, "name");
pe([
  h({ type: String, reflect: !0 })
], dt.prototype, "label");
pe([
  h({ type: Boolean, reflect: !0 })
], dt.prototype, "checked");
pe([
  h({ type: Boolean, reflect: !0 })
], dt.prototype, "inverted");
var sl = Object.defineProperty, Ut = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && sl(t, e, n), n;
};
const Ii = class Ii extends w {
  constructor() {
    super(...arguments), this.vertical = !1, this.color = "#bcf124", this._colorInput = Nt(), this._textInput = Nt(), this.onValueChange = new Event("input"), this.onOpacityInput = (t) => {
      const e = t.target;
      this.opacity = e.value, this.dispatchEvent(this.onValueChange);
    };
  }
  /**
   * Represents both the color and opacity values combined into a single object. This is an instance property, not an HTMLElement attribute.
   * @type {Object}
   * @example
   * const colorInput = document.createElement('bim-color-input');
   * colorInput.value = { color: '#ff0000', opacity: 0.5 };
   */
  set value(t) {
    const { color: e, opacity: s } = t;
    this.color = e, s && (this.opacity = s);
  }
  get value() {
    const t = {
      color: this.color
    };
    return this.opacity && (t.opacity = this.opacity), t;
  }
  onColorInput(t) {
    t.stopPropagation();
    const { value: e } = this._colorInput;
    e && (this.color = e.value, this.dispatchEvent(this.onValueChange));
  }
  onTextInput(t) {
    t.stopPropagation();
    const { value: e } = this._textInput;
    if (!e)
      return;
    const { value: s } = e;
    let n = s.replace(/[^a-fA-F0-9]/g, "");
    n.startsWith("#") || (n = `#${n}`), e.value = n.slice(0, 7), e.value.length === 7 && (this.color = e.value, this.dispatchEvent(this.onValueChange));
  }
  /**
   * Focuses on the color input by programmatically triggering a click event on the underlying color input element.
   * If the color input element is not available, the function does nothing.
   */
  focus() {
    const { value: t } = this._colorInput;
    t && t.click();
  }
  render() {
    return m`
      <div class="parent">
        <bim-input
          .label=${this.label}
          .icon=${this.icon}
          .vertical="${this.vertical}"
        >
          <div class="color-container">
            <div
              style="display: flex; align-items: center; gap: .375rem; height: 100%; flex: 1; padding: 0 0.5rem;"
            >
              <input
                ${Ht(this._colorInput)}
                @input="${this.onColorInput}"
                type="color"
                aria-label=${this.label || this.name || "Color Input"}
                value="${this.color}"
              />
              <div
                @click=${this.focus}
                class="sample"
                style="background-color: ${this.color}"
              ></div>
              <input
                ${Ht(this._textInput)}
                @input="${this.onTextInput}"
                value="${this.color}"
                type="text"
                aria-label=${this.label || this.name || "Text Color Input"}
              />
            </div>
            ${this.opacity !== void 0 ? m`<bim-number-input
                  @change=${this.onOpacityInput}
                  slider
                  suffix="%"
                  min="0"
                  value=${this.opacity}
                  max="100"
                ></bim-number-input>` : null}
          </div>
        </bim-input>
      </div>
    `;
  }
};
Ii.styles = C`
    :host {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
      flex: 1;
      display: block;
    }

    :host(:focus) {
      --bim-input--olw: var(--bim-number-input--olw, 2px);
      --bim-input--olc: var(--bim-ui_accent-base);
    }

    .parent {
      display: flex;
      gap: 0.375rem;
    }

    .color-container {
      position: relative;
      outline: none;
      display: flex;
      height: 100%;
      gap: 0.5rem;
      justify-content: flex-start;
      align-items: center;
      flex: 1;
      border-radius: var(--bim-color-input--bdrs, var(--bim-ui_size-4xs));
    }

    .color-container input[type="color"] {
      position: absolute;
      bottom: -0.25rem;
      visibility: hidden;
      width: 0;
      height: 0;
    }

    .color-container .sample {
      width: 1rem;
      height: 1rem;
      border-radius: 0.125rem;
      background-color: #fff;
    }

    .color-container input[type="text"] {
      height: 100%;
      flex: 1;
      width: 3.25rem;
      text-transform: uppercase;
      font-size: 0.75rem;
      background-color: transparent;
      padding: 0%;
      outline: none;
      border: none;
      color: var(--bim-color-input--c, var(--bim-ui_bg-contrast-100));
    }

    bim-number-input {
      flex-grow: 0;
    }
  `;
let J = Ii;
Ut([
  h({ type: String, reflect: !0 })
], J.prototype, "name");
Ut([
  h({ type: String, reflect: !0 })
], J.prototype, "label");
Ut([
  h({ type: String, reflect: !0 })
], J.prototype, "icon");
Ut([
  h({ type: Boolean, reflect: !0 })
], J.prototype, "vertical");
Ut([
  h({ type: Number, reflect: !0 })
], J.prototype, "opacity");
Ut([
  h({ type: String, reflect: !0 })
], J.prototype, "color");
const Ie = (i, t = {}, e = !0) => {
  let s = {};
  for (const n of i.children) {
    const r = n, o = r.getAttribute("name") || r.getAttribute("label"), a = t[o];
    if (o) {
      if ("value" in r && typeof r.value < "u" && r.value !== null) {
        const l = r.value;
        if (typeof l == "object" && !Array.isArray(l) && Object.keys(l).length === 0)
          continue;
        s[o] = a ? a(r.value) : r.value;
      } else if (e) {
        const l = Ie(r, t);
        if (Object.keys(l).length === 0)
          continue;
        s[o] = a ? a(l) : l;
      }
    } else
      e && (s = { ...s, ...Ie(r, t) });
  }
  return s;
}, Ue = (i) => i === "true" || i === "false" ? i === "true" : i && !isNaN(Number(i)) && i.trim() !== "" ? Number(i) : i, rl = [">=", "<=", "=", ">", "<", "?", "/", "#"];
function Rn(i) {
  const t = rl.find(
    (a) => i.split(a).length === 2
  ), e = i.split(t).map((a) => a.trim()), [s, n] = e, r = n.startsWith("'") && n.endsWith("'") ? n.replace(/'/g, "") : Ue(n);
  return { key: s, condition: t, value: r };
}
const mi = (i) => {
  try {
    const t = [], e = i.split(/&(?![^()]*\))/).map((s) => s.trim());
    for (const s of e) {
      const n = !s.startsWith("(") && !s.endsWith(")"), r = s.startsWith("(") && s.endsWith(")");
      if (n) {
        const o = Rn(s);
        t.push(o);
      }
      if (r) {
        const c = {
          operator: "&",
          queries: s.replace(/^(\()|(\))$/g, "").split("&").map((u) => u.trim()).map((u, d) => {
            const f = Rn(u);
            return d > 0 && (f.operator = "&"), f;
          })
        };
        t.push(c);
      }
    }
    return t;
  } catch {
    return null;
  }
}, zn = (i, t, e) => {
  let s = !1;
  switch (t) {
    case "=":
      s = i === e;
      break;
    case "?":
      s = String(i).includes(String(e));
      break;
    case "<":
      (typeof i == "number" || typeof e == "number") && (s = i < e);
      break;
    case "<=":
      (typeof i == "number" || typeof e == "number") && (s = i <= e);
      break;
    case ">":
      (typeof i == "number" || typeof e == "number") && (s = i > e);
      break;
    case ">=":
      (typeof i == "number" || typeof e == "number") && (s = i >= e);
      break;
    case "/":
      s = String(i).startsWith(String(e));
      break;
  }
  return s;
};
var ol = Object.defineProperty, ll = Object.getOwnPropertyDescriptor, yt = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? ll(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && ol(t, e, n), n;
};
const Li = class Li extends w {
  constructor() {
    super(...arguments), this.checked = !1, this.checkbox = !1, this.noMark = !1, this.vertical = !1;
  }
  get value() {
    return this._value !== void 0 ? this._value : this.label ? Ue(this.label) : this.label;
  }
  set value(t) {
    this._value = t;
  }
  render() {
    return m`
      <div class="parent" .title=${this.label ?? ""}>
        ${this.img || this.icon || this.label ? m` <div style="display: flex; column-gap: 0.375rem">
              ${this.checkbox && !this.noMark ? m`<bim-checkbox
                    style="pointer-events: none"
                    .checked=${this.checked}
                  ></bim-checkbox>` : null}
              <bim-label
                .vertical=${this.vertical}
                .icon=${this.icon}
                .img=${this.img}
                >${this.label}</bim-label
              >
            </div>` : null}
        ${!this.checkbox && !this.noMark && this.checked ? m`<svg
              xmlns="http://www.w3.org/2000/svg"
              height="1.125rem"
              viewBox="0 0 24 24"
              width="1.125rem"
              fill="#FFFFFF"
            >
              <path d="M0 0h24v24H0z" fill="none" />
              <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" />
            </svg>` : null}
        <slot></slot>
      </div>
    `;
  }
};
Li.styles = C`
    :host {
      --bim-label--c: var(--bim-ui_bg-contrast-100);
      display: block;
      box-sizing: border-box;
      flex: 1;
      padding: 0rem 0.5rem;
      border-radius: var(--bim-ui_size-4xs);
      transition: all 0.15s;
    }

    :host(:hover) {
      cursor: pointer;
      background-color: color-mix(
        in lab,
        var(--bim-selector--bgc, var(--bim-ui_bg-contrast-20)),
        var(--bim-ui_main-base) 10%
      );
    }

    :host([checked]) {
      --bim-label--c: color-mix(in lab, var(--bim-ui_main-base), white 30%);
    }

    :host([checked]) svg {
      fill: color-mix(in lab, var(--bim-ui_main-base), white 30%);
    }

    .parent {
      box-sizing: border-box;
      display: flex;
      justify-content: var(--bim-option--jc, space-between);
      column-gap: 0.5rem;
      align-items: center;
      min-height: 1.75rem;
      height: 100%;
    }

    input {
      height: 1rem;
      width: 1rem;
      cursor: pointer;
      border: none;
      outline: none;
      accent-color: var(--bim-checkbox--c, var(--bim-ui_main-base));
    }

    input:focus {
      outline: var(--bim-checkbox--olw, 2px) solid
        var(--bim-checkbox--olc, var(--bim-ui_accent-base));
    }

    bim-label {
      pointer-events: none;
    }
  `;
let T = Li;
yt([
  h({ type: String, reflect: !0 })
], T.prototype, "img", 2);
yt([
  h({ type: String, reflect: !0 })
], T.prototype, "label", 2);
yt([
  h({ type: String, reflect: !0 })
], T.prototype, "icon", 2);
yt([
  h({ type: Boolean, reflect: !0 })
], T.prototype, "checked", 2);
yt([
  h({ type: Boolean, reflect: !0 })
], T.prototype, "checkbox", 2);
yt([
  h({ type: Boolean, attribute: "no-mark", reflect: !0 })
], T.prototype, "noMark", 2);
yt([
  h({
    converter: {
      fromAttribute(i) {
        return i && Ue(i);
      }
    }
  })
], T.prototype, "value", 1);
yt([
  h({ type: Boolean, reflect: !0 })
], T.prototype, "vertical", 2);
var al = Object.defineProperty, cl = Object.getOwnPropertyDescriptor, _t = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? cl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && al(t, e, n), n;
};
const Ri = class Ri extends zs {
  constructor() {
    super(), this.multiple = !1, this.required = !1, this.vertical = !1, this._visible = !1, this._value = /* @__PURE__ */ new Set(), this.onValueChange = new Event("change"), this._contextMenu = Nt(), this.onOptionClick = (t) => {
      const e = t.target, s = this._value.has(e);
      if (!this.multiple && !this.required && !s)
        this._value = /* @__PURE__ */ new Set([e]);
      else if (!this.multiple && !this.required && s)
        this._value = /* @__PURE__ */ new Set([]);
      else if (!this.multiple && this.required && !s)
        this._value = /* @__PURE__ */ new Set([e]);
      else if (this.multiple && !this.required && !s)
        this._value = /* @__PURE__ */ new Set([...this._value, e]);
      else if (this.multiple && !this.required && s) {
        const n = [...this._value].filter((r) => r !== e);
        this._value = new Set(n);
      } else if (this.multiple && this.required && !s)
        this._value = /* @__PURE__ */ new Set([...this._value, e]);
      else if (this.multiple && this.required && s) {
        const n = [...this._value].filter((o) => o !== e), r = new Set(n);
        r.size !== 0 && (this._value = r);
      }
      this.updateOptionsState(), this.dispatchEvent(this.onValueChange);
    }, this.useObserver = !0;
  }
  set visible(t) {
    if (t) {
      const { value: e } = this._contextMenu;
      if (!e)
        return;
      for (const s of this.elements)
        e.append(s);
      this._visible = !0;
    } else {
      for (const e of this.elements)
        this.append(e);
      this._visible = !1, this.resetVisibleElements();
    }
  }
  get visible() {
    return this._visible;
  }
  /**
   * The selected values in the dropdown.
   * @type {any[]}
   * @example
   * const dropdown = document.createElement('bim-dropdown');
   * dropdown.value = ['option1', 'option2'];
   */
  set value(t) {
    if (this.required && Object.keys(t).length === 0)
      return;
    const e = /* @__PURE__ */ new Set();
    for (const s of t) {
      const n = this.findOption(s);
      if (n && (e.add(n), !this.multiple && Object.keys(t).length === 1))
        break;
    }
    this._value = e, this.updateOptionsState(), this.dispatchEvent(this.onValueChange);
  }
  get value() {
    return [...this._value].filter(
      (e) => e instanceof T && e.checked
    ).map((e) => e.value);
  }
  get _options() {
    const t = /* @__PURE__ */ new Set([...this.elements]);
    for (const e of this.children)
      e instanceof T && t.add(e);
    return [...t];
  }
  onSlotChange(t) {
    const e = t.target.assignedElements();
    this.observe(e);
    const s = /* @__PURE__ */ new Set();
    for (const n of this.elements) {
      if (!(n instanceof T)) {
        n.remove();
        continue;
      }
      n.checked && s.add(n), n.removeEventListener("click", this.onOptionClick), n.addEventListener("click", this.onOptionClick);
    }
    this._value = s;
  }
  updateOptionsState() {
    for (const t of this._options)
      t instanceof T && (t.checked = this._value.has(t));
  }
  findOption(t) {
    return this._options.find((s) => s instanceof T ? s.label === t || s.value === t : !1);
  }
  render() {
    let t, e, s;
    if (this._value.size === 0)
      t = "Select an option...";
    else if (this._value.size === 1) {
      const n = [...this._value][0];
      t = (n == null ? void 0 : n.label) || (n == null ? void 0 : n.value), e = n == null ? void 0 : n.img, s = n == null ? void 0 : n.icon;
    } else
      t = `Multiple (${this._value.size})`;
    return m`
      <bim-input
        title=${this.label ?? ""}
        .label=${this.label}
        .icon=${this.icon}
        .vertical=${this.vertical}
      >
        <div class="input" @click=${() => this.visible = !this.visible}>
          <bim-label
            .img=${e}
            .icon=${s}
            style="overflow: hidden;"
            >${t}</bim-label
          >
          <svg
            style="flex-shrink: 0; fill: var(--bim-dropdown--c, var(--bim-ui_bg-contrast-100))"
            xmlns="http://www.w3.org/2000/svg"
            height="1.125rem"
            viewBox="0 0 24 24"
            width="1.125rem"
            fill="#9ca3af"
          >
            <path d="M0 0h24v24H0V0z" fill="none" />
            <path d="M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" />
          </svg>
          <bim-context-menu
            ${Ht(this._contextMenu)}
            .visible=${this.visible}
            @hidden=${() => {
      this.visible && (this.visible = !1);
    }}
          >
            <slot @slotchange=${this.onSlotChange}></slot>
          </bim-context-menu>
        </div>
      </bim-input>
    `;
  }
};
Ri.styles = [
  vt.scrollbar,
  C`
      :host {
        --bim-input--bgc: var(
          --bim-dropdown--bgc,
          var(--bim-ui_bg-contrast-20)
        );
        --bim-input--olw: 2px;
        --bim-input--olc: transparent;
        --bim-input--bdrs: var(--bim-ui_size-4xs);
        flex: 1;
        display: block;
      }

      :host([visible]) {
        --bim-input--olc: var(--bim-ui_accent-base);
      }

      .input {
        --bim-label--fz: var(--bim-drodown--fz, var(--bim-ui_size-xs));
        --bim-label--c: var(--bim-dropdown--c, var(--bim-ui_bg-contrast-100));
        height: 100%;
        display: flex;
        flex: 1;
        overflow: hidden;
        column-gap: 0.25rem;
        outline: none;
        cursor: pointer;
        align-items: center;
        justify-content: space-between;
        padding: 0 0.5rem;
      }

      bim-label {
        pointer-events: none;
      }
    `
];
let V = Ri;
_t([
  h({ type: String, reflect: !0 })
], V.prototype, "name", 2);
_t([
  h({ type: String, reflect: !0 })
], V.prototype, "icon", 2);
_t([
  h({ type: String, reflect: !0 })
], V.prototype, "label", 2);
_t([
  h({ type: Boolean, reflect: !0 })
], V.prototype, "multiple", 2);
_t([
  h({ type: Boolean, reflect: !0 })
], V.prototype, "required", 2);
_t([
  h({ type: Boolean, reflect: !0 })
], V.prototype, "vertical", 2);
_t([
  h({ type: Boolean, reflect: !0 })
], V.prototype, "visible", 1);
_t([
  Vt()
], V.prototype, "_value", 2);
var ul = Object.defineProperty, js = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && ul(t, e, n), n;
};
const zi = class zi extends w {
  constructor() {
    super(...arguments), this.floating = !1, this.layouts = {};
  }
  // private isVerticalArea(area: string) {
  //   const { rows } = this;
  //   const row = rows.find((row) => row.includes(area));
  //   if (!row)
  //     throw new Error(
  //       `${area} wasn't defined in the grid-template of this bim-grid`,
  //     );
  //   const index = rows.indexOf(row);
  //   const abovePanel = index > 0 && rows[index - 1].includes(area);
  //   const belowPanel =
  //     index < rows.length - 1 && rows[index + 1].includes(area);
  //   return abovePanel || belowPanel;
  // }
  getUniqueAreasFromTemplate(t) {
    const n = t.split(`
`).map((o) => o.trim()).map((o) => o.split('"')[1]).filter((o) => o !== void 0).flatMap((o) => o.split(/\s+/));
    return [...new Set(n)].filter((o) => o !== "");
  }
  firstUpdated() {
    this._onLayoutChange = new Event("layoutchange");
  }
  render() {
    if (this.layout) {
      if (this.layouts[this.layout]) {
        this.innerHTML = "";
        const t = this.layouts[this.layout], s = this.getUniqueAreasFromTemplate(t.template).map((n) => {
          const r = t.elements[n];
          return r && (r.style.gridArea = n), r;
        }).filter((n) => !!n);
        this.style.gridTemplate = t.template, this._onLayoutChange && this.dispatchEvent(this._onLayoutChange), this.append(...s);
      }
    } else
      this.innerHTML = "", this.style.gridTemplate = "", this._onLayoutChange && this.dispatchEvent(this._onLayoutChange);
    return m`<slot></slot>`;
  }
};
zi.styles = C`
    :host {
      display: grid;
      height: 100%;
      width: 100%;
      overflow: hidden;
      box-sizing: border-box;
    }

    /* :host(:not([layout])) {
      display: none;
    } */

    :host([floating]) {
      --bim-panel--bdrs: var(--bim-ui_size-4xs);
      background-color: transparent;
      padding: 1rem;
      gap: 1rem;
      position: absolute;
      pointer-events: none;
      top: 0px;
      left: 0px;
    }

    :host(:not([floating])) {
      --bim-panel--bdrs: 0;
      background-color: var(--bim-ui_bg-contrast-20);
      gap: 1px;
    }
  `;
let ae = zi;
js([
  h({ type: Boolean, reflect: !0 })
], ae.prototype, "floating");
js([
  h({ type: String, reflect: !0 })
], ae.prototype, "layout");
const je = class je extends w {
  render() {
    return m`
      <iconify-icon .icon=${this.icon} height="none"></iconify-icon>
    `;
  }
};
je.styles = C`
    :host {
      height: var(--bim-icon--fz, var(--bim-ui_size-sm));
      width: var(--bim-icon--fz, var(--bim-ui_size-sm));
    }

    iconify-icon {
      height: var(--bim-icon--fz, var(--bim-ui_size-sm));
      width: var(--bim-icon--fz, var(--bim-ui_size-sm));
      color: var(--bim-icon--c);
      transition: all 0.15s;
    }
  `, je.properties = {
  icon: { type: String }
};
let bi = je;
var hl = Object.defineProperty, qe = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && hl(t, e, n), n;
};
const Mi = class Mi extends w {
  constructor() {
    super(...arguments), this.vertical = !1, this.onValueChange = new Event("change");
  }
  get value() {
    const t = {};
    for (const e of this.children) {
      const s = e;
      "value" in s ? t[s.name || s.label] = s.value : "checked" in s && (t[s.name || s.label] = s.checked);
    }
    return t;
  }
  set value(t) {
    const e = [...this.children];
    for (const s in t) {
      const n = e.find((a) => {
        const l = a;
        return l.name === s || l.label === s;
      });
      if (!n)
        continue;
      const r = n, o = t[s];
      typeof o == "boolean" ? r.checked = o : r.value = o;
    }
  }
  render() {
    return m`
      <div class="parent">
        ${this.label || this.icon ? m`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
        <div class="input">
          <slot></slot>
        </div>
      </div>
    `;
  }
};
Mi.styles = C`
    :host {
      flex: 1;
      display: block;
    }

    .parent {
      display: flex;
      flex-wrap: wrap;
      column-gap: 1rem;
      row-gap: 0.375rem;
      user-select: none;
      flex: 1;
    }

    :host(:not([vertical])) .parent {
      justify-content: space-between;
    }

    :host([vertical]) .parent {
      flex-direction: column;
    }

    .input {
      overflow: hidden;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      min-height: 1.75rem;
      min-width: 3rem;
      gap: var(--bim-input--g, var(--bim-ui_size-4xs));
      padding: var(--bim-input--p, 0);
      background-color: var(--bim-input--bgc, transparent);
      outline: var(--bim-input--olw, 2px) solid
        var(--bim-input--olc, transparent);
      border-radius: var(--bim-input--bdrs, var(--bim-ui_size-4xs));
      transition: all 0.15s;
    }

    :host(:not([vertical])) .input {
      flex: 1;
      justify-content: flex-end;
    }

    :host(:not([vertical])[label]) .input {
      max-width: fit-content;
    }
  `;
let Ot = Mi;
qe([
  h({ type: String, reflect: !0 })
], Ot.prototype, "name");
qe([
  h({ type: String, reflect: !0 })
], Ot.prototype, "label");
qe([
  h({ type: String, reflect: !0 })
], Ot.prototype, "icon");
qe([
  h({ type: Boolean, reflect: !0 })
], Ot.prototype, "vertical");
var dl = Object.defineProperty, me = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && dl(t, e, n), n;
};
const ji = class ji extends w {
  constructor() {
    super(...arguments), this.labelHidden = !1, this.iconHidden = !1, this.vertical = !1;
  }
  get value() {
    return this.textContent ? Ue(this.textContent) : this.textContent;
  }
  render() {
    return m`
      <div class="parent" .title=${this.textContent ?? ""}>
        ${this.img ? m`<img .src=${this.img} .alt=${this.textContent || ""} />` : null}
        ${!this.iconHidden && this.icon ? m`<bim-icon .icon=${this.icon}></bim-icon>` : null}
        <p><slot></slot></p>
      </div>
    `;
  }
};
ji.styles = C`
    :host {
      --bim-icon--c: var(--bim-label--c);
      color: var(--bim-label--c, var(--bim-ui_bg-contrast-60));
      font-size: var(--bim-label--fz, var(--bim-ui_size-xs));
      overflow: hidden;
      display: block;
      white-space: nowrap;
      line-height: 1.1rem;
      transition: all 0.15s;
    }

    .parent {
      display: flex;
      align-items: center;
      column-gap: 0.25rem;
      row-gap: 0.125rem;
      user-select: none;
      height: 100%;
    }

    :host([vertical]) .parent {
      flex-direction: column;
    }

    .parent p {
      margin: 0;
      text-overflow: ellipsis;
      overflow: hidden;
      display: flex;
      align-items: center;
      gap: 0.125rem;
    }

    :host([label-hidden]) .parent p,
    :host(:empty) .parent p {
      display: none;
    }

    img {
      height: 100%;
      aspect-ratio: 1;
      border-radius: 100%;
      margin-right: 0.125rem;
    }

    :host(:not([vertical])) img {
      max-height: var(
        --bim-label_icon--sz,
        calc(var(--bim-label--fz, var(--bim-ui_size-xs)) * 1.8)
      );
    }

    :host([vertical]) img {
      max-height: var(
        --bim-label_icon--sz,
        calc(var(--bim-label--fz, var(--bim-ui_size-xs)) * 4)
      );
    }
  `;
let ft = ji;
me([
  h({ type: String, reflect: !0 })
], ft.prototype, "img");
me([
  h({ type: Boolean, attribute: "label-hidden", reflect: !0 })
], ft.prototype, "labelHidden");
me([
  h({ type: String, reflect: !0 })
], ft.prototype, "icon");
me([
  h({ type: Boolean, attribute: "icon-hidden", reflect: !0 })
], ft.prototype, "iconHidden");
me([
  h({ type: Boolean, reflect: !0 })
], ft.prototype, "vertical");
var fl = Object.defineProperty, pl = Object.getOwnPropertyDescriptor, H = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? pl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && fl(t, e, n), n;
};
const Bi = class Bi extends w {
  constructor() {
    super(...arguments), this._value = 0, this.vertical = !1, this.slider = !1, this._input = Nt(), this.onValueChange = new Event("change");
  }
  set value(t) {
    this.setValue(t.toString());
  }
  get value() {
    return this._value;
  }
  onChange(t) {
    t.stopPropagation();
    const { value: e } = this._input;
    e && this.setValue(e.value);
  }
  setValue(t) {
    const { value: e } = this._input;
    let s = t;
    if (s = s.replace(/[^0-9.-]/g, ""), s = s.replace(/(\..*)\./g, "$1"), s.endsWith(".") || (s.lastIndexOf("-") > 0 && (s = s[0] + s.substring(1).replace(/-/g, "")), s === "-" || s === "-0"))
      return;
    let n = Number(s);
    Number.isNaN(n) || (n = this.min !== void 0 ? Math.max(n, this.min) : n, n = this.max !== void 0 ? Math.min(n, this.max) : n, this.value !== n && (this._value = n, e && (e.value = this.value.toString()), this.requestUpdate(), this.dispatchEvent(this.onValueChange)));
  }
  onBlur() {
    const { value: t } = this._input;
    t && Number.isNaN(Number(t.value)) && (t.value = this.value.toString());
  }
  onSliderMouseDown(t) {
    document.body.style.cursor = "w-resize";
    const { clientX: e } = t, s = this.value;
    let n = !1;
    const r = (l) => {
      var v;
      n = !0;
      const { clientX: c } = l, u = this.step ?? 1, d = ((v = u.toString().split(".")[1]) == null ? void 0 : v.length) || 0, f = 1 / (this.sensitivity ?? 1), p = (c - e) / f;
      if (Math.floor(Math.abs(p)) !== Math.abs(p))
        return;
      const b = s + p * u;
      this.setValue(b.toFixed(d));
    }, o = () => {
      this.slider = !0, this.removeEventListener("blur", o);
    }, a = () => {
      document.removeEventListener("mousemove", r), document.body.style.cursor = "default", n ? n = !1 : (this.addEventListener("blur", o), this.slider = !1, requestAnimationFrame(() => this.focus())), document.removeEventListener("mouseup", a);
    };
    document.addEventListener("mousemove", r), document.addEventListener("mouseup", a);
  }
  onFocus(t) {
    t.stopPropagation();
    const e = (s) => {
      s.key === "Escape" && (this.blur(), window.removeEventListener("keydown", e));
    };
    window.addEventListener("keydown", e);
  }
  connectedCallback() {
    super.connectedCallback(), this.min && this.min > this.value && (this._value = this.min), this.max && this.max < this.value && (this._value = this.max);
  }
  /**
   * Sets focus to the input element of the number input component.
   * This method is useful for programmatically focusing the input element, for example,
   * in response to a user action or to emphasize the input in the UI.
   *
   * If the input element reference is not available (not yet rendered or disconnected),
   * this method will do nothing.
   */
  focus() {
    const { value: t } = this._input;
    t && t.focus();
  }
  render() {
    const t = m`
      ${this.pref || this.icon ? m`<bim-label
            style="pointer-events: auto"
            @mousedown=${this.onSliderMouseDown}
            .icon=${this.icon}
            >${this.pref}</bim-label
          >` : null}
      <input
        ${Ht(this._input)}
        type="text"
        aria-label=${this.label || this.name || "Number Input"}
        size="1"
        @input=${(a) => a.stopPropagation()}
        @change=${this.onChange}
        @blur=${this.onBlur}
        @focus=${this.onFocus}
        .value=${this.value.toString()}
      />
      ${this.suffix ? m`<bim-label
            style="pointer-events: auto"
            @mousedown=${this.onSliderMouseDown}
            >${this.suffix}</bim-label
          >` : null}
    `, e = this.min ?? -1 / 0, s = this.max ?? 1 / 0, n = 100 * (this.value - e) / (s - e), r = m`
      <style>
        .slider-indicator {
          width: ${`${n}%`};
        }
      </style>
      <div class="slider" @mousedown=${this.onSliderMouseDown}>
        <div class="slider-indicator"></div>
        ${this.pref || this.icon ? m`<bim-label
              style="z-index: 1; margin-right: 0.125rem"
              .icon=${this.icon}
              >${`${this.pref}: `}</bim-label
            >` : null}
        <bim-label style="z-index: 1;">${this.value}</bim-label>
        ${this.suffix ? m`<bim-label style="z-index: 1;">${this.suffix}</bim-label>` : null}
      </div>
    `, o = `${this.label || this.name || this.pref ? `${this.label || this.name || this.pref}: ` : ""}${this.value}${this.suffix ?? ""}`;
    return m`
      <bim-input
        title=${o}
        .label=${this.label}
        .icon=${this.icon}
        .vertical=${this.vertical}
      >
        ${this.slider ? r : t}
      </bim-input>
    `;
  }
};
Bi.styles = C`
    :host {
      --bim-input--bgc: var(
        --bim-number-input--bgc,
        var(--bim-ui_bg-contrast-20)
      );
      --bim-input--olw: var(--bim-number-input--olw, 2px);
      --bim-input--olc: var(--bim-number-input--olc, transparent);
      --bim-input--bdrs: var(--bim-number-input--bdrs, var(--bim-ui_size-4xs));
      --bim-input--p: 0 0.375rem;
      flex: 1;
      display: block;
    }

    :host(:focus) {
      --bim-input--olw: var(--bim-number-input--olw, 2px);
      --bim-input--olc: var(
        --bim-number-inputfocus--c,
        var(--bim-ui_accent-base)
      );
    }

    :host(:not([slider])) bim-label {
      --bim-label--c: var(
        --bim-number-input_affixes--c,
        var(--bim-ui_bg-contrast-60)
      );
      --bim-label--fz: var(
        --bim-number-input_affixes--fz,
        var(--bim-ui_size-xs)
      );
    }

    p {
      margin: 0;
      padding: 0;
    }

    input {
      background-color: transparent;
      outline: none;
      border: none;
      padding: 0;
      flex-grow: 1;
      text-align: right;
      font-family: inherit;
      font-feature-settings: inherit;
      font-variation-settings: inherit;
      font-size: var(--bim-number-input--fz, var(--bim-ui_size-xs));
      color: var(--bim-number-input--c, var(--bim-ui_bg-contrast-100));
    }

    :host([suffix]:not([pref])) input {
      text-align: left;
    }

    :host([slider]) {
      --bim-input--p: 0;
    }

    :host([slider]) .slider {
      --bim-label--c: var(--bim-ui_bg-contrast-100);
    }

    .slider {
      position: relative;
      display: flex;
      justify-content: center;
      width: 100%;
      height: 100%;
      padding: 0 0.5rem;
    }

    .slider-indicator {
      height: 100%;
      background-color: var(--bim-ui_main-base);
      position: absolute;
      top: 0;
      left: 0;
      border-radius: var(--bim-input--bdrs, var(--bim-ui_size-4xs));
    }

    bim-input {
      display: flex;
    }

    bim-label {
      pointer-events: none;
    }
  `;
let L = Bi;
H([
  h({ type: String, reflect: !0 })
], L.prototype, "name", 2);
H([
  h({ type: String, reflect: !0 })
], L.prototype, "icon", 2);
H([
  h({ type: String, reflect: !0 })
], L.prototype, "label", 2);
H([
  h({ type: String, reflect: !0 })
], L.prototype, "pref", 2);
H([
  h({ type: Number, reflect: !0 })
], L.prototype, "min", 2);
H([
  h({ type: Number, reflect: !0 })
], L.prototype, "value", 1);
H([
  h({ type: Number, reflect: !0 })
], L.prototype, "step", 2);
H([
  h({ type: Number, reflect: !0 })
], L.prototype, "sensitivity", 2);
H([
  h({ type: Number, reflect: !0 })
], L.prototype, "max", 2);
H([
  h({ type: String, reflect: !0 })
], L.prototype, "suffix", 2);
H([
  h({ type: Boolean, reflect: !0 })
], L.prototype, "vertical", 2);
H([
  h({ type: Boolean, reflect: !0 })
], L.prototype, "slider", 2);
var ml = Object.defineProperty, bl = Object.getOwnPropertyDescriptor, be = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? bl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && ml(t, e, n), n;
};
const Ni = class Ni extends w {
  constructor() {
    super(...arguments), this.onValueChange = new Event("change"), this._hidden = !1, this.headerHidden = !1, this.valueTransform = {}, this.activationButton = document.createElement("bim-button");
  }
  set hidden(t) {
    this._hidden = t, this.activationButton.active = !t, this.dispatchEvent(new Event("hiddenchange"));
  }
  get hidden() {
    return this._hidden;
  }
  /**
   * The `value` getter computes and returns the current state of the panel's form elements as an object. This property is dynamic and reflects the current input values within the panel. When accessed, it traverses the panel's child elements, collecting values from those that have a `name` or `label` attribute, and constructs an object where each key corresponds to the `name` or `label` of the element, and the value is the element's value. This property is particularly useful for forms or interactive panels where the user's input needs to be retrieved programmatically. The value returned is a snapshot of the panel's state at the time of access, and it does not maintain a live link to the input elements.
   *
   * @default {}
   * @example <bim-panel></bim-panel> <!-- Access via JavaScript to get value -->
   * @example
   * const panel = document.createElement('bim-panel');
   * document.body.appendChild(panel);
   * console.log(panel.value); // Logs the current value object of the panel
   */
  get value() {
    return Ie(this, this.valueTransform);
  }
  /**
   * The `value` setter allows programmatically updating the values of the panel's form elements. When a data object is passed to this property, it attempts to match the object's keys with the `name` or `label` attributes of the panel's child elements. If a match is found, the corresponding element's value is updated to the value associated with the key in the data object. This property is useful for initializing the panel with specific data or updating its state based on external inputs. Note that this operation does not affect elements without a matching `name` or `label`, and it only updates the values of elements that are direct children of the panel.
   *
   * @type {Record<string, any>}
   * @example <bim-panel></bim-panel> <!-- Set value via JavaScript -->
   * @example
   * const panel = document.createElement('bim-panel');
   * document.body.appendChild(panel);
   * panel.value = { 'input-name': 'John Doe', 'checkbox-name': true };
   */
  set value(t) {
    const e = [...this.children];
    for (const s in t) {
      const n = e.find((o) => {
        const a = o;
        return a.name === s || a.label === s;
      });
      if (!n)
        continue;
      const r = n;
      r.value = t[s];
    }
  }
  connectedCallback() {
    super.connectedCallback(), this.activationButton.active = !this.hidden, this.activationButton.onclick = () => this.hidden = !this.hidden;
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.activationButton.remove();
  }
  /**
   * Collapses all `bim-panel-section` elements within the panel.
   * This method iterates over each `bim-panel-section` found within the panel's DOM and sets their `collapsed` property to `true`,
   * effectively hiding their content from view. This can be used to programmatically minimize the space taken up by sections
   * within the panel, making the panel more compact or to hide details that are not immediately necessary.
   */
  collapseSections() {
    const t = this.querySelectorAll("bim-panel-section");
    for (const e of t)
      e.collapsed = !0;
  }
  /**
   * Expands all `bim-panel-section` elements within the panel.
   * This method iterates over each `bim-panel-section` found within the panel's DOM and sets their `collapsed` property to `false`,
   * effectively showing their content. This can be used to programmatically reveal the content of sections within the panel,
   * making the panel more informative or to display details that are necessary for the user.
   */
  expandSections() {
    const t = this.querySelectorAll("bim-panel-section");
    for (const e of t)
      e.collapsed = !1;
  }
  render() {
    return this.activationButton.icon = this.icon, this.activationButton.label = this.label || this.name, this.activationButton.tooltipTitle = this.label || this.name, m`
      <div class="parent">
        ${this.label || this.name || this.icon ? m`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
        <div class="sections">
          <slot></slot>
        </div>
      </div>
    `;
  }
};
Ni.styles = [
  vt.scrollbar,
  C`
      :host {
        display: flex;
        border-radius: var(--bim-ui_size-base);
        background-color: var(--bim-ui_bg-base);
        overflow: auto;
      }

      :host([hidden]) {
        display: none;
      }

      .parent {
        display: flex;
        flex: 1;
        flex-direction: column;
        pointer-events: auto;
        overflow: auto;
      }

      .parent bim-label {
        --bim-label--c: var(--bim-panel--c, var(--bim-ui_bg-contrast-80));
        --bim-label--fz: var(--bim-panel--fz, var(--bim-ui_size-sm));
        font-weight: 600;
        padding: 1rem;
        flex-shrink: 0;
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([header-hidden]) .parent bim-label {
        display: none;
      }

      .sections {
        display: flex;
        flex-direction: column;
        overflow: auto;
      }

      ::slotted(bim-panel-section:not(:last-child)) {
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }
    `
];
let Z = Ni;
be([
  h({ type: String, reflect: !0 })
], Z.prototype, "icon", 2);
be([
  h({ type: String, reflect: !0 })
], Z.prototype, "name", 2);
be([
  h({ type: String, reflect: !0 })
], Z.prototype, "label", 2);
be([
  h({ type: Boolean, reflect: !0 })
], Z.prototype, "hidden", 1);
be([
  h({ type: Boolean, attribute: "header-hidden", reflect: !0 })
], Z.prototype, "headerHidden", 2);
var gl = Object.defineProperty, ge = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && gl(t, e, n), n;
};
const Hi = class Hi extends w {
  constructor() {
    super(...arguments), this.onValueChange = new Event("change"), this.valueTransform = {};
  }
  /**
   * The `value` getter computes and returns the current state of the panel section's form elements as an object. This object's keys are the `name` or `label` attributes of the child elements, and the values are the corresponding values of these elements. This property is particularly useful for retrieving a consolidated view of the user's input or selections within the panel section. When the value of any child element changes, the returned object from this getter will reflect those changes, providing a dynamic snapshot of the panel section's state. Note that this property does not have a default value as it dynamically reflects the current state of the panel section's form elements.
   * @example <bim-panel-section></bim-panel-section> <!-- Usage in HTML not directly applicable as this is a getter -->
   * @example
   * const section = document.createElement('bim-panel-section');
   * console.log(section.value); // Logs the current value object
   */
  get value() {
    const t = this.parentElement;
    let e;
    return t instanceof Z && (e = t.valueTransform), Object.values(this.valueTransform).length !== 0 && (e = this.valueTransform), Ie(this, e);
  }
  /**
   * The `value` setter allows programmatically updating the values of the panel section's child elements. It accepts an object where keys correspond to the `name` or `label` attributes of the child elements, and the values are the new values to be set for these elements. This property is useful for initializing the panel section with specific values or updating its state based on external data. When the property changes, the corresponding child elements' values are updated to reflect the new state. This does not have a default value as it is a method for updating child elements' values.
   * @type {Record<string, any>}
   * @default undefined
   * @example <bim-panel-section></bim-panel-section> <!-- Usage in HTML not directly applicable as this is a setter -->
   * @example
   * const section = document.createElement('bim-panel-section');
   * section.value = { 'user-settings': 'John Doe' }; // Programmatically sets the value of a child element named 'user-settings'
   */
  set value(t) {
    const e = [...this.children];
    for (const s in t) {
      const n = e.find((o) => {
        const a = o;
        return a.name === s || a.label === s;
      });
      if (!n)
        continue;
      const r = n;
      r.value = t[s];
    }
  }
  onHeaderClick() {
    this.fixed || (this.collapsed = !this.collapsed);
  }
  render() {
    const t = this.label || this.icon || this.name || this.fixed, e = m`<svg
      xmlns="http://www.w3.org/2000/svg"
      height="1.125rem"
      viewBox="0 0 24 24"
      width="1.125rem"
    >
      <path d="M0 0h24v24H0V0z" fill="none" />
      <path d="M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" />
    </svg>`, s = m`<svg
      xmlns="http://www.w3.org/2000/svg"
      height="1.125rem"
      viewBox="0 0 24 24"
      width="1.125rem"
    >
      <path d="M0 0h24v24H0z" fill="none" />
      <path d="M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z" />
    </svg>`, n = this.collapsed ? e : s, r = m`
      <div
        class="header"
        title=${this.label ?? ""}
        @click=${this.onHeaderClick}
      >
        ${this.label || this.icon || this.name ? m`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
        ${this.fixed ? null : n}
      </div>
    `;
    return m`
      <div class="parent">
        ${t ? r : null}
        <div class="components">
          <slot></slot>
        </div>
      </div>
    `;
  }
};
Hi.styles = [
  vt.scrollbar,
  C`
      :host {
        display: block;
        pointer-events: auto;
      }

      :host(:not([fixed])) .header:hover {
        --bim-label--c: var(--bim-ui_accent-base);
        color: var(--bim-ui_accent-base);
        cursor: pointer;
      }

      :host(:not([fixed])) .header:hover svg {
        fill: var(--bim-ui_accent-base);
      }

      .header {
        --bim-label--fz: var(--bim-ui_size-sm);
        --bim-label--c: var(--bim-ui_bg-contrast-80);
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        height: 1.5rem;
        padding: 0.75rem 1rem;
      }

      .header svg {
        fill: var(--bim-ui_bg-contrast-80);
      }

      .title {
        display: flex;
        align-items: center;
        column-gap: 0.5rem;
      }

      .title p {
        font-size: var(--bim-ui_size-sm);
      }

      .components {
        display: flex;
        flex-direction: column;
        row-gap: 0.75rem;
        padding: 0.125rem 1rem 1rem;
      }

      :host(:not([fixed])[collapsed]) .components {
        display: none;
        height: 0px;
      }

      bim-label {
        pointer-events: none;
      }
    `
];
let pt = Hi;
ge([
  h({ type: String, reflect: !0 })
], pt.prototype, "icon");
ge([
  h({ type: String, reflect: !0 })
], pt.prototype, "label");
ge([
  h({ type: String, reflect: !0 })
], pt.prototype, "name");
ge([
  h({ type: Boolean, reflect: !0 })
], pt.prototype, "fixed");
ge([
  h({ type: Boolean, reflect: !0 })
], pt.prototype, "collapsed");
var vl = Object.defineProperty, ve = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && vl(t, e, n), n;
};
const Di = class Di extends w {
  constructor() {
    super(...arguments), this.vertical = !1, this.onValueChange = new Event("change"), this._canEmitEvents = !1, this._value = document.createElement("bim-option"), this.onOptionClick = (t) => {
      this._value = t.target, this.dispatchEvent(this.onValueChange);
      for (const e of this.children)
        e instanceof T && (e.checked = e === t.target);
    };
  }
  get _options() {
    return [...this.querySelectorAll("bim-option")];
  }
  /**
   * Sets the value of the selector.
   * It finds the matching option based on the provided value and sets it as the selected option.
   * If no matching option is found, it does nothing.
   *
   * @param value - The value to set for the selector.
   */
  set value(t) {
    const e = this.findOption(t);
    if (e) {
      for (const s of this._options)
        s.checked = s === e;
      this._value = e, this._canEmitEvents && this.dispatchEvent(this.onValueChange);
    }
  }
  get value() {
    return this._value.value;
  }
  onSlotChange(t) {
    const e = t.target.assignedElements();
    for (const s of e)
      s instanceof T && (s.noMark = !0, s.removeEventListener("click", this.onOptionClick), s.addEventListener("click", this.onOptionClick));
  }
  findOption(t) {
    return this._options.find((s) => s instanceof T ? s.label === t || s.value === t : !1);
  }
  firstUpdated() {
    const t = [...this.children].find(
      (e) => e instanceof T && e.checked
    );
    t && (this._value = t);
  }
  render() {
    return m`
      <bim-input
        .vertical=${this.vertical}
        .label=${this.label}
        .icon=${this.icon}
      >
        <slot @slotchange=${this.onSlotChange}></slot>
      </bim-input>
    `;
  }
};
Di.styles = C`
    :host {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
      --bim-input--g: 0;
      --bim-option--jc: center;
      flex: 1;
      display: block;
    }

    ::slotted(bim-option) {
      border-radius: 0;
    }

    ::slotted(bim-option[checked]) {
      --bim-label--c: var(--bim-ui_main-contrast);
      background-color: var(--bim-ui_main-base);
    }
  `;
let mt = Di;
ve([
  h({ type: String, reflect: !0 })
], mt.prototype, "name");
ve([
  h({ type: String, reflect: !0 })
], mt.prototype, "icon");
ve([
  h({ type: String, reflect: !0 })
], mt.prototype, "label");
ve([
  h({ type: Boolean, reflect: !0 })
], mt.prototype, "vertical");
ve([
  Vt()
], mt.prototype, "_value");
const yl = () => m`
    <style>
      div {
        display: flex;
        gap: 0.375rem;
        border-radius: 0.25rem;
        min-height: 1.25rem;
      }

      [data-type="row"] {
        background-color: var(--bim-ui_bg-contrast-10);
        animation: row-loading 1s linear infinite alternate;
        padding: 0.5rem;
      }

      [data-type="cell"] {
        background-color: var(--bim-ui_bg-contrast-20);
        flex: 0.25;
      }

      @keyframes row-loading {
        0% {
          background-color: var(--bim-ui_bg-contrast-10);
        }
        100% {
          background-color: var(--bim-ui_bg-contrast-20);
        }
      }
    </style>
    <div style="display: flex; flex-direction: column;">
      <div data-type="row" style="gap: 2rem">
        <div data-type="cell" style="flex: 1"></div>
        <div data-type="cell" style="flex: 2"></div>
        <div data-type="cell" style="flex: 1"></div>
        <div data-type="cell" style="flex: 0.5"></div>
      </div>
      <div style="display: flex;">
        <div data-type="row" style="flex: 1">
          <div data-type="cell" style="flex: 0.5"></div>
        </div>
        <div data-type="row" style="flex: 2">
          <div data-type="cell" style="flex: 0.75"></div>
        </div>
        <div data-type="row" style="flex: 1">
          <div data-type="cell"></div>
        </div>
        <div data-type="row" style="flex: 0.5">
          <div data-type="cell" style="flex: 0.75"></div>
        </div>
      </div>
      <div style="display: flex;">
        <div data-type="row" style="flex: 1">
          <div data-type="cell" style="flex: 0.75"></div>
        </div>
        <div data-type="row" style="flex: 2">
          <div data-type="cell"></div>
        </div>
        <div data-type="row" style="flex: 1">
          <div data-type="cell" style="flex: 0.5"></div>
        </div>
        <div data-type="row" style="flex: 0.5">
          <div data-type="cell" style="flex: 0.5"></div>
        </div>
      </div>
      <div style="display: flex;">
        <div data-type="row" style="flex: 1">
          <div data-type="cell"></div>
        </div>
        <div data-type="row" style="flex: 2">
          <div data-type="cell" style="flex: 0.5"></div>
        </div>
        <div data-type="row" style="flex: 1">
          <div data-type="cell" style="flex: 0.75"></div>
        </div>
        <div data-type="row" style="flex: 0.5">
          <div data-type="cell" style="flex: 0.7s5"></div>
        </div>
      </div>
    </div>
  `, _l = () => m`
    <style>
      .loader {
        grid-area: Processing;
        position: relative;
        padding: 0.125rem;
      }
      .loader:before {
        content: "";
        position: absolute;
      }
      .loader .loaderBar {
        position: absolute;
        top: 0;
        right: 100%;
        bottom: 0;
        left: 0;
        background: var(--bim-ui_main-base);
        /* width: 25%; */
        width: 0;
        animation: borealisBar 2s linear infinite;
      }

      @keyframes borealisBar {
        0% {
          left: 0%;
          right: 100%;
          width: 0%;
        }
        10% {
          left: 0%;
          right: 75%;
          width: 25%;
        }
        90% {
          right: 0%;
          left: 75%;
          width: 25%;
        }
        100% {
          left: 100%;
          right: 0%;
          width: 0%;
        }
      }
    </style>
    <div class="loader">
      <div class="loaderBar"></div>
    </div>
  `;
var xl = Object.defineProperty, wl = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && xl(t, e, n), n;
};
const Fi = class Fi extends w {
  constructor() {
    super(...arguments), this.column = "", this.columnIndex = 0, this.rowData = {};
  }
  get data() {
    return this.column ? this.rowData[this.column] : null;
  }
  render() {
    return m`
      <style>
        :host {
          grid-area: ${this.column ?? "unset"};
        }
      </style>
      <slot></slot>
    `;
  }
};
Fi.styles = C`
    :host {
      padding: 0.375rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    :host([data-column-index="0"]) {
      justify-content: normal;
    }

    :host([data-column-index="0"]:not([data-cell-header]))
      ::slotted(bim-label) {
      text-align: left;
    }

    ::slotted(*) {
      --bim-input--bgc: transparent;
      --bim-input--olc: var(--bim-ui_bg-contrast-20);
      --bim-input--olw: 1px;
    }

    ::slotted(bim-input) {
      --bim-input--olw: 0;
    }

    ::slotted(bim-label) {
      white-space: normal;
      text-align: center;
    }
  `;
let Le = Fi;
wl([
  h({ type: String, reflect: !0 })
], Le.prototype, "column");
var $l = Object.defineProperty, Cl = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && $l(t, e, n), n;
};
const Vi = class Vi extends w {
  constructor() {
    super(...arguments), this._groups = [], this.data = [], this.table = this.closest("bim-table");
  }
  toggleGroups(t, e = !1) {
    for (const s of this._groups)
      s.childrenHidden = typeof t > "u" ? !s.childrenHidden : !t, e && s.toggleChildren(t, e);
  }
  render() {
    return this._groups = [], m`
      <slot></slot>
      ${this.data.map((t) => {
      const e = document.createElement(
        "bim-table-group"
      );
      return this._groups.push(e), e.table = this.table, e.data = t, e;
    })}
    `;
  }
};
Vi.styles = C`
    :host {
      --bim-button--bgc: transparent;
      position: relative;
      grid-area: Children;
    }

    :host([hidden]) {
      display: none;
    }

    ::slotted(.branch.branch-vertical) {
      top: 0;
      bottom: 1.125rem;
    }
  `;
let Re = Vi;
Cl([
  h({ type: Array, attribute: !1 })
], Re.prototype, "data");
var El = Object.defineProperty, Sl = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && El(t, e, n), n;
};
const Ui = class Ui extends w {
  constructor() {
    super(...arguments), this.data = { data: {} }, this.childrenHidden = !0, this.table = this.closest("bim-table");
  }
  connectedCallback() {
    super.connectedCallback(), this.table && this.table.expanded ? this.childrenHidden = !1 : this.childrenHidden = !0;
  }
  toggleChildren(t, e = !1) {
    this._children && (this.childrenHidden = typeof t > "u" ? !this.childrenHidden : !t, e && this._children.toggleGroups(t, e));
  }
  render() {
    if (!this.table)
      throw new Error("TableGroup: parent table wasn't found!");
    const t = this.table.getGroupIndentation(this.data) ?? 0, e = m`
      ${this.table.noIndentation ? null : m`
            <style>
              .branch-vertical {
                left: ${t + (this.table.selectableRows ? 1.9375 : 0.5625)}rem;
              }
            </style>
            <div class="branch branch-vertical"></div>
          `}
    `, s = document.createDocumentFragment();
    Bt(e, s);
    let n = null;
    this.table.noIndentation || (n = document.createElement("div"), n.classList.add("branch", "branch-horizontal"), n.style.left = `${t - 1 + (this.table.selectableRows ? 2.05 : 0.5625)}rem`);
    let r = null;
    if (!this.table.noIndentation) {
      const l = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "svg"
      );
      l.setAttribute("height", "9.5"), l.setAttribute("width", "7.5"), l.setAttribute("viewBox", "0 0 4.6666672 7.3333333");
      const c = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "path"
      );
      c.setAttribute(
        "d",
        "m 1.7470835,6.9583848 2.5899999,-2.59 c 0.39,-0.39 0.39,-1.02 0,-1.41 L 1.7470835,0.36838483 c -0.63,-0.62000003 -1.71000005,-0.18 -1.71000005,0.70999997 v 5.17 c 0,0.9 1.08000005,1.34 1.71000005,0.71 z"
      ), l.append(c);
      const u = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "svg"
      );
      u.setAttribute("height", "6.5"), u.setAttribute("width", "9.5"), u.setAttribute("viewBox", "0 0 5.9111118 5.0175439");
      const d = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "path"
      );
      d.setAttribute(
        "d",
        "M -0.33616196,1.922522 2.253838,4.5125219 c 0.39,0.39 1.02,0.39 1.41,0 L 6.2538379,1.922522 c 0.6200001,-0.63 0.18,-1.71000007 -0.7099999,-1.71000007 H 0.37383804 c -0.89999997,0 -1.33999997,1.08000007 -0.71,1.71000007 z"
      ), u.append(d), r = document.createElement("div"), r.addEventListener("click", (f) => {
        f.stopPropagation(), this.toggleChildren();
      }), r.classList.add("caret"), r.style.left = `${(this.table.selectableRows ? 1.5 : 0.125) + t}rem`, this.childrenHidden ? r.append(l) : r.append(u);
    }
    const o = document.createElement("bim-table-row");
    this.data.children && !this.childrenHidden && o.append(s), o.table = this.table, o.data = this.data.data, this.table.dispatchEvent(
      new CustomEvent("rowcreated", { detail: { row: o } })
    ), r && this.data.children && o.append(r), t !== 0 && (!this.data.children || this.childrenHidden) && n && o.append(n);
    let a;
    if (this.data.children) {
      a = document.createElement("bim-table-children"), this._children = a, a.table = this.table, a.data = this.data.children;
      const l = document.createDocumentFragment();
      Bt(e, l), a.append(l);
    }
    return m`
      <div class="parent">${o} ${this.childrenHidden ? null : a}</div>
    `;
  }
};
Ui.styles = C`
    :host {
      position: relative;
    }

    .parent {
      display: grid;
      grid-template-areas: "Data" "Children";
    }

    .branch {
      position: absolute;
      z-index: 1;
    }

    .branch-vertical {
      border-left: 1px dotted var(--bim-ui_bg-contrast-40);
    }

    .branch-horizontal {
      top: 50%;
      width: 1rem;
      border-bottom: 1px dotted var(--bim-ui_bg-contrast-40);
    }

    .caret {
      position: absolute;
      z-index: 2;
      transform: translateY(-50%) rotate(0deg);
      top: 50%;
      display: flex;
      width: 0.95rem;
      height: 0.95rem;
      justify-content: center;
      align-items: center;
      cursor: pointer;
    }

    .caret svg {
      fill: var(--bim-ui_bg-contrast-60);
    }
  `;
let ze = Ui;
Sl([
  h({ type: Boolean, attribute: "children-hidden", reflect: !0 })
], ze.prototype, "childrenHidden");
var Al = Object.defineProperty, qt = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && Al(t, e, n), n;
};
const qi = class qi extends w {
  constructor() {
    super(...arguments), this.selected = !1, this.columns = [], this.hiddenColumns = [], this.data = {}, this.isHeader = !1, this.table = this.closest("bim-table"), this.onTableColumnsChange = () => {
      this.table && (this.columns = this.table.columns);
    }, this.onTableColumnsHidden = () => {
      this.table && (this.hiddenColumns = this.table.hiddenColumns);
    }, this._observer = new IntersectionObserver(
      (t) => {
        this._intersecting = t[0].isIntersecting;
      },
      { rootMargin: "36px" }
    );
  }
  get _columnNames() {
    return this.columns.filter(
      (s) => !this.hiddenColumns.includes(s.name)
    ).map((s) => s.name);
  }
  get _columnWidths() {
    return this.columns.filter(
      (s) => !this.hiddenColumns.includes(s.name)
    ).map((s) => s.width);
  }
  get _isSelected() {
    var t;
    return (t = this.table) == null ? void 0 : t.selection.has(this.data);
  }
  onSelectionChange(t) {
    if (!this.table)
      return;
    const e = t.target;
    this.selected = e.value, e.value ? (this.table.selection.add(this.data), this.table.dispatchEvent(
      new CustomEvent("rowselected", {
        detail: {
          data: this.data
        }
      })
    )) : (this.table.selection.delete(this.data), this.table.dispatchEvent(
      new CustomEvent("rowdeselected", {
        detail: {
          data: this.data
        }
      })
    ));
  }
  connectedCallback() {
    super.connectedCallback(), this._observer.observe(this), this.table && (this.columns = this.table.columns, this.hiddenColumns = this.table.hiddenColumns, this.table.addEventListener("columnschange", this.onTableColumnsChange), this.table.addEventListener("columnshidden", this.onTableColumnsHidden), this.toggleAttribute("selected", this._isSelected));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._observer.unobserve(this), this.table && (this.columns = [], this.hiddenColumns = [], this.table.removeEventListener("columnschange", this.onTableColumnsChange), this.table.removeEventListener("columnshidden", this.onTableColumnsHidden), this.toggleAttribute("selected", !1));
  }
  compute() {
    if (!this.table)
      throw new Error("TableRow: parent table wasn't found!");
    const t = this.table.getRowIndentation(this.data) ?? 0, e = this.isHeader ? this.data : this.table.applyDataTransform(this.data) ?? this.data, s = [];
    for (const n in e) {
      if (this.hiddenColumns.includes(n))
        continue;
      const r = e[n];
      let o;
      if (typeof r == "string" || typeof r == "boolean" || typeof r == "number" ? (o = document.createElement("bim-label"), o.textContent = String(r)) : r instanceof HTMLElement ? o = r : (o = document.createDocumentFragment(), Bt(r, o)), !o)
        continue;
      const a = document.createElement("bim-table-cell");
      a.append(o), a.column = n, this._columnNames.indexOf(n) === 0 && (a.style.marginLeft = `${this.table.noIndentation ? 0 : t + 0.75}rem`);
      const l = this._columnNames.indexOf(n);
      a.setAttribute("data-column-index", String(l)), a.toggleAttribute(
        "data-no-indentation",
        l === 0 && this.table.noIndentation
      ), a.toggleAttribute("data-cell-header", this.isHeader), a.rowData = this.data, this.table.dispatchEvent(
        new CustomEvent("cellcreated", {
          detail: { cell: a }
        })
      ), s.push(a);
    }
    return this.style.gridTemplateAreas = `"${this.table.selectableRows ? "Selection" : ""} ${this._columnNames.join(" ")}"`, this.style.gridTemplateColumns = `${this.table.selectableRows ? "1.6rem" : ""} ${this._columnWidths.join(" ")}`, m`
      ${!this.isHeader && this.table.selectableRows ? m`<bim-checkbox
            @change=${this.onSelectionChange}
            .checked=${this._isSelected}
            style="align-self: center; justify-self: center"
          ></bim-checkbox>` : null}
      ${s}
      <slot></slot>
    `;
  }
  render() {
    return m`${this._intersecting ? this.compute() : m``}`;
  }
};
qi.styles = C`
    :host {
      position: relative;
      grid-area: Data;
      display: grid;
      min-height: 2.25rem;
      transition: all 0.15s;
    }

    ::slotted(.branch.branch-vertical) {
      top: 50%;
      bottom: 0;
    }

    :host([selected]) {
      background-color: color-mix(
        in lab,
        var(--bim-ui_bg-contrast-20) 30%,
        var(--bim-ui_main-base) 10%
      );
    }
  `;
let tt = qi;
qt([
  h({ type: Boolean, reflect: !0 })
], tt.prototype, "selected");
qt([
  h({ attribute: !1 })
], tt.prototype, "columns");
qt([
  h({ attribute: !1 })
], tt.prototype, "hiddenColumns");
qt([
  h({ attribute: !1 })
], tt.prototype, "data");
qt([
  h({ type: Boolean, attribute: "is-header", reflect: !0 })
], tt.prototype, "isHeader");
qt([
  Vt()
], tt.prototype, "_intersecting");
var Ol = Object.defineProperty, kl = Object.getOwnPropertyDescriptor, q = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? kl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && Ol(t, e, n), n;
};
const Wi = class Wi extends w {
  constructor() {
    super(...arguments), this._columnsChange = new Event("columnschange"), this._filteredData = [], this.headersHidden = !1, this.minColWidth = "4rem", this._columns = [], this._textDelimiters = {
      comma: ",",
      tab: "	"
    }, this._queryString = null, this._data = [], this.expanded = !1, this.preserveStructureOnFilter = !1, this.indentationInText = !1, this.dataTransform = {}, this.selectableRows = !1, this.selection = /* @__PURE__ */ new Set(), this.noIndentation = !1, this.loading = !1, this._errorLoading = !1, this._onColumnsHidden = new Event("columnshidden"), this._hiddenColumns = [], this.loadingErrorElement = null, this._stringFilterFunction = (t, e) => Object.values(e.data).some((n) => String(n).toLowerCase().includes(t.toLowerCase())), this._queryFilterFunction = (t, e) => {
      let s = !1;
      const n = mi(t) ?? [];
      for (const r of n) {
        if ("queries" in r) {
          s = !1;
          break;
        }
        const { condition: o, value: a } = r;
        let { key: l } = r;
        if (l.startsWith("[") && l.endsWith("]")) {
          const c = l.replace("[", "").replace("]", "");
          l = c, s = Object.keys(e.data).filter((f) => f.includes(c)).map(
            (f) => zn(e.data[f], o, a)
          ).some((f) => f);
        } else
          s = zn(e.data[l], o, a);
        if (!s)
          break;
      }
      return s;
    };
  }
  set columns(t) {
    const e = [];
    for (const s of t) {
      const n = typeof s == "string" ? { name: s, width: `minmax(${this.minColWidth}, 1fr)` } : s;
      e.push(n);
    }
    this._columns = e, this.computeMissingColumns(this.data), this.dispatchEvent(this._columnsChange);
  }
  get columns() {
    return this._columns;
  }
  get _headerRowData() {
    const t = {};
    for (const e of this.columns)
      if (typeof e == "string")
        t[e] = e;
      else {
        const { name: s } = e;
        t[s] = s;
      }
    return t;
  }
  /**
   * Getter for the `value` property.
   * Returns the filtered data if a search string is provided, otherwise returns the original data.
   *
   * @example
   * ```typescript
   * const tableValue = table.value;
   * console.log(tableValue); // Output: The filtered or original data.
   * ```
   */
  get value() {
    return this._filteredData;
  }
  /**
   * Sets the search string for filtering the table data.
   * This property allows you to filter the table data based on a search string.
   * If a search string is provided, the table will only display rows that match the search criteria.
   * The search criteria can be a simple string or a complex query.
   * If a simple string is provided, the table will filter rows based on the string's presence in any column.
   * If a complex query is provided, the table will filter rows based on the query's conditions and values.
   *
   * @example Simple Query
   * ```typescript
   * table.queryString = "example";
   * ```
   *
   * @example Complex Query
   * ```typescript
   * table.queryString = "column1="Jhon Doe" & column2=20";
   * ```
   */
  set queryString(t) {
    this.toggleAttribute("data-processing", !0), this._queryString = t && t.trim() !== "" ? t.trim() : null, this.updateFilteredData(), this.toggleAttribute("data-processing", !1);
  }
  get queryString() {
    return this._queryString;
  }
  set data(t) {
    this._data = t, this.updateFilteredData(), this.computeMissingColumns(t) && (this.columns = this._columns);
  }
  get data() {
    return this._data;
  }
  get dataAsync() {
    return new Promise((t) => {
      setTimeout(() => {
        t(this.data);
      });
    });
  }
  set hiddenColumns(t) {
    this._hiddenColumns = t, setTimeout(() => {
      this.dispatchEvent(this._onColumnsHidden);
    });
  }
  get hiddenColumns() {
    return this._hiddenColumns;
  }
  updateFilteredData() {
    this.queryString ? (mi(this.queryString) ? (this.filterFunction = this._queryFilterFunction, this._filteredData = this.filter(this.queryString)) : (this.filterFunction = this._stringFilterFunction, this._filteredData = this.filter(this.queryString)), this.preserveStructureOnFilter && (this._expandedBeforeFilter === void 0 && (this._expandedBeforeFilter = this.expanded), this.expanded = !0)) : (this.preserveStructureOnFilter && this._expandedBeforeFilter !== void 0 && (this.expanded = this._expandedBeforeFilter, this._expandedBeforeFilter = void 0), this._filteredData = this.data);
  }
  computeMissingColumns(t) {
    let e = !1;
    for (const s of t) {
      const { children: n, data: r } = s;
      for (const o in r)
        this._columns.map((l) => typeof l == "string" ? l : l.name).includes(o) || (this._columns.push({
          name: o,
          width: `minmax(${this.minColWidth}, 1fr)`
        }), e = !0);
      if (n) {
        const o = this.computeMissingColumns(n);
        o && !e && (e = o);
      }
    }
    return e;
  }
  generateText(t = "comma", e = this.value, s = "", n = !0) {
    const r = this._textDelimiters[t];
    let o = "";
    const a = this.columns.map((l) => l.name);
    if (n) {
      this.indentationInText && (o += `Indentation${r}`);
      const l = `${a.join(r)}
`;
      o += l;
    }
    for (const [l, c] of e.entries()) {
      const { data: u, children: d } = c, f = this.indentationInText ? `${s}${l + 1}${r}` : "", p = a.map((v) => u[v] ?? ""), b = `${f}${p.join(r)}
`;
      o += b, d && (o += this.generateText(
        t,
        c.children,
        `${s}${l + 1}.`,
        !1
      ));
    }
    return o;
  }
  /**
   * A getter function that generates a CSV (Comma Separated Values) representation of the table data.
   *
   * @returns A string containing the CSV representation of the table data.
   *
   * @example
   * ```typescript
   * const csvData = table.csv;
   * console.log(csvData); // Output: "Column 1,Column 2\nValue 1,Value 2\nValue 3,Value 4"
   * ```
   */
  get csv() {
    return this.generateText("comma");
  }
  /**
   * A getter function that generates a Tab Separated Values (TSV) representation of the table data.
   *
   * @returns A string containing the TSV representation of the table data.
   *
   * @example
   * ```typescript
   * const tsvData = table.tsv;
   * console.log(tsvData); // Output: "Column 1\tColumn 2\nValue 1\tValue 2\nValue 3\tValue 4"
   * ```
   */
  get tsv() {
    return this.generateText("tab");
  }
  applyDataTransform(t) {
    const e = {};
    for (const s of Object.keys(this.dataTransform)) {
      const n = this.columns.find((r) => r.name === s);
      n && n.forceDataTransform && (s in t || (t[s] = ""));
    }
    for (const s in t) {
      const n = this.dataTransform[s];
      n ? e[s] = n(t[s], t) : e[s] = t[s];
    }
    return e;
  }
  /**
   * The `downloadData` method is used to download the table data in different formats.
   *
   * @param fileName - The name of the downloaded file. Default is "BIM Table Data".
   * @param format - The format of the downloaded file. Can be "json", "tsv", or "csv". Default is "json".
   *
   * @returns - This method does not return any value.
   *
   * @example
   * ```typescript
   * table.downloadData("MyTableData", "tsv");
   * ```
   */
  downloadData(t = "BIM Table Data", e = "json") {
    let s = null;
    if (e === "json" && (s = new File(
      [JSON.stringify(this.value, void 0, 2)],
      `${t}.json`
    )), e === "csv" && (s = new File([this.csv], `${t}.csv`)), e === "tsv" && (s = new File([this.tsv], `${t}.tsv`)), !s)
      return;
    const n = document.createElement("a");
    n.href = URL.createObjectURL(s), n.download = s.name, n.click(), URL.revokeObjectURL(n.href);
  }
  getRowIndentation(t, e = this.value, s = 0) {
    for (const n of e) {
      if (n.data === t)
        return s;
      if (n.children) {
        const r = this.getRowIndentation(
          t,
          n.children,
          s + 1
        );
        if (r !== null)
          return r;
      }
    }
    return null;
  }
  getGroupIndentation(t, e = this.value, s = 0) {
    for (const n of e) {
      if (n === t)
        return s;
      if (n.children) {
        const r = this.getGroupIndentation(
          t,
          n.children,
          s + 1
        );
        if (r !== null)
          return r;
      }
    }
    return null;
  }
  connectedCallback() {
    super.connectedCallback(), this.dispatchEvent(new Event("connected"));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.dispatchEvent(new Event("disconnected"));
  }
  /**
   * Asynchronously loads data into the table based on Table.loadFunction.
   * If the data is already available, just set it in Table.data.
   *
   * @param force - A boolean indicating whether to force loading even if the table already has data.
   *
   * @returns - A promise that resolves to a boolean indicating whether the data loading was successful.
   * If the promise resolves to `true`, the data loading was successful.
   * If the promise resolves to `false`, the data loading was not successful.
   *
   * @remarks - If the table already has data and `force` is `false`, the function resolves to `false` without making any changes.
   * If the table already has data and `force` is `true`, the existing data is discarded before loading the new data.
   * If an error occurs during data loading, the function sets the `errorLoadingMessage` property with the error message and resolves to `false`.
   */
  async loadData(t = !1) {
    if (this._filteredData.length !== 0 && !t || !this.loadFunction)
      return !1;
    this.loading = !0;
    try {
      const e = await this.loadFunction();
      return this.data = e, this.loading = !1, this._errorLoading = !1, !0;
    } catch (e) {
      return this.loading = !1, this._filteredData.length !== 0 || (e instanceof Error && this.loadingErrorElement && e.message.trim() !== "" && (this.loadingErrorElement.textContent = e.message), this._errorLoading = !0), !1;
    }
  }
  filter(t, e = this.filterFunction ?? this._stringFilterFunction, s = this.data) {
    const n = [];
    for (const r of s)
      if (e(t, r)) {
        if (this.preserveStructureOnFilter) {
          const a = { data: r.data };
          if (r.children) {
            const l = this.filter(
              t,
              e,
              r.children
            );
            l.length && (a.children = l);
          }
          n.push(a);
        } else if (n.push({ data: r.data }), r.children) {
          const a = this.filter(
            t,
            e,
            r.children
          );
          n.push(...a);
        }
      } else if (r.children) {
        const a = this.filter(
          t,
          e,
          r.children
        );
        this.preserveStructureOnFilter && a.length ? n.push({
          data: r.data,
          children: a
        }) : n.push(...a);
      }
    return n;
  }
  get _missingDataElement() {
    return this.querySelector("[slot='missing-data']");
  }
  render() {
    if (this.loading)
      return yl();
    if (this._errorLoading)
      return m`<slot name="error-loading"></slot>`;
    if (this._filteredData.length === 0 && this._missingDataElement)
      return m`<slot name="missing-data"></slot>`;
    const t = document.createElement("bim-table-row");
    t.table = this, t.isHeader = !0, t.data = this._headerRowData, t.style.gridArea = "Header", t.style.position = "sticky", t.style.top = "0", t.style.zIndex = "5";
    const e = document.createElement("bim-table-children");
    return e.table = this, e.data = this.value, e.style.gridArea = "Body", e.style.backgroundColor = "transparent", m`
      <div class="parent">
        ${this.headersHidden ? null : t} ${_l()}
        <div style="overflow-x: hidden; grid-area: Body">${e}</div>
      </div>
    `;
  }
};
Wi.styles = [
  vt.scrollbar,
  C`
      :host {
        position: relative;
        overflow: auto;
        display: block;
        pointer-events: auto;
      }

      :host(:not([data-processing])) .loader {
        display: none;
      }

      .parent {
        display: grid;
        grid-template:
          "Header" auto
          "Processing" auto
          "Body" 1fr
          "Footer" auto;
        overflow: auto;
        height: 100%;
      }

      .parent > bim-table-row[is-header] {
        color: var(--bim-table_header--c, var(--bim-ui_bg-contrast-100));
        background-color: var(
          --bim-table_header--bgc,
          var(--bim-ui_bg-contrast-20)
        );
      }

      .controls {
        display: flex;
        gap: 0.375rem;
        flex-wrap: wrap;
        margin-bottom: 0.5rem;
      }
    `
];
let z = Wi;
q([
  Vt()
], z.prototype, "_filteredData", 2);
q([
  h({
    type: Boolean,
    attribute: "headers-hidden",
    reflect: !0
  })
], z.prototype, "headersHidden", 2);
q([
  h({ type: String, attribute: "min-col-width", reflect: !0 })
], z.prototype, "minColWidth", 2);
q([
  h({ type: Array, attribute: !1 })
], z.prototype, "columns", 1);
q([
  h({ type: Array, attribute: !1 })
], z.prototype, "data", 1);
q([
  h({ type: Boolean, reflect: !0 })
], z.prototype, "expanded", 2);
q([
  h({ type: Boolean, reflect: !0, attribute: "selectable-rows" })
], z.prototype, "selectableRows", 2);
q([
  h({ attribute: !1 })
], z.prototype, "selection", 2);
q([
  h({ type: Boolean, attribute: "no-indentation", reflect: !0 })
], z.prototype, "noIndentation", 2);
q([
  h({ type: Boolean, reflect: !0 })
], z.prototype, "loading", 2);
q([
  Vt()
], z.prototype, "_errorLoading", 2);
var Pl = Object.defineProperty, Tl = Object.getOwnPropertyDescriptor, We = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? Tl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && Pl(t, e, n), n;
};
const Qi = class Qi extends w {
  constructor() {
    super(...arguments), this._defaultName = "__unnamed__", this.name = this._defaultName, this._hidden = !1;
  }
  set hidden(t) {
    this._hidden = t, this.dispatchEvent(new Event("hiddenchange"));
  }
  get hidden() {
    return this._hidden;
  }
  connectedCallback() {
    super.connectedCallback();
    const { parentElement: t } = this;
    if (t && this.name === this._defaultName) {
      const e = [...t.children].indexOf(this);
      this.name = `${this._defaultName}${e}`;
    }
  }
  render() {
    return m` <slot></slot> `;
  }
};
Qi.styles = C`
    :host {
      display: block;
      height: 100%;
    }

    :host([hidden]) {
      display: none;
    }
  `;
let R = Qi;
We([
  h({ type: String, reflect: !0 })
], R.prototype, "name", 2);
We([
  h({ type: String, reflect: !0 })
], R.prototype, "label", 2);
We([
  h({ type: String, reflect: !0 })
], R.prototype, "icon", 2);
We([
  h({ type: Boolean, reflect: !0 })
], R.prototype, "hidden", 1);
var Il = Object.defineProperty, Ll = Object.getOwnPropertyDescriptor, Wt = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? Ll(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && Il(t, e, n), n;
};
const Yi = class Yi extends w {
  constructor() {
    super(...arguments), this._switchers = [], this.bottom = !1, this.switchersHidden = !1, this.floating = !1, this.switchersFull = !1, this.onTabHiddenChange = (t) => {
      const e = t.target;
      e instanceof R && !e.hidden && (e.removeEventListener("hiddenchange", this.onTabHiddenChange), this.tab = e.name, e.addEventListener("hiddenchange", this.onTabHiddenChange));
    };
  }
  set tab(t) {
    this._tab = t;
    const e = [...this.children], s = e.find(
      (n) => n instanceof R && n.name === t
    );
    for (const n of e) {
      if (!(n instanceof R))
        continue;
      n.hidden = s !== n;
      const r = this.getTabSwitcher(n.name);
      r && r.toggleAttribute("data-active", !n.hidden);
    }
  }
  get tab() {
    return this._tab;
  }
  getTabSwitcher(t) {
    return this._switchers.find(
      (s) => s.getAttribute("data-name") === t
    );
  }
  createSwitchers() {
    this._switchers = [];
    for (const t of this.children) {
      if (!(t instanceof R))
        continue;
      const e = document.createElement("div");
      e.addEventListener("click", () => {
        this.tab === t.name ? this.toggleAttribute("tab", !1) : this.tab = t.name;
      }), e.setAttribute("data-name", t.name), e.className = "switcher";
      const s = document.createElement("bim-label");
      s.textContent = t.label ?? "", s.icon = t.icon, e.append(s), this._switchers.push(e);
    }
  }
  onSlotChange(t) {
    this.createSwitchers();
    const e = t.target.assignedElements(), s = e.find((n) => n instanceof R ? this.tab ? n.name === this.tab : !n.hidden : !1);
    s && s instanceof R && (this.tab = s.name);
    for (const n of e) {
      if (!(n instanceof R)) {
        n.remove();
        continue;
      }
      n.removeEventListener("hiddenchange", this.onTabHiddenChange), s !== n && (n.hidden = !0), n.addEventListener("hiddenchange", this.onTabHiddenChange);
    }
  }
  render() {
    return m`
      <div class="parent">
        <div class="switchers">${this._switchers}</div>
        <div class="content">
          <slot @slotchange=${this.onSlotChange}></slot>
        </div>
      </div>
    `;
  }
};
Yi.styles = [
  vt.scrollbar,
  C`
      * {
        box-sizing: border-box;
      }

      :host {
        background-color: var(--bim-ui_bg-base);
        display: block;
        overflow: auto;
      }

      .parent {
        display: grid;
        grid-template: "switchers" auto "content" 1fr;
        height: 100%;
      }

      :host([bottom]) .parent {
        grid-template: "content" 1fr "switchers" auto;
      }

      .switchers {
        display: flex;
        height: 2.25rem;
        font-weight: 600;
        grid-area: switchers;
      }

      .switcher {
        --bim-label--c: var(--bim-ui_bg-contrast-80);
        background-color: var(--bim-ui_bg-base);
        cursor: pointer;
        pointer-events: auto;
        padding: 0rem 0.75rem;
        display: flex;
        justify-content: center;
        transition: all 0.15s;
      }

      :host([switchers-full]) .switcher {
        flex: 1;
      }

      .switcher:hover,
      .switcher[data-active] {
        --bim-label--c: var(--bim-ui_main-contrast);
        background-color: var(--bim-ui_main-base);
      }

      .switchers bim-label {
        pointer-events: none;
      }

      :host([switchers-hidden]) .switchers {
        display: none;
      }

      .content {
        grid-area: content;
        overflow: auto;
      }

      :host(:not([bottom])) .content {
        border-top: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([bottom]) .content {
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host(:not([tab])) .content {
        display: none;
      }

      :host([floating]) {
        background-color: transparent;
      }

      :host([floating]) .switchers {
        justify-self: center;
        overflow: auto;
      }

      :host([floating]:not([bottom])) .switchers {
        border-radius: var(--bim-ui_size-2xs) var(--bim-ui_size-2xs) 0 0;
        border-top: 1px solid var(--bim-ui_bg-contrast-20);
        border-left: 1px solid var(--bim-ui_bg-contrast-20);
        border-right: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating][bottom]) .switchers {
        border-radius: 0 0 var(--bim-ui_size-2xs) var(--bim-ui_size-2xs);
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
        border-left: 1px solid var(--bim-ui_bg-contrast-20);
        border-right: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating]:not([tab])) .switchers {
        border-radius: var(--bim-ui_size-2xs);
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating][bottom]:not([tab])) .switchers {
        border-top: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating]) .content {
        border: 1px solid var(--bim-ui_bg-contrast-20);
        border-radius: var(--bim-ui_size-2xs);
        background-color: var(--bim-ui_bg-base);
      }
    `
];
let et = Yi;
Wt([
  Vt()
], et.prototype, "_switchers", 2);
Wt([
  h({ type: Boolean, reflect: !0 })
], et.prototype, "bottom", 2);
Wt([
  h({ type: Boolean, attribute: "switchers-hidden", reflect: !0 })
], et.prototype, "switchersHidden", 2);
Wt([
  h({ type: Boolean, reflect: !0 })
], et.prototype, "floating", 2);
Wt([
  h({ type: String, reflect: !0 })
], et.prototype, "tab", 1);
Wt([
  h({ type: Boolean, attribute: "switchers-full", reflect: !0 })
], et.prototype, "switchersFull", 2);
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Mn = (i) => i ?? k;
var Rl = Object.defineProperty, zl = Object.getOwnPropertyDescriptor, it = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? zl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && Rl(t, e, n), n;
};
const Gi = class Gi extends w {
  constructor() {
    super(...arguments), this._inputTypes = [
      "date",
      "datetime-local",
      "email",
      "month",
      "password",
      "search",
      "tel",
      "text",
      "time",
      "url",
      "week",
      "area"
    ], this.value = "", this.vertical = !1, this._type = "text", this.onValueChange = new Event("input");
  }
  set type(t) {
    this._inputTypes.includes(t) && (this._type = t);
  }
  get type() {
    return this._type;
  }
  /**
   * Gets the query value derived from the current input value.
   * The `getQuery` function is assumed to be a utility function that takes a string as input
   * and returns a processed query value based on the input.
   *
   * @returns The processed query value derived from the current input value.
   *
   * @example
   * ```typescript
   * const textInput = new TextInput();
   * textInput.value = "Key?Value";
   * console.log(textInput.query);
   * ```
   */
  get query() {
    return mi(this.value);
  }
  onInputChange(t) {
    t.stopPropagation();
    const e = t.target;
    clearTimeout(this._debounceTimeoutID), this._debounceTimeoutID = setTimeout(() => {
      this.value = e.value, this.dispatchEvent(this.onValueChange);
    }, this.debounce);
  }
  focus() {
    setTimeout(() => {
      var e;
      const t = (e = this.shadowRoot) == null ? void 0 : e.querySelector("input");
      t == null || t.focus();
    });
  }
  render() {
    return m`
      <bim-input
        .name=${this.name}
        .icon=${this.icon}
        .label=${this.label}
        .vertical=${this.vertical}
      >
        ${this.type === "area" ? m` <textarea
              aria-label=${this.label || this.name || "Text Input"}
              .value=${this.value}
              .rows=${this.rows ?? 5}
              placeholder=${Mn(this.placeholder)}
              @input=${this.onInputChange}
            ></textarea>` : m` <input
              aria-label=${this.label || this.name || "Text Input"}
              .type=${this.type}
              .value=${this.value}
              placeholder=${Mn(this.placeholder)}
              @input=${this.onInputChange}
            />`}
      </bim-input>
    `;
  }
};
Gi.styles = [
  vt.scrollbar,
  C`
      :host {
        --bim-input--bgc: var(--bim-ui_bg-contrast-20);
        flex: 1;
        display: block;
      }

      input,
      textarea {
        font-family: inherit;
        background-color: transparent;
        border: none;
        width: 100%;
        padding: var(--bim-ui_size-3xs);
        color: var(--bim-text-input--c, var(--bim-ui_bg-contrast-100));
      }

      input {
        outline: none;
        height: 100%;
        padding: 0 var(--bim-ui_size-3xs); /* Override padding */
        border-radius: var(--bim-text-input--bdrs, var(--bim-ui_size-4xs));
      }

      textarea {
        line-height: 1.1rem;
        resize: vertical;
      }

      :host(:focus) {
        --bim-input--olc: var(--bim-ui_accent-base);
      }

      /* :host([disabled]) {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
    } */
    `
];
let B = Gi;
it([
  h({ type: String, reflect: !0 })
], B.prototype, "icon", 2);
it([
  h({ type: String, reflect: !0 })
], B.prototype, "label", 2);
it([
  h({ type: String, reflect: !0 })
], B.prototype, "name", 2);
it([
  h({ type: String, reflect: !0 })
], B.prototype, "placeholder", 2);
it([
  h({ type: String, reflect: !0 })
], B.prototype, "value", 2);
it([
  h({ type: Boolean, reflect: !0 })
], B.prototype, "vertical", 2);
it([
  h({ type: Number, reflect: !0 })
], B.prototype, "debounce", 2);
it([
  h({ type: Number, reflect: !0 })
], B.prototype, "rows", 2);
it([
  h({ type: String, reflect: !0 })
], B.prototype, "type", 1);
var Ml = Object.defineProperty, jl = Object.getOwnPropertyDescriptor, Bs = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? jl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && Ml(t, e, n), n;
};
const Ki = class Ki extends w {
  constructor() {
    super(...arguments), this.rows = 2, this._vertical = !1;
  }
  set vertical(t) {
    this._vertical = t, this.updateChildren();
  }
  get vertical() {
    return this._vertical;
  }
  updateChildren() {
    const t = this.children;
    for (const e of t)
      this.vertical ? e.setAttribute("label-hidden", "") : e.removeAttribute("label-hidden");
  }
  render() {
    return m`
      <style>
        .parent {
          grid-auto-flow: ${this.vertical ? "row" : "column"};
          grid-template-rows: repeat(${this.rows}, 1fr);
        }
      </style>
      <div class="parent">
        <slot @slotchange=${this.updateChildren}></slot>
      </div>
    `;
  }
};
Ki.styles = C`
    .parent {
      display: grid;
      gap: 0.25rem;
    }

    ::slotted(bim-button[label]:not([vertical])) {
      --bim-button--jc: flex-start;
    }

    ::slotted(bim-button) {
      --bim-label--c: var(--bim-ui_bg-contrast-80);
    }
  `;
let Dt = Ki;
Bs([
  h({ type: Number, reflect: !0 })
], Dt.prototype, "rows", 2);
Bs([
  h({ type: Boolean, reflect: !0 })
], Dt.prototype, "vertical", 1);
var Bl = Object.defineProperty, Nl = Object.getOwnPropertyDescriptor, Qe = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? Nl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && Bl(t, e, n), n;
};
const Xi = class Xi extends w {
  constructor() {
    super(...arguments), this._vertical = !1, this._labelHidden = !1;
  }
  set vertical(t) {
    this._vertical = t, this.updateChildren();
  }
  get vertical() {
    return this._vertical;
  }
  set labelHidden(t) {
    this._labelHidden = t, this.updateChildren();
  }
  get labelHidden() {
    return this._labelHidden;
  }
  updateChildren() {
    const t = this.children;
    for (const e of t)
      e instanceof Dt && (e.vertical = this.vertical), e.toggleAttribute("label-hidden", this.vertical);
  }
  render() {
    return m`
      <div class="parent">
        <div class="children">
          <slot @slotchange=${this.updateChildren}></slot>
        </div>
        ${!this.labelHidden && (this.label || this.icon) ? m`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
      </div>
    `;
  }
};
Xi.styles = C`
    :host {
      --bim-label--fz: var(--bim-ui_size-xs);
      --bim-label--c: var(--bim-ui_bg-contrast-60);
      display: block;
      flex: 1;
    }

    :host(:not([vertical])) ::slotted(bim-button[vertical]) {
      --bim-icon--fz: var(--bim-ui_size-5xl);
      min-height: 3.75rem;
    }

    ::slotted(bim-button) {
      --bim-label--c: var(--bim-ui_bg-contrast-80);
    }

    .parent {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      align-items: center;
      padding: 0.5rem;
      height: 100%;
      box-sizing: border-box;
      justify-content: space-between;
    }

    :host([vertical]) .parent {
      flex-direction: row-reverse;
    }

    :host([vertical]) .parent > bim-label {
      writing-mode: tb;
    }

    .children {
      display: flex;
      gap: 0.25rem;
    }

    :host([vertical]) .children {
      flex-direction: column;
    }
  `;
let bt = Xi;
Qe([
  h({ type: String, reflect: !0 })
], bt.prototype, "label", 2);
Qe([
  h({ type: String, reflect: !0 })
], bt.prototype, "icon", 2);
Qe([
  h({ type: Boolean, reflect: !0 })
], bt.prototype, "vertical", 1);
Qe([
  h({ type: Boolean, attribute: "label-hidden", reflect: !0 })
], bt.prototype, "labelHidden", 1);
var Hl = Object.defineProperty, Dl = Object.getOwnPropertyDescriptor, Pi = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? Dl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && Hl(t, e, n), n;
};
const Ji = class Ji extends w {
  constructor() {
    super(...arguments), this.labelsHidden = !1, this._vertical = !1, this._hidden = !1;
  }
  set vertical(t) {
    this._vertical = t, this.updateSections();
  }
  get vertical() {
    return this._vertical;
  }
  set hidden(t) {
    this._hidden = t, this.dispatchEvent(new Event("hiddenchange"));
  }
  get hidden() {
    return this._hidden;
  }
  // private setActivationButton() {
  //   this.activationButton.draggable = Manager.config.draggableToolbars;
  //   this.activationButton.addEventListener(
  //     "click",
  //     () => (this.hidden = !this.hidden),
  //   );
  //   this.activationButton.setAttribute("data-ui-manager-id", this._managerID);
  //   this.activationButton.addEventListener("dragstart", (e) => {
  //     const id = this.getAttribute("data-ui-manager-id");
  //     if (e.dataTransfer && id) {
  //       e.dataTransfer.setData("id", id);
  //       e.dataTransfer.effectAllowed = "move";
  //     }
  //     const containers = document.querySelectorAll("bim-toolbars-container");
  //     for (const container of containers) {
  //       if (container === this.parentElement) continue;
  //       container.dropping = true;
  //     }
  //   });
  //   this.activationButton.addEventListener("dragend", (e) => {
  //     if (e.dataTransfer) e.dataTransfer.clearData();
  //     const containers = document.querySelectorAll("bim-toolbars-container");
  //     for (const container of containers) {
  //       container.dropping = false;
  //     }
  //   });
  // }
  updateSections() {
    const t = this.children;
    for (const e of t)
      e instanceof bt && (e.labelHidden = this.vertical && !Te.config.sectionLabelOnVerticalToolbar, e.vertical = this.vertical);
  }
  // firstUpdated() {
  //   this.setAttribute("data-ui-manager-id", this._managerID);
  // }
  render() {
    return m`
      <div class="parent">
        <slot @slotchange=${this.updateSections}></slot>
      </div>
    `;
  }
};
Ji.styles = C`
    :host {
      --bim-button--bgc: transparent;
      background-color: var(--bim-ui_bg-base);
      border-radius: var(--bim-ui_size-2xs);
      display: block;
    }

    :host([hidden]) {
      display: none;
    }

    .parent {
      display: flex;
      width: min-content;
      pointer-events: auto;
    }

    :host([vertical]) .parent {
      flex-direction: column;
    }

    :host([vertical]) {
      width: min-content;
      border-radius: var(--bim-ui_size-2xs);
      border: 1px solid var(--bim-ui_bg-contrast-20);
    }

    ::slotted(bim-toolbar-section:not(:last-child)) {
      border-right: 1px solid var(--bim-ui_bg-contrast-20);
      border-bottom: none;
    }

    :host([vertical]) ::slotted(bim-toolbar-section:not(:last-child)) {
      border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      border-right: none;
    }
  `;
let Ft = Ji;
Pi([
  h({ type: String, reflect: !0 })
], Ft.prototype, "icon", 2);
Pi([
  h({ type: Boolean, attribute: "labels-hidden", reflect: !0 })
], Ft.prototype, "labelsHidden", 2);
Pi([
  h({ type: Boolean, reflect: !0 })
], Ft.prototype, "vertical", 1);
var Fl = Object.defineProperty, Vl = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && Fl(t, e, n), n;
};
const Zi = class Zi extends w {
  constructor() {
    super(), this._onResize = new Event("resize"), new ResizeObserver(() => {
      setTimeout(() => {
        this.dispatchEvent(this._onResize);
      });
    }).observe(this);
  }
  render() {
    return m`
      <div class="parent">
        <slot></slot>
      </div>
    `;
  }
};
Zi.styles = C`
    :host {
      display: grid;
      min-width: 0;
      min-height: 0;
      height: 100%;
    }

    .parent {
      overflow: hidden;
      position: relative;
    }
  `;
let Me = Zi;
Vl([
  h({ type: String, reflect: !0 })
], Me.prototype, "name");
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Ns = "important", Ul = " !" + Ns, Ql = us(class extends hs {
  constructor(i) {
    var t;
    if (super(i), i.type !== cs.ATTRIBUTE || i.name !== "style" || ((t = i.strings) == null ? void 0 : t.length) > 2)
      throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(i) {
    return Object.keys(i).reduce((t, e) => {
      const s = i[e];
      return s == null ? t : t + `${e = e.includes("-") ? e : e.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${s};`;
    }, "");
  }
  update(i, [t]) {
    const { style: e } = i.element;
    if (this.ft === void 0)
      return this.ft = new Set(Object.keys(t)), this.render(t);
    for (const s of this.ft)
      t[s] == null && (this.ft.delete(s), s.includes("-") ? e.removeProperty(s) : e[s] = null);
    for (const s in t) {
      const n = t[s];
      if (n != null) {
        this.ft.add(s);
        const r = typeof n == "string" && n.endsWith(Ul);
        s.includes("-") || r ? e.setProperty(s, r ? n.slice(0, -11) : n, r ? Ns : "") : e[s] = n;
      }
    }
    return At;
  }
});
export {
  il as Button,
  dt as Checkbox,
  J as ColorInput,
  zs as Component,
  pi as ContextMenu,
  V as Dropdown,
  ae as Grid,
  bi as Icon,
  Ot as Input,
  ft as Label,
  Te as Manager,
  L as NumberInput,
  T as Option,
  Z as Panel,
  pt as PanelSection,
  mt as Selector,
  R as Tab,
  z as Table,
  Le as TableCell,
  Re as TableChildren,
  ze as TableGroup,
  tt as TableRow,
  et as Tabs,
  B as TextInput,
  Ft as Toolbar,
  Dt as ToolbarGroup,
  bt as ToolbarSection,
  Me as Viewport,
  m as html,
  Ht as ref,
  Ql as styleMap
};
