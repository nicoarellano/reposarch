var so = Object.defineProperty;
var io = (c, s, t) => s in c ? so(c, s, { enumerable: !0, configurable: !0, writable: !0, value: t }) : c[s] = t;
var T = (c, s, t) => (io(c, typeof s != "symbol" ? s + "" : s, t), t);
import * as M from "three";
import { BufferAttribute as Nr, Vector3 as q, Vector2 as Je, Plane as gn, Line3 as he, Triangle as je, Sphere as no, Matrix4 as de, Box3 as se, BackSide as ro, DoubleSide as br, FrontSide as Pn, Mesh as rt, Ray as oo, Raycaster as ao, Quaternion as le, Object3D as Qi, Euler as co, MeshBasicMaterial as Pr, LineBasicMaterial as lo, CylinderGeometry as zt, BoxGeometry as Dt, BufferGeometry as Ln, Float32BufferAttribute as Mn, OctahedronGeometry as Ms, Line as Ie, SphereGeometry as ho, TorusGeometry as rs, PlaneGeometry as uo } from "three";
import * as ye from "@thatopen/fragments";
import { Serializer as fo } from "@thatopen/fragments";
import * as X from "web-ifc";
const Lr = 0, po = 1, Eo = 2, xn = 2, Ni = 1.25, vn = 1, ri = 6 * 4 + 4 + 4, wi = 65535, mo = Math.pow(2, -24), bi = Symbol("SKIP_GENERATION");
function Io(c) {
  return c.index ? c.index.count : c.attributes.position.count;
}
function es(c) {
  return Io(c) / 3;
}
function go(c, s = ArrayBuffer) {
  return c > 65535 ? new Uint32Array(new s(4 * c)) : new Uint16Array(new s(2 * c));
}
function Co(c, s) {
  if (!c.index) {
    const t = c.attributes.position.count, e = s.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer, i = go(t, e);
    c.setIndex(new Nr(i, 1));
    for (let n = 0; n < t; n++)
      i[n] = n;
  }
}
function Mr(c) {
  const s = es(c), t = c.drawRange, e = t.start / 3, i = (t.start + t.count) / 3, n = Math.max(0, e), r = Math.min(s, i) - n;
  return [{
    offset: Math.floor(n),
    count: Math.floor(r)
  }];
}
function xr(c) {
  if (!c.groups || !c.groups.length)
    return Mr(c);
  const s = [], t = /* @__PURE__ */ new Set(), e = c.drawRange, i = e.start / 3, n = (e.start + e.count) / 3;
  for (const o of c.groups) {
    const a = o.start / 3, l = (o.start + o.count) / 3;
    t.add(Math.max(i, a)), t.add(Math.min(n, l));
  }
  const r = Array.from(t.values()).sort((o, a) => o - a);
  for (let o = 0; o < r.length - 1; o++) {
    const a = r[o], l = r[o + 1];
    s.push({
      offset: Math.floor(a),
      count: Math.floor(l - a)
    });
  }
  return s;
}
function To(c) {
  if (c.groups.length === 0)
    return !1;
  const s = es(c), t = xr(c).sort((n, r) => n.offset - r.offset), e = t[t.length - 1];
  e.count = Math.min(s - e.offset, e.count);
  let i = 0;
  return t.forEach(({ count: n }) => i += n), s !== i;
}
function wt(c, s, t) {
  return t.min.x = s[c], t.min.y = s[c + 1], t.min.z = s[c + 2], t.max.x = s[c + 3], t.max.y = s[c + 4], t.max.z = s[c + 5], t;
}
function _o(c) {
  c[0] = c[1] = c[2] = 1 / 0, c[3] = c[4] = c[5] = -1 / 0;
}
function Dn(c) {
  let s = -1, t = -1 / 0;
  for (let e = 0; e < 3; e++) {
    const i = c[e + 3] - c[e];
    i > t && (t = i, s = e);
  }
  return s;
}
function Un(c, s) {
  s.set(c);
}
function Bn(c, s, t) {
  let e, i;
  for (let n = 0; n < 3; n++) {
    const r = n + 3;
    e = c[n], i = s[n], t[n] = e < i ? e : i, e = c[r], i = s[r], t[r] = e > i ? e : i;
  }
}
function xs(c, s, t) {
  for (let e = 0; e < 3; e++) {
    const i = s[c + 2 * e], n = s[c + 2 * e + 1], r = i - n, o = i + n;
    r < t[e] && (t[e] = r), o > t[e + 3] && (t[e + 3] = o);
  }
}
function os(c) {
  const s = c[3] - c[0], t = c[4] - c[1], e = c[5] - c[2];
  return 2 * (s * t + t * e + e * s);
}
function Pi(c, s, t, e, i = null) {
  let n = 1 / 0, r = 1 / 0, o = 1 / 0, a = -1 / 0, l = -1 / 0, h = -1 / 0, d = 1 / 0, u = 1 / 0, f = 1 / 0, E = -1 / 0, p = -1 / 0, I = -1 / 0;
  const m = i !== null;
  for (let C = s * 6, R = (s + t) * 6; C < R; C += 6) {
    const g = c[C + 0], y = c[C + 1], F = g - y, S = g + y;
    F < n && (n = F), S > a && (a = S), m && g < d && (d = g), m && g > E && (E = g);
    const L = c[C + 2], N = c[C + 3], x = L - N, k = L + N;
    x < r && (r = x), k > l && (l = k), m && L < u && (u = L), m && L > p && (p = L);
    const w = c[C + 4], P = c[C + 5], _ = w - P, v = w + P;
    _ < o && (o = _), v > h && (h = v), m && w < f && (f = w), m && w > I && (I = w);
  }
  e[0] = n, e[1] = r, e[2] = o, e[3] = a, e[4] = l, e[5] = h, m && (i[0] = d, i[1] = u, i[2] = f, i[3] = E, i[4] = p, i[5] = I);
}
function Ao(c, s, t, e) {
  let i = 1 / 0, n = 1 / 0, r = 1 / 0, o = -1 / 0, a = -1 / 0, l = -1 / 0;
  for (let h = s * 6, d = (s + t) * 6; h < d; h += 6) {
    const u = c[h + 0];
    u < i && (i = u), u > o && (o = u);
    const f = c[h + 2];
    f < n && (n = f), f > a && (a = f);
    const E = c[h + 4];
    E < r && (r = E), E > l && (l = E);
  }
  e[0] = i, e[1] = n, e[2] = r, e[3] = o, e[4] = a, e[5] = l;
}
function Ro(c, s) {
  _o(s);
  const t = c.attributes.position, e = c.index ? c.index.array : null, i = es(c), n = new Float32Array(i * 6), r = t.normalized, o = t.array, a = t.offset || 0;
  let l = 3;
  t.isInterleavedBufferAttribute && (l = t.data.stride);
  const h = ["getX", "getY", "getZ"];
  for (let d = 0; d < i; d++) {
    const u = d * 3, f = d * 6;
    let E = u + 0, p = u + 1, I = u + 2;
    e && (E = e[E], p = e[p], I = e[I]), r || (E = E * l + a, p = p * l + a, I = I * l + a);
    for (let m = 0; m < 3; m++) {
      let C, R, g;
      r ? (C = t[h[m]](E), R = t[h[m]](p), g = t[h[m]](I)) : (C = o[E + m], R = o[p + m], g = o[I + m]);
      let y = C;
      R < y && (y = R), g < y && (y = g);
      let F = C;
      R > F && (F = R), g > F && (F = g);
      const S = (F - y) / 2, L = m * 2;
      n[f + L + 0] = y + S, n[f + L + 1] = S + (Math.abs(y) + S) * mo, y < s[m] && (s[m] = y), F > s[m + 3] && (s[m + 3] = F);
    }
  }
  return n;
}
const fe = 32, yo = (c, s) => c.candidate - s.candidate, ge = new Array(fe).fill().map(() => ({
  count: 0,
  bounds: new Float32Array(6),
  rightCacheBounds: new Float32Array(6),
  leftCacheBounds: new Float32Array(6),
  candidate: 0
})), vs = new Float32Array(6);
function wo(c, s, t, e, i, n) {
  let r = -1, o = 0;
  if (n === Lr)
    r = Dn(s), r !== -1 && (o = (s[r] + s[r + 3]) / 2);
  else if (n === po)
    r = Dn(c), r !== -1 && (o = Fo(t, e, i, r));
  else if (n === Eo) {
    const a = os(c);
    let l = Ni * i;
    const h = e * 6, d = (e + i) * 6;
    for (let u = 0; u < 3; u++) {
      const f = s[u], I = (s[u + 3] - f) / fe;
      if (i < fe / 4) {
        const m = [...ge];
        m.length = i;
        let C = 0;
        for (let g = h; g < d; g += 6, C++) {
          const y = m[C];
          y.candidate = t[g + 2 * u], y.count = 0;
          const {
            bounds: F,
            leftCacheBounds: S,
            rightCacheBounds: L
          } = y;
          for (let N = 0; N < 3; N++)
            L[N] = 1 / 0, L[N + 3] = -1 / 0, S[N] = 1 / 0, S[N + 3] = -1 / 0, F[N] = 1 / 0, F[N + 3] = -1 / 0;
          xs(g, t, F);
        }
        m.sort(yo);
        let R = i;
        for (let g = 0; g < R; g++) {
          const y = m[g];
          for (; g + 1 < R && m[g + 1].candidate === y.candidate; )
            m.splice(g + 1, 1), R--;
        }
        for (let g = h; g < d; g += 6) {
          const y = t[g + 2 * u];
          for (let F = 0; F < R; F++) {
            const S = m[F];
            y >= S.candidate ? xs(g, t, S.rightCacheBounds) : (xs(g, t, S.leftCacheBounds), S.count++);
          }
        }
        for (let g = 0; g < R; g++) {
          const y = m[g], F = y.count, S = i - y.count, L = y.leftCacheBounds, N = y.rightCacheBounds;
          let x = 0;
          F !== 0 && (x = os(L) / a);
          let k = 0;
          S !== 0 && (k = os(N) / a);
          const w = vn + Ni * (x * F + k * S);
          w < l && (r = u, l = w, o = y.candidate);
        }
      } else {
        for (let R = 0; R < fe; R++) {
          const g = ge[R];
          g.count = 0, g.candidate = f + I + R * I;
          const y = g.bounds;
          for (let F = 0; F < 3; F++)
            y[F] = 1 / 0, y[F + 3] = -1 / 0;
        }
        for (let R = h; R < d; R += 6) {
          let F = ~~((t[R + 2 * u] - f) / I);
          F >= fe && (F = fe - 1);
          const S = ge[F];
          S.count++, xs(R, t, S.bounds);
        }
        const m = ge[fe - 1];
        Un(m.bounds, m.rightCacheBounds);
        for (let R = fe - 2; R >= 0; R--) {
          const g = ge[R], y = ge[R + 1];
          Bn(g.bounds, y.rightCacheBounds, g.rightCacheBounds);
        }
        let C = 0;
        for (let R = 0; R < fe - 1; R++) {
          const g = ge[R], y = g.count, F = g.bounds, L = ge[R + 1].rightCacheBounds;
          y !== 0 && (C === 0 ? Un(F, vs) : Bn(F, vs, vs)), C += y;
          let N = 0, x = 0;
          C !== 0 && (N = os(vs) / a);
          const k = i - C;
          k !== 0 && (x = os(L) / a);
          const w = vn + Ni * (N * C + x * k);
          w < l && (r = u, l = w, o = g.candidate);
        }
      }
    }
  } else
    console.warn(`MeshBVH: Invalid build strategy value ${n} used.`);
  return { axis: r, pos: o };
}
function Fo(c, s, t, e) {
  let i = 0;
  for (let n = s, r = s + t; n < r; n++)
    i += c[n * 6 + e * 2];
  return i / t;
}
class Ds {
  constructor() {
  }
}
function So(c, s, t, e, i, n) {
  let r = e, o = e + i - 1;
  const a = n.pos, l = n.axis * 2;
  for (; ; ) {
    for (; r <= o && t[r * 6 + l] < a; )
      r++;
    for (; r <= o && t[o * 6 + l] >= a; )
      o--;
    if (r < o) {
      for (let h = 0; h < 3; h++) {
        let d = s[r * 3 + h];
        s[r * 3 + h] = s[o * 3 + h], s[o * 3 + h] = d;
      }
      for (let h = 0; h < 6; h++) {
        let d = t[r * 6 + h];
        t[r * 6 + h] = t[o * 6 + h], t[o * 6 + h] = d;
      }
      r++, o--;
    } else
      return r;
  }
}
function Oo(c, s, t, e, i, n) {
  let r = e, o = e + i - 1;
  const a = n.pos, l = n.axis * 2;
  for (; ; ) {
    for (; r <= o && t[r * 6 + l] < a; )
      r++;
    for (; r <= o && t[o * 6 + l] >= a; )
      o--;
    if (r < o) {
      let h = c[r];
      c[r] = c[o], c[o] = h;
      for (let d = 0; d < 6; d++) {
        let u = t[r * 6 + d];
        t[r * 6 + d] = t[o * 6 + d], t[o * 6 + d] = u;
      }
      r++, o--;
    } else
      return r;
  }
}
function No(c, s) {
  const t = (c.index ? c.index.count : c.attributes.position.count) / 3, e = t > 2 ** 16, i = e ? 4 : 2, n = s ? new SharedArrayBuffer(t * i) : new ArrayBuffer(t * i), r = e ? new Uint32Array(n) : new Uint16Array(n);
  for (let o = 0, a = r.length; o < a; o++)
    r[o] = o;
  return r;
}
function bo(c, s) {
  const t = c.geometry, e = t.index ? t.index.array : null, i = s.maxDepth, n = s.verbose, r = s.maxLeafTris, o = s.strategy, a = s.onProgress, l = es(t), h = c._indirectBuffer;
  let d = !1;
  const u = new Float32Array(6), f = new Float32Array(6), E = Ro(t, u), p = s.indirect ? Oo : So, I = [], m = s.indirect ? Mr(t) : xr(t);
  if (m.length === 1) {
    const g = m[0], y = new Ds();
    y.boundingData = u, Ao(E, g.offset, g.count, f), R(y, g.offset, g.count, f), I.push(y);
  } else
    for (let g of m) {
      const y = new Ds();
      y.boundingData = new Float32Array(6), Pi(E, g.offset, g.count, y.boundingData, f), R(y, g.offset, g.count, f), I.push(y);
    }
  return I;
  function C(g) {
    a && a(g / l);
  }
  function R(g, y, F, S = null, L = 0) {
    if (!d && L >= i && (d = !0, n && (console.warn(`MeshBVH: Max depth of ${i} reached when generating BVH. Consider increasing maxDepth.`), console.warn(t))), F <= r || L >= i)
      return C(y + F), g.offset = y, g.count = F, g;
    const N = wo(g.boundingData, S, E, y, F, o);
    if (N.axis === -1)
      return C(y + F), g.offset = y, g.count = F, g;
    const x = p(h, e, E, y, F, N);
    if (x === y || x === y + F)
      C(y + F), g.offset = y, g.count = F;
    else {
      g.splitAxis = N.axis;
      const k = new Ds(), w = y, P = x - y;
      g.left = k, k.boundingData = new Float32Array(6), Pi(E, w, P, k.boundingData, f), R(k, w, P, f, L + 1);
      const _ = new Ds(), v = x, Q = F - P;
      g.right = _, _.boundingData = new Float32Array(6), Pi(E, v, Q, _.boundingData, f), R(_, v, Q, f, L + 1);
    }
    return g;
  }
}
function Po(c, s) {
  const t = c.geometry;
  s.indirect && (c._indirectBuffer = No(t, s.useSharedArrayBuffer), To(t) && !s.verbose && console.warn(
    'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.'
  )), c._indirectBuffer || Co(t, s);
  const e = bo(c, s);
  let i, n, r;
  const o = [], a = s.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
  for (let d = 0; d < e.length; d++) {
    const u = e[d];
    let f = l(u);
    const E = new a(ri * f);
    i = new Float32Array(E), n = new Uint32Array(E), r = new Uint16Array(E), h(0, u), o.push(E);
  }
  c._roots = o;
  return;
  function l(d) {
    return d.count ? 1 : 1 + l(d.left) + l(d.right);
  }
  function h(d, u) {
    const f = d / 4, E = d / 2, p = !!u.count, I = u.boundingData;
    for (let m = 0; m < 6; m++)
      i[f + m] = I[m];
    if (p) {
      const m = u.offset, C = u.count;
      return n[f + 6] = m, r[E + 14] = C, r[E + 15] = wi, d + ri;
    } else {
      const m = u.left, C = u.right, R = u.splitAxis;
      let g;
      if (g = h(d + ri, m), g / 4 > Math.pow(2, 32))
        throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
      return n[f + 6] = g / 4, g = h(g, C), n[f + 7] = R, g;
    }
  }
}
class pe {
  constructor() {
    this.min = 1 / 0, this.max = -1 / 0;
  }
  setFromPointsField(s, t) {
    let e = 1 / 0, i = -1 / 0;
    for (let n = 0, r = s.length; n < r; n++) {
      const a = s[n][t];
      e = a < e ? a : e, i = a > i ? a : i;
    }
    this.min = e, this.max = i;
  }
  setFromPoints(s, t) {
    let e = 1 / 0, i = -1 / 0;
    for (let n = 0, r = t.length; n < r; n++) {
      const o = t[n], a = s.dot(o);
      e = a < e ? a : e, i = a > i ? a : i;
    }
    this.min = e, this.max = i;
  }
  isSeparated(s) {
    return this.min > s.max || s.min > this.max;
  }
}
pe.prototype.setFromBox = function() {
  const c = new q();
  return function(t, e) {
    const i = e.min, n = e.max;
    let r = 1 / 0, o = -1 / 0;
    for (let a = 0; a <= 1; a++)
      for (let l = 0; l <= 1; l++)
        for (let h = 0; h <= 1; h++) {
          c.x = i.x * a + n.x * (1 - a), c.y = i.y * l + n.y * (1 - l), c.z = i.z * h + n.z * (1 - h);
          const d = t.dot(c);
          r = Math.min(d, r), o = Math.max(d, o);
        }
    this.min = r, this.max = o;
  };
}();
const Lo = function() {
  const c = new q(), s = new q(), t = new q();
  return function(i, n, r) {
    const o = i.start, a = c, l = n.start, h = s;
    t.subVectors(o, l), c.subVectors(i.end, i.start), s.subVectors(n.end, n.start);
    const d = t.dot(h), u = h.dot(a), f = h.dot(h), E = t.dot(a), I = a.dot(a) * f - u * u;
    let m, C;
    I !== 0 ? m = (d * u - E * f) / I : m = 0, C = (d + m * u) / f, r.x = m, r.y = C;
  };
}(), Cn = function() {
  const c = new Je(), s = new q(), t = new q();
  return function(i, n, r, o) {
    Lo(i, n, c);
    let a = c.x, l = c.y;
    if (a >= 0 && a <= 1 && l >= 0 && l <= 1) {
      i.at(a, r), n.at(l, o);
      return;
    } else if (a >= 0 && a <= 1) {
      l < 0 ? n.at(0, o) : n.at(1, o), i.closestPointToPoint(o, !0, r);
      return;
    } else if (l >= 0 && l <= 1) {
      a < 0 ? i.at(0, r) : i.at(1, r), n.closestPointToPoint(r, !0, o);
      return;
    } else {
      let h;
      a < 0 ? h = i.start : h = i.end;
      let d;
      l < 0 ? d = n.start : d = n.end;
      const u = s, f = t;
      if (i.closestPointToPoint(d, !0, s), n.closestPointToPoint(h, !0, t), u.distanceToSquared(d) <= f.distanceToSquared(h)) {
        r.copy(u), o.copy(d);
        return;
      } else {
        r.copy(h), o.copy(f);
        return;
      }
    }
  };
}(), Mo = function() {
  const c = new q(), s = new q(), t = new gn(), e = new he();
  return function(n, r) {
    const { radius: o, center: a } = n, { a: l, b: h, c: d } = r;
    if (e.start = l, e.end = h, e.closestPointToPoint(a, !0, c).distanceTo(a) <= o || (e.start = l, e.end = d, e.closestPointToPoint(a, !0, c).distanceTo(a) <= o) || (e.start = h, e.end = d, e.closestPointToPoint(a, !0, c).distanceTo(a) <= o))
      return !0;
    const p = r.getPlane(t);
    if (Math.abs(p.distanceToPoint(a)) <= o) {
      const m = p.projectPoint(a, s);
      if (r.containsPoint(m))
        return !0;
    }
    return !1;
  };
}(), xo = 1e-15;
function Li(c) {
  return Math.abs(c) < xo;
}
class ee extends je {
  constructor(...s) {
    super(...s), this.isExtendedTriangle = !0, this.satAxes = new Array(4).fill().map(() => new q()), this.satBounds = new Array(4).fill().map(() => new pe()), this.points = [this.a, this.b, this.c], this.sphere = new no(), this.plane = new gn(), this.needsUpdate = !0;
  }
  intersectsSphere(s) {
    return Mo(s, this);
  }
  update() {
    const s = this.a, t = this.b, e = this.c, i = this.points, n = this.satAxes, r = this.satBounds, o = n[0], a = r[0];
    this.getNormal(o), a.setFromPoints(o, i);
    const l = n[1], h = r[1];
    l.subVectors(s, t), h.setFromPoints(l, i);
    const d = n[2], u = r[2];
    d.subVectors(t, e), u.setFromPoints(d, i);
    const f = n[3], E = r[3];
    f.subVectors(e, s), E.setFromPoints(f, i), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(o, s), this.needsUpdate = !1;
  }
}
ee.prototype.closestPointToSegment = function() {
  const c = new q(), s = new q(), t = new he();
  return function(i, n = null, r = null) {
    const { start: o, end: a } = i, l = this.points;
    let h, d = 1 / 0;
    for (let u = 0; u < 3; u++) {
      const f = (u + 1) % 3;
      t.start.copy(l[u]), t.end.copy(l[f]), Cn(t, i, c, s), h = c.distanceToSquared(s), h < d && (d = h, n && n.copy(c), r && r.copy(s));
    }
    return this.closestPointToPoint(o, c), h = o.distanceToSquared(c), h < d && (d = h, n && n.copy(c), r && r.copy(o)), this.closestPointToPoint(a, c), h = a.distanceToSquared(c), h < d && (d = h, n && n.copy(c), r && r.copy(a)), Math.sqrt(d);
  };
}();
ee.prototype.intersectsTriangle = function() {
  const c = new ee(), s = new Array(3), t = new Array(3), e = new pe(), i = new pe(), n = new q(), r = new q(), o = new q(), a = new q(), l = new q(), h = new he(), d = new he(), u = new he(), f = new q();
  function E(p, I, m) {
    const C = p.points;
    let R = 0, g = -1;
    for (let y = 0; y < 3; y++) {
      const { start: F, end: S } = h;
      F.copy(C[y]), S.copy(C[(y + 1) % 3]), h.delta(r);
      const L = Li(I.distanceToPoint(F));
      if (Li(I.normal.dot(r)) && L) {
        m.copy(h), R = 2;
        break;
      }
      const N = I.intersectLine(h, f);
      if (!N && L && f.copy(F), (N || L) && !Li(f.distanceTo(S))) {
        if (R <= 1)
          (R === 1 ? m.start : m.end).copy(f), L && (g = R);
        else if (R >= 2) {
          (g === 1 ? m.start : m.end).copy(f), R = 2;
          break;
        }
        if (R++, R === 2 && g === -1)
          break;
      }
    }
    return R;
  }
  return function(I, m = null, C = !1) {
    this.needsUpdate && this.update(), I.isExtendedTriangle ? I.needsUpdate && I.update() : (c.copy(I), c.update(), I = c);
    const R = this.plane, g = I.plane;
    if (Math.abs(R.normal.dot(g.normal)) > 1 - 1e-10) {
      const y = this.satBounds, F = this.satAxes;
      t[0] = I.a, t[1] = I.b, t[2] = I.c;
      for (let N = 0; N < 4; N++) {
        const x = y[N], k = F[N];
        if (e.setFromPoints(k, t), x.isSeparated(e))
          return !1;
      }
      const S = I.satBounds, L = I.satAxes;
      s[0] = this.a, s[1] = this.b, s[2] = this.c;
      for (let N = 0; N < 4; N++) {
        const x = S[N], k = L[N];
        if (e.setFromPoints(k, s), x.isSeparated(e))
          return !1;
      }
      for (let N = 0; N < 4; N++) {
        const x = F[N];
        for (let k = 0; k < 4; k++) {
          const w = L[k];
          if (n.crossVectors(x, w), e.setFromPoints(n, s), i.setFromPoints(n, t), e.isSeparated(i))
            return !1;
        }
      }
      return m && (C || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), m.start.set(0, 0, 0), m.end.set(0, 0, 0)), !0;
    } else {
      const y = E(this, g, d);
      if (y === 1 && I.containsPoint(d.end))
        return m && (m.start.copy(d.end), m.end.copy(d.end)), !0;
      if (y !== 2)
        return !1;
      const F = E(I, R, u);
      if (F === 1 && this.containsPoint(u.end))
        return m && (m.start.copy(u.end), m.end.copy(u.end)), !0;
      if (F !== 2)
        return !1;
      if (d.delta(o), u.delta(a), o.dot(a) < 0) {
        let P = u.start;
        u.start = u.end, u.end = P;
      }
      const S = d.start.dot(o), L = d.end.dot(o), N = u.start.dot(o), x = u.end.dot(o), k = L < N, w = S < x;
      return S !== x && N !== L && k === w ? !1 : (m && (l.subVectors(d.start, u.start), l.dot(o) > 0 ? m.start.copy(d.start) : m.start.copy(u.start), l.subVectors(d.end, u.end), l.dot(o) < 0 ? m.end.copy(d.end) : m.end.copy(u.end)), !0);
    }
  };
}();
ee.prototype.distanceToPoint = function() {
  const c = new q();
  return function(t) {
    return this.closestPointToPoint(t, c), t.distanceTo(c);
  };
}();
ee.prototype.distanceToTriangle = function() {
  const c = new q(), s = new q(), t = ["a", "b", "c"], e = new he(), i = new he();
  return function(r, o = null, a = null) {
    const l = o || a ? e : null;
    if (this.intersectsTriangle(r, l))
      return (o || a) && (o && l.getCenter(o), a && l.getCenter(a)), 0;
    let h = 1 / 0;
    for (let d = 0; d < 3; d++) {
      let u;
      const f = t[d], E = r[f];
      this.closestPointToPoint(E, c), u = E.distanceToSquared(c), u < h && (h = u, o && o.copy(c), a && a.copy(E));
      const p = this[f];
      r.closestPointToPoint(p, c), u = p.distanceToSquared(c), u < h && (h = u, o && o.copy(p), a && a.copy(c));
    }
    for (let d = 0; d < 3; d++) {
      const u = t[d], f = t[(d + 1) % 3];
      e.set(this[u], this[f]);
      for (let E = 0; E < 3; E++) {
        const p = t[E], I = t[(E + 1) % 3];
        i.set(r[p], r[I]), Cn(e, i, c, s);
        const m = c.distanceToSquared(s);
        m < h && (h = m, o && o.copy(c), a && a.copy(s));
      }
    }
    return Math.sqrt(h);
  };
}();
class Bt {
  constructor(s, t, e) {
    this.isOrientedBox = !0, this.min = new q(), this.max = new q(), this.matrix = new de(), this.invMatrix = new de(), this.points = new Array(8).fill().map(() => new q()), this.satAxes = new Array(3).fill().map(() => new q()), this.satBounds = new Array(3).fill().map(() => new pe()), this.alignedSatBounds = new Array(3).fill().map(() => new pe()), this.needsUpdate = !1, s && this.min.copy(s), t && this.max.copy(t), e && this.matrix.copy(e);
  }
  set(s, t, e) {
    this.min.copy(s), this.max.copy(t), this.matrix.copy(e), this.needsUpdate = !0;
  }
  copy(s) {
    this.min.copy(s.min), this.max.copy(s.max), this.matrix.copy(s.matrix), this.needsUpdate = !0;
  }
}
Bt.prototype.update = /* @__PURE__ */ function() {
  return function() {
    const s = this.matrix, t = this.min, e = this.max, i = this.points;
    for (let l = 0; l <= 1; l++)
      for (let h = 0; h <= 1; h++)
        for (let d = 0; d <= 1; d++) {
          const u = 1 * l | 2 * h | 4 * d, f = i[u];
          f.x = l ? e.x : t.x, f.y = h ? e.y : t.y, f.z = d ? e.z : t.z, f.applyMatrix4(s);
        }
    const n = this.satBounds, r = this.satAxes, o = i[0];
    for (let l = 0; l < 3; l++) {
      const h = r[l], d = n[l], u = 1 << l, f = i[u];
      h.subVectors(o, f), d.setFromPoints(h, i);
    }
    const a = this.alignedSatBounds;
    a[0].setFromPointsField(i, "x"), a[1].setFromPointsField(i, "y"), a[2].setFromPointsField(i, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = !1;
  };
}();
Bt.prototype.intersectsBox = function() {
  const c = new pe();
  return function(t) {
    this.needsUpdate && this.update();
    const e = t.min, i = t.max, n = this.satBounds, r = this.satAxes, o = this.alignedSatBounds;
    if (c.min = e.x, c.max = i.x, o[0].isSeparated(c) || (c.min = e.y, c.max = i.y, o[1].isSeparated(c)) || (c.min = e.z, c.max = i.z, o[2].isSeparated(c)))
      return !1;
    for (let a = 0; a < 3; a++) {
      const l = r[a], h = n[a];
      if (c.setFromBox(l, t), h.isSeparated(c))
        return !1;
    }
    return !0;
  };
}();
Bt.prototype.intersectsTriangle = function() {
  const c = new ee(), s = new Array(3), t = new pe(), e = new pe(), i = new q();
  return function(r) {
    this.needsUpdate && this.update(), r.isExtendedTriangle ? r.needsUpdate && r.update() : (c.copy(r), c.update(), r = c);
    const o = this.satBounds, a = this.satAxes;
    s[0] = r.a, s[1] = r.b, s[2] = r.c;
    for (let u = 0; u < 3; u++) {
      const f = o[u], E = a[u];
      if (t.setFromPoints(E, s), f.isSeparated(t))
        return !1;
    }
    const l = r.satBounds, h = r.satAxes, d = this.points;
    for (let u = 0; u < 3; u++) {
      const f = l[u], E = h[u];
      if (t.setFromPoints(E, d), f.isSeparated(t))
        return !1;
    }
    for (let u = 0; u < 3; u++) {
      const f = a[u];
      for (let E = 0; E < 4; E++) {
        const p = h[E];
        if (i.crossVectors(f, p), t.setFromPoints(i, s), e.setFromPoints(i, d), t.isSeparated(e))
          return !1;
      }
    }
    return !0;
  };
}();
Bt.prototype.closestPointToPoint = /* @__PURE__ */ function() {
  return function(s, t) {
    return this.needsUpdate && this.update(), t.copy(s).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), t;
  };
}();
Bt.prototype.distanceToPoint = function() {
  const c = new q();
  return function(t) {
    return this.closestPointToPoint(t, c), t.distanceTo(c);
  };
}();
Bt.prototype.distanceToBox = function() {
  const c = ["x", "y", "z"], s = new Array(12).fill().map(() => new he()), t = new Array(12).fill().map(() => new he()), e = new q(), i = new q();
  return function(r, o = 0, a = null, l = null) {
    if (this.needsUpdate && this.update(), this.intersectsBox(r))
      return (a || l) && (r.getCenter(i), this.closestPointToPoint(i, e), r.closestPointToPoint(e, i), a && a.copy(e), l && l.copy(i)), 0;
    const h = o * o, d = r.min, u = r.max, f = this.points;
    let E = 1 / 0;
    for (let I = 0; I < 8; I++) {
      const m = f[I];
      i.copy(m).clamp(d, u);
      const C = m.distanceToSquared(i);
      if (C < E && (E = C, a && a.copy(m), l && l.copy(i), C < h))
        return Math.sqrt(C);
    }
    let p = 0;
    for (let I = 0; I < 3; I++)
      for (let m = 0; m <= 1; m++)
        for (let C = 0; C <= 1; C++) {
          const R = (I + 1) % 3, g = (I + 2) % 3, y = m << R | C << g, F = 1 << I | m << R | C << g, S = f[y], L = f[F];
          s[p].set(S, L);
          const x = c[I], k = c[R], w = c[g], P = t[p], _ = P.start, v = P.end;
          _[x] = d[x], _[k] = m ? d[k] : u[k], _[w] = C ? d[w] : u[k], v[x] = u[x], v[k] = m ? d[k] : u[k], v[w] = C ? d[w] : u[k], p++;
        }
    for (let I = 0; I <= 1; I++)
      for (let m = 0; m <= 1; m++)
        for (let C = 0; C <= 1; C++) {
          i.x = I ? u.x : d.x, i.y = m ? u.y : d.y, i.z = C ? u.z : d.z, this.closestPointToPoint(i, e);
          const R = i.distanceToSquared(e);
          if (R < E && (E = R, a && a.copy(e), l && l.copy(i), R < h))
            return Math.sqrt(R);
        }
    for (let I = 0; I < 12; I++) {
      const m = s[I];
      for (let C = 0; C < 12; C++) {
        const R = t[C];
        Cn(m, R, e, i);
        const g = e.distanceToSquared(i);
        if (g < E && (E = g, a && a.copy(e), l && l.copy(i), g < h))
          return Math.sqrt(g);
      }
    }
    return Math.sqrt(E);
  };
}();
class Tn {
  constructor(s) {
    this._getNewPrimitive = s, this._primitives = [];
  }
  getPrimitive() {
    const s = this._primitives;
    return s.length === 0 ? this._getNewPrimitive() : s.pop();
  }
  releasePrimitive(s) {
    this._primitives.push(s);
  }
}
class vo extends Tn {
  constructor() {
    super(() => new ee());
  }
}
const Xt = /* @__PURE__ */ new vo();
function Vt(c, s) {
  return s[c + 15] === 65535;
}
function Yt(c, s) {
  return s[c + 6];
}
function Zt(c, s) {
  return s[c + 14];
}
function $t(c) {
  return c + 8;
}
function jt(c, s) {
  return s[c + 6];
}
function vr(c, s) {
  return s[c + 7];
}
class Do {
  constructor() {
    this.float32Array = null, this.uint16Array = null, this.uint32Array = null;
    const s = [];
    let t = null;
    this.setBuffer = (e) => {
      t && s.push(t), t = e, this.float32Array = new Float32Array(e), this.uint16Array = new Uint16Array(e), this.uint32Array = new Uint32Array(e);
    }, this.clearBuffer = () => {
      t = null, this.float32Array = null, this.uint16Array = null, this.uint32Array = null, s.length !== 0 && this.setBuffer(s.pop());
    };
  }
}
const At = new Do();
let Re, Qe;
const ve = [], Us = /* @__PURE__ */ new Tn(() => new se());
function Uo(c, s, t, e, i, n) {
  Re = Us.getPrimitive(), Qe = Us.getPrimitive(), ve.push(Re, Qe), At.setBuffer(c._roots[s]);
  const r = qi(0, c.geometry, t, e, i, n);
  At.clearBuffer(), Us.releasePrimitive(Re), Us.releasePrimitive(Qe), ve.pop(), ve.pop();
  const o = ve.length;
  return o > 0 && (Qe = ve[o - 1], Re = ve[o - 2]), r;
}
function qi(c, s, t, e, i = null, n = 0, r = 0) {
  const { float32Array: o, uint16Array: a, uint32Array: l } = At;
  let h = c * 2;
  if (Vt(h, a)) {
    const u = Yt(c, l), f = Zt(h, a);
    return wt(c, o, Re), e(u, f, !1, r, n + c, Re);
  } else {
    let x = function(w) {
      const { uint16Array: P, uint32Array: _ } = At;
      let v = w * 2;
      for (; !Vt(v, P); )
        w = $t(w), v = w * 2;
      return Yt(w, _);
    }, k = function(w) {
      const { uint16Array: P, uint32Array: _ } = At;
      let v = w * 2;
      for (; !Vt(v, P); )
        w = jt(w, _), v = w * 2;
      return Yt(w, _) + Zt(v, P);
    };
    const u = $t(c), f = jt(c, l);
    let E = u, p = f, I, m, C, R;
    if (i && (C = Re, R = Qe, wt(E, o, C), wt(p, o, R), I = i(C), m = i(R), m < I)) {
      E = f, p = u;
      const w = I;
      I = m, m = w, C = R;
    }
    C || (C = Re, wt(E, o, C));
    const g = Vt(E * 2, a), y = t(C, g, I, r + 1, n + E);
    let F;
    if (y === xn) {
      const w = x(E), _ = k(E) - w;
      F = e(w, _, !0, r + 1, n + E, C);
    } else
      F = y && qi(
        E,
        s,
        t,
        e,
        i,
        n,
        r + 1
      );
    if (F)
      return !0;
    R = Qe, wt(p, o, R);
    const S = Vt(p * 2, a), L = t(R, S, m, r + 1, n + p);
    let N;
    if (L === xn) {
      const w = x(p), _ = k(p) - w;
      N = e(w, _, !0, r + 1, n + p, R);
    } else
      N = L && qi(
        p,
        s,
        t,
        e,
        i,
        n,
        r + 1
      );
    return !!N;
  }
}
const as = /* @__PURE__ */ new q(), Mi = /* @__PURE__ */ new q();
function Bo(c, s, t = {}, e = 0, i = 1 / 0) {
  const n = e * e, r = i * i;
  let o = 1 / 0, a = null;
  if (c.shapecast(
    {
      boundsTraverseOrder: (h) => (as.copy(s).clamp(h.min, h.max), as.distanceToSquared(s)),
      intersectsBounds: (h, d, u) => u < o && u < r,
      intersectsTriangle: (h, d) => {
        h.closestPointToPoint(s, as);
        const u = s.distanceToSquared(as);
        return u < o && (Mi.copy(as), o = u, a = d), u < n;
      }
    }
  ), o === 1 / 0)
    return null;
  const l = Math.sqrt(o);
  return t.point ? t.point.copy(Mi) : t.point = Mi.clone(), t.distance = l, t.faceIndex = a, t;
}
const De = /* @__PURE__ */ new q(), Ue = /* @__PURE__ */ new q(), Be = /* @__PURE__ */ new q(), Bs = /* @__PURE__ */ new Je(), zs = /* @__PURE__ */ new Je(), ks = /* @__PURE__ */ new Je(), zn = /* @__PURE__ */ new q(), kn = /* @__PURE__ */ new q(), Vn = /* @__PURE__ */ new q(), Vs = /* @__PURE__ */ new q();
function zo(c, s, t, e, i, n) {
  let r;
  return n === ro ? r = c.intersectTriangle(e, t, s, !0, i) : r = c.intersectTriangle(s, t, e, n !== br, i), r === null ? null : {
    distance: c.origin.distanceTo(i),
    point: i.clone()
  };
}
function ko(c, s, t, e, i, n, r, o, a) {
  De.fromBufferAttribute(s, n), Ue.fromBufferAttribute(s, r), Be.fromBufferAttribute(s, o);
  const l = zo(c, De, Ue, Be, Vs, a);
  if (l) {
    e && (Bs.fromBufferAttribute(e, n), zs.fromBufferAttribute(e, r), ks.fromBufferAttribute(e, o), l.uv = je.getInterpolation(Vs, De, Ue, Be, Bs, zs, ks, new Je())), i && (Bs.fromBufferAttribute(i, n), zs.fromBufferAttribute(i, r), ks.fromBufferAttribute(i, o), l.uv1 = je.getInterpolation(Vs, De, Ue, Be, Bs, zs, ks, new Je())), t && (zn.fromBufferAttribute(t, n), kn.fromBufferAttribute(t, r), Vn.fromBufferAttribute(t, o), l.normal = je.getInterpolation(Vs, De, Ue, Be, zn, kn, Vn, new q()), l.normal.dot(c.direction) > 0 && l.normal.multiplyScalar(-1));
    const h = {
      a: n,
      b: r,
      c: o,
      normal: new q(),
      materialIndex: 0
    };
    je.getNormal(De, Ue, Be, h.normal), l.face = h, l.faceIndex = n;
  }
  return l;
}
function Fi(c, s, t, e, i) {
  const n = e * 3;
  let r = n + 0, o = n + 1, a = n + 2;
  const l = c.index;
  c.index && (r = l.getX(r), o = l.getX(o), a = l.getX(a));
  const { position: h, normal: d, uv: u, uv1: f } = c.attributes, E = ko(t, h, d, u, f, r, o, a, s);
  return E ? (E.faceIndex = e, i && i.push(E), E) : null;
}
function Pt(c, s, t, e) {
  const i = c.a, n = c.b, r = c.c;
  let o = s, a = s + 1, l = s + 2;
  t && (o = t.getX(o), a = t.getX(a), l = t.getX(l)), i.x = e.getX(o), i.y = e.getY(o), i.z = e.getZ(o), n.x = e.getX(a), n.y = e.getY(a), n.z = e.getZ(a), r.x = e.getX(l), r.y = e.getY(l), r.z = e.getZ(l);
}
function Vo(c, s, t, e, i, n) {
  const { geometry: r, _indirectBuffer: o } = c;
  for (let a = e, l = e + i; a < l; a++)
    Fi(r, s, t, a, n);
}
function Yo(c, s, t, e, i) {
  const { geometry: n, _indirectBuffer: r } = c;
  let o = 1 / 0, a = null;
  for (let l = e, h = e + i; l < h; l++) {
    let d;
    d = Fi(n, s, t, l), d && d.distance < o && (a = d, o = d.distance);
  }
  return a;
}
function Go(c, s, t, e, i, n, r) {
  const { geometry: o } = t, { index: a } = o, l = o.attributes.position;
  for (let h = c, d = s + c; h < d; h++) {
    let u;
    if (u = h, Pt(r, u * 3, a, l), r.needsUpdate = !0, e(r, u, i, n))
      return !0;
  }
  return !1;
}
function Ho(c, s = null) {
  s && Array.isArray(s) && (s = new Set(s));
  const t = c.geometry, e = t.index ? t.index.array : null, i = t.attributes.position;
  let n, r, o, a, l = 0;
  const h = c._roots;
  for (let u = 0, f = h.length; u < f; u++)
    n = h[u], r = new Uint32Array(n), o = new Uint16Array(n), a = new Float32Array(n), d(0, l), l += n.byteLength;
  function d(u, f, E = !1) {
    const p = u * 2;
    if (o[p + 15] === wi) {
      const m = r[u + 6], C = o[p + 14];
      let R = 1 / 0, g = 1 / 0, y = 1 / 0, F = -1 / 0, S = -1 / 0, L = -1 / 0;
      for (let N = 3 * m, x = 3 * (m + C); N < x; N++) {
        let k = e[N];
        const w = i.getX(k), P = i.getY(k), _ = i.getZ(k);
        w < R && (R = w), w > F && (F = w), P < g && (g = P), P > S && (S = P), _ < y && (y = _), _ > L && (L = _);
      }
      return a[u + 0] !== R || a[u + 1] !== g || a[u + 2] !== y || a[u + 3] !== F || a[u + 4] !== S || a[u + 5] !== L ? (a[u + 0] = R, a[u + 1] = g, a[u + 2] = y, a[u + 3] = F, a[u + 4] = S, a[u + 5] = L, !0) : !1;
    } else {
      const m = u + 8, C = r[u + 6], R = m + f, g = C + f;
      let y = E, F = !1, S = !1;
      s ? y || (F = s.has(R), S = s.has(g), y = !F && !S) : (F = !0, S = !0);
      const L = y || F, N = y || S;
      let x = !1;
      L && (x = d(m, f, y));
      let k = !1;
      N && (k = d(C, f, y));
      const w = x || k;
      if (w)
        for (let P = 0; P < 3; P++) {
          const _ = m + P, v = C + P, Q = a[_], V = a[_ + 3], et = a[v], H = a[v + 3];
          a[u + P] = Q < et ? Q : et, a[u + P + 3] = V > H ? V : H;
        }
      return w;
    }
  }
}
const Yn = /* @__PURE__ */ new se();
function we(c, s, t, e) {
  return wt(c, s, Yn), t.intersectBox(Yn, e);
}
function Wo(c, s, t, e, i, n) {
  const { geometry: r, _indirectBuffer: o } = c;
  for (let a = e, l = e + i; a < l; a++) {
    let h = o ? o[a] : a;
    Fi(r, s, t, h, n);
  }
}
function Xo(c, s, t, e, i) {
  const { geometry: n, _indirectBuffer: r } = c;
  let o = 1 / 0, a = null;
  for (let l = e, h = e + i; l < h; l++) {
    let d;
    d = Fi(n, s, t, r ? r[l] : l), d && d.distance < o && (a = d, o = d.distance);
  }
  return a;
}
function Zo(c, s, t, e, i, n, r) {
  const { geometry: o } = t, { index: a } = o, l = o.attributes.position;
  for (let h = c, d = s + c; h < d; h++) {
    let u;
    if (u = t.resolveTriangleIndex(h), Pt(r, u * 3, a, l), r.needsUpdate = !0, e(r, u, i, n))
      return !0;
  }
  return !1;
}
const Gn = /* @__PURE__ */ new q();
function $o(c, s, t, e, i) {
  At.setBuffer(c._roots[s]), Ki(0, c, t, e, i), At.clearBuffer();
}
function Ki(c, s, t, e, i) {
  const { float32Array: n, uint16Array: r, uint32Array: o } = At, a = c * 2;
  if (Vt(a, r)) {
    const h = Yt(c, o), d = Zt(a, r);
    Vo(s, t, e, h, d, i);
  } else {
    const h = $t(c);
    we(h, n, e, Gn) && Ki(h, s, t, e, i);
    const d = jt(c, o);
    we(d, n, e, Gn) && Ki(d, s, t, e, i);
  }
}
const Hn = /* @__PURE__ */ new q(), jo = ["x", "y", "z"];
function Qo(c, s, t, e) {
  At.setBuffer(c._roots[s]);
  const i = Ji(0, c, t, e);
  return At.clearBuffer(), i;
}
function Ji(c, s, t, e) {
  const { float32Array: i, uint16Array: n, uint32Array: r } = At;
  let o = c * 2;
  if (Vt(o, n)) {
    const l = Yt(c, r), h = Zt(o, n);
    return Yo(s, t, e, l, h);
  } else {
    const l = vr(c, r), h = jo[l], u = e.direction[h] >= 0;
    let f, E;
    u ? (f = $t(c), E = jt(c, r)) : (f = jt(c, r), E = $t(c));
    const I = we(f, i, e, Hn) ? Ji(f, s, t, e) : null;
    if (I) {
      const R = I.point[h];
      if (u ? R <= i[E + l] : (
        // min bounding data
        R >= i[E + l + 3]
      ))
        return I;
    }
    const C = we(E, i, e, Hn) ? Ji(E, s, t, e) : null;
    return I && C ? I.distance <= C.distance ? I : C : I || C || null;
  }
}
const Ys = /* @__PURE__ */ new se(), ze = /* @__PURE__ */ new ee(), ke = /* @__PURE__ */ new ee(), cs = /* @__PURE__ */ new de(), Wn = /* @__PURE__ */ new Bt(), Gs = /* @__PURE__ */ new Bt();
function qo(c, s, t, e) {
  At.setBuffer(c._roots[s]);
  const i = tn(0, c, t, e);
  return At.clearBuffer(), i;
}
function tn(c, s, t, e, i = null) {
  const { float32Array: n, uint16Array: r, uint32Array: o } = At;
  let a = c * 2;
  if (i === null && (t.boundingBox || t.computeBoundingBox(), Wn.set(t.boundingBox.min, t.boundingBox.max, e), i = Wn), Vt(a, r)) {
    const h = s.geometry, d = h.index, u = h.attributes.position, f = t.index, E = t.attributes.position, p = Yt(c, o), I = Zt(a, r);
    if (cs.copy(e).invert(), t.boundsTree)
      return wt(c, n, Gs), Gs.matrix.copy(cs), Gs.needsUpdate = !0, t.boundsTree.shapecast({
        intersectsBounds: (C) => Gs.intersectsBox(C),
        intersectsTriangle: (C) => {
          C.a.applyMatrix4(e), C.b.applyMatrix4(e), C.c.applyMatrix4(e), C.needsUpdate = !0;
          for (let R = p * 3, g = (I + p) * 3; R < g; R += 3)
            if (Pt(ke, R, d, u), ke.needsUpdate = !0, C.intersectsTriangle(ke))
              return !0;
          return !1;
        }
      });
    for (let m = p * 3, C = (I + p) * 3; m < C; m += 3) {
      Pt(ze, m, d, u), ze.a.applyMatrix4(cs), ze.b.applyMatrix4(cs), ze.c.applyMatrix4(cs), ze.needsUpdate = !0;
      for (let R = 0, g = f.count; R < g; R += 3)
        if (Pt(ke, R, f, E), ke.needsUpdate = !0, ze.intersectsTriangle(ke))
          return !0;
    }
  } else {
    const h = c + 8, d = o[c + 6];
    return wt(h, n, Ys), !!(i.intersectsBox(Ys) && tn(h, s, t, e, i) || (wt(d, n, Ys), i.intersectsBox(Ys) && tn(d, s, t, e, i)));
  }
}
const Hs = /* @__PURE__ */ new de(), xi = /* @__PURE__ */ new Bt(), ls = /* @__PURE__ */ new Bt(), Ko = /* @__PURE__ */ new q(), Jo = /* @__PURE__ */ new q(), ta = /* @__PURE__ */ new q(), ea = /* @__PURE__ */ new q();
function sa(c, s, t, e = {}, i = {}, n = 0, r = 1 / 0) {
  s.boundingBox || s.computeBoundingBox(), xi.set(s.boundingBox.min, s.boundingBox.max, t), xi.needsUpdate = !0;
  const o = c.geometry, a = o.attributes.position, l = o.index, h = s.attributes.position, d = s.index, u = Xt.getPrimitive(), f = Xt.getPrimitive();
  let E = Ko, p = Jo, I = null, m = null;
  i && (I = ta, m = ea);
  let C = 1 / 0, R = null, g = null;
  return Hs.copy(t).invert(), ls.matrix.copy(Hs), c.shapecast(
    {
      boundsTraverseOrder: (y) => xi.distanceToBox(y),
      intersectsBounds: (y, F, S) => S < C && S < r ? (F && (ls.min.copy(y.min), ls.max.copy(y.max), ls.needsUpdate = !0), !0) : !1,
      intersectsRange: (y, F) => {
        if (s.boundsTree)
          return s.boundsTree.shapecast({
            boundsTraverseOrder: (L) => ls.distanceToBox(L),
            intersectsBounds: (L, N, x) => x < C && x < r,
            intersectsRange: (L, N) => {
              for (let x = L, k = L + N; x < k; x++) {
                Pt(f, 3 * x, d, h), f.a.applyMatrix4(t), f.b.applyMatrix4(t), f.c.applyMatrix4(t), f.needsUpdate = !0;
                for (let w = y, P = y + F; w < P; w++) {
                  Pt(u, 3 * w, l, a), u.needsUpdate = !0;
                  const _ = u.distanceToTriangle(f, E, I);
                  if (_ < C && (p.copy(E), m && m.copy(I), C = _, R = w, g = x), _ < n)
                    return !0;
                }
              }
            }
          });
        {
          const S = es(s);
          for (let L = 0, N = S; L < N; L++) {
            Pt(f, 3 * L, d, h), f.a.applyMatrix4(t), f.b.applyMatrix4(t), f.c.applyMatrix4(t), f.needsUpdate = !0;
            for (let x = y, k = y + F; x < k; x++) {
              Pt(u, 3 * x, l, a), u.needsUpdate = !0;
              const w = u.distanceToTriangle(f, E, I);
              if (w < C && (p.copy(E), m && m.copy(I), C = w, R = x, g = L), w < n)
                return !0;
            }
          }
        }
      }
    }
  ), Xt.releasePrimitive(u), Xt.releasePrimitive(f), C === 1 / 0 ? null : (e.point ? e.point.copy(p) : e.point = p.clone(), e.distance = C, e.faceIndex = R, i && (i.point ? i.point.copy(m) : i.point = m.clone(), i.point.applyMatrix4(Hs), p.applyMatrix4(Hs), i.distance = p.sub(i.point).length(), i.faceIndex = g), e);
}
function ia(c, s = null) {
  s && Array.isArray(s) && (s = new Set(s));
  const t = c.geometry, e = t.index ? t.index.array : null, i = t.attributes.position;
  let n, r, o, a, l = 0;
  const h = c._roots;
  for (let u = 0, f = h.length; u < f; u++)
    n = h[u], r = new Uint32Array(n), o = new Uint16Array(n), a = new Float32Array(n), d(0, l), l += n.byteLength;
  function d(u, f, E = !1) {
    const p = u * 2;
    if (o[p + 15] === wi) {
      const m = r[u + 6], C = o[p + 14];
      let R = 1 / 0, g = 1 / 0, y = 1 / 0, F = -1 / 0, S = -1 / 0, L = -1 / 0;
      for (let N = m, x = m + C; N < x; N++) {
        const k = 3 * c.resolveTriangleIndex(N);
        for (let w = 0; w < 3; w++) {
          let P = k + w;
          P = e ? e[P] : P;
          const _ = i.getX(P), v = i.getY(P), Q = i.getZ(P);
          _ < R && (R = _), _ > F && (F = _), v < g && (g = v), v > S && (S = v), Q < y && (y = Q), Q > L && (L = Q);
        }
      }
      return a[u + 0] !== R || a[u + 1] !== g || a[u + 2] !== y || a[u + 3] !== F || a[u + 4] !== S || a[u + 5] !== L ? (a[u + 0] = R, a[u + 1] = g, a[u + 2] = y, a[u + 3] = F, a[u + 4] = S, a[u + 5] = L, !0) : !1;
    } else {
      const m = u + 8, C = r[u + 6], R = m + f, g = C + f;
      let y = E, F = !1, S = !1;
      s ? y || (F = s.has(R), S = s.has(g), y = !F && !S) : (F = !0, S = !0);
      const L = y || F, N = y || S;
      let x = !1;
      L && (x = d(m, f, y));
      let k = !1;
      N && (k = d(C, f, y));
      const w = x || k;
      if (w)
        for (let P = 0; P < 3; P++) {
          const _ = m + P, v = C + P, Q = a[_], V = a[_ + 3], et = a[v], H = a[v + 3];
          a[u + P] = Q < et ? Q : et, a[u + P + 3] = V > H ? V : H;
        }
      return w;
    }
  }
}
const Xn = /* @__PURE__ */ new q();
function na(c, s, t, e, i) {
  At.setBuffer(c._roots[s]), en(0, c, t, e, i), At.clearBuffer();
}
function en(c, s, t, e, i) {
  const { float32Array: n, uint16Array: r, uint32Array: o } = At, a = c * 2;
  if (Vt(a, r)) {
    const h = Yt(c, o), d = Zt(a, r);
    Wo(s, t, e, h, d, i);
  } else {
    const h = $t(c);
    we(h, n, e, Xn) && en(h, s, t, e, i);
    const d = jt(c, o);
    we(d, n, e, Xn) && en(d, s, t, e, i);
  }
}
const Zn = /* @__PURE__ */ new q(), ra = ["x", "y", "z"];
function oa(c, s, t, e) {
  At.setBuffer(c._roots[s]);
  const i = sn(0, c, t, e);
  return At.clearBuffer(), i;
}
function sn(c, s, t, e) {
  const { float32Array: i, uint16Array: n, uint32Array: r } = At;
  let o = c * 2;
  if (Vt(o, n)) {
    const l = Yt(c, r), h = Zt(o, n);
    return Xo(s, t, e, l, h);
  } else {
    const l = vr(c, r), h = ra[l], u = e.direction[h] >= 0;
    let f, E;
    u ? (f = $t(c), E = jt(c, r)) : (f = jt(c, r), E = $t(c));
    const I = we(f, i, e, Zn) ? sn(f, s, t, e) : null;
    if (I) {
      const R = I.point[h];
      if (u ? R <= i[E + l] : (
        // min bounding data
        R >= i[E + l + 3]
      ))
        return I;
    }
    const C = we(E, i, e, Zn) ? sn(E, s, t, e) : null;
    return I && C ? I.distance <= C.distance ? I : C : I || C || null;
  }
}
const Ws = /* @__PURE__ */ new se(), Ve = /* @__PURE__ */ new ee(), Ye = /* @__PURE__ */ new ee(), hs = /* @__PURE__ */ new de(), $n = /* @__PURE__ */ new Bt(), Xs = /* @__PURE__ */ new Bt();
function aa(c, s, t, e) {
  At.setBuffer(c._roots[s]);
  const i = nn(0, c, t, e);
  return At.clearBuffer(), i;
}
function nn(c, s, t, e, i = null) {
  const { float32Array: n, uint16Array: r, uint32Array: o } = At;
  let a = c * 2;
  if (i === null && (t.boundingBox || t.computeBoundingBox(), $n.set(t.boundingBox.min, t.boundingBox.max, e), i = $n), Vt(a, r)) {
    const h = s.geometry, d = h.index, u = h.attributes.position, f = t.index, E = t.attributes.position, p = Yt(c, o), I = Zt(a, r);
    if (hs.copy(e).invert(), t.boundsTree)
      return wt(c, n, Xs), Xs.matrix.copy(hs), Xs.needsUpdate = !0, t.boundsTree.shapecast({
        intersectsBounds: (C) => Xs.intersectsBox(C),
        intersectsTriangle: (C) => {
          C.a.applyMatrix4(e), C.b.applyMatrix4(e), C.c.applyMatrix4(e), C.needsUpdate = !0;
          for (let R = p, g = I + p; R < g; R++)
            if (Pt(Ye, 3 * s.resolveTriangleIndex(R), d, u), Ye.needsUpdate = !0, C.intersectsTriangle(Ye))
              return !0;
          return !1;
        }
      });
    for (let m = p, C = I + p; m < C; m++) {
      const R = s.resolveTriangleIndex(m);
      Pt(Ve, 3 * R, d, u), Ve.a.applyMatrix4(hs), Ve.b.applyMatrix4(hs), Ve.c.applyMatrix4(hs), Ve.needsUpdate = !0;
      for (let g = 0, y = f.count; g < y; g += 3)
        if (Pt(Ye, g, f, E), Ye.needsUpdate = !0, Ve.intersectsTriangle(Ye))
          return !0;
    }
  } else {
    const h = c + 8, d = o[c + 6];
    return wt(h, n, Ws), !!(i.intersectsBox(Ws) && nn(h, s, t, e, i) || (wt(d, n, Ws), i.intersectsBox(Ws) && nn(d, s, t, e, i)));
  }
}
const Zs = /* @__PURE__ */ new de(), vi = /* @__PURE__ */ new Bt(), ds = /* @__PURE__ */ new Bt(), ca = /* @__PURE__ */ new q(), la = /* @__PURE__ */ new q(), ha = /* @__PURE__ */ new q(), da = /* @__PURE__ */ new q();
function ua(c, s, t, e = {}, i = {}, n = 0, r = 1 / 0) {
  s.boundingBox || s.computeBoundingBox(), vi.set(s.boundingBox.min, s.boundingBox.max, t), vi.needsUpdate = !0;
  const o = c.geometry, a = o.attributes.position, l = o.index, h = s.attributes.position, d = s.index, u = Xt.getPrimitive(), f = Xt.getPrimitive();
  let E = ca, p = la, I = null, m = null;
  i && (I = ha, m = da);
  let C = 1 / 0, R = null, g = null;
  return Zs.copy(t).invert(), ds.matrix.copy(Zs), c.shapecast(
    {
      boundsTraverseOrder: (y) => vi.distanceToBox(y),
      intersectsBounds: (y, F, S) => S < C && S < r ? (F && (ds.min.copy(y.min), ds.max.copy(y.max), ds.needsUpdate = !0), !0) : !1,
      intersectsRange: (y, F) => {
        if (s.boundsTree) {
          const S = s.boundsTree;
          return S.shapecast({
            boundsTraverseOrder: (L) => ds.distanceToBox(L),
            intersectsBounds: (L, N, x) => x < C && x < r,
            intersectsRange: (L, N) => {
              for (let x = L, k = L + N; x < k; x++) {
                const w = S.resolveTriangleIndex(x);
                Pt(f, 3 * w, d, h), f.a.applyMatrix4(t), f.b.applyMatrix4(t), f.c.applyMatrix4(t), f.needsUpdate = !0;
                for (let P = y, _ = y + F; P < _; P++) {
                  const v = c.resolveTriangleIndex(P);
                  Pt(u, 3 * v, l, a), u.needsUpdate = !0;
                  const Q = u.distanceToTriangle(f, E, I);
                  if (Q < C && (p.copy(E), m && m.copy(I), C = Q, R = P, g = x), Q < n)
                    return !0;
                }
              }
            }
          });
        } else {
          const S = es(s);
          for (let L = 0, N = S; L < N; L++) {
            Pt(f, 3 * L, d, h), f.a.applyMatrix4(t), f.b.applyMatrix4(t), f.c.applyMatrix4(t), f.needsUpdate = !0;
            for (let x = y, k = y + F; x < k; x++) {
              const w = c.resolveTriangleIndex(x);
              Pt(u, 3 * w, l, a), u.needsUpdate = !0;
              const P = u.distanceToTriangle(f, E, I);
              if (P < C && (p.copy(E), m && m.copy(I), C = P, R = x, g = L), P < n)
                return !0;
            }
          }
        }
      }
    }
  ), Xt.releasePrimitive(u), Xt.releasePrimitive(f), C === 1 / 0 ? null : (e.point ? e.point.copy(p) : e.point = p.clone(), e.distance = C, e.faceIndex = R, i && (i.point ? i.point.copy(m) : i.point = m.clone(), i.point.applyMatrix4(Zs), p.applyMatrix4(Zs), i.distance = p.sub(i.point).length(), i.faceIndex = g), e);
}
function fa() {
  return typeof SharedArrayBuffer < "u";
}
const Rs = new At.constructor(), li = new At.constructor(), _e = new Tn(() => new se()), Ge = new se(), He = new se(), Di = new se(), Ui = new se();
let Bi = !1;
function pa(c, s, t, e) {
  if (Bi)
    throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
  Bi = !0;
  const i = c._roots, n = s._roots;
  let r, o = 0, a = 0;
  const l = new de().copy(t).invert();
  for (let h = 0, d = i.length; h < d; h++) {
    Rs.setBuffer(i[h]), a = 0;
    const u = _e.getPrimitive();
    wt(0, Rs.float32Array, u), u.applyMatrix4(l);
    for (let f = 0, E = n.length; f < E && (li.setBuffer(n[h]), r = Qt(
      0,
      0,
      t,
      l,
      e,
      o,
      a,
      0,
      0,
      u
    ), li.clearBuffer(), a += n[f].length, !r); f++)
      ;
    if (_e.releasePrimitive(u), Rs.clearBuffer(), o += i[h].length, r)
      break;
  }
  return Bi = !1, r;
}
function Qt(c, s, t, e, i, n = 0, r = 0, o = 0, a = 0, l = null, h = !1) {
  let d, u;
  h ? (d = li, u = Rs) : (d = Rs, u = li);
  const f = d.float32Array, E = d.uint32Array, p = d.uint16Array, I = u.float32Array, m = u.uint32Array, C = u.uint16Array, R = c * 2, g = s * 2, y = Vt(R, p), F = Vt(g, C);
  let S = !1;
  if (F && y)
    h ? S = i(
      Yt(s, m),
      Zt(s * 2, C),
      Yt(c, E),
      Zt(c * 2, p),
      a,
      r + s,
      o,
      n + c
    ) : S = i(
      Yt(c, E),
      Zt(c * 2, p),
      Yt(s, m),
      Zt(s * 2, C),
      o,
      n + c,
      a,
      r + s
    );
  else if (F) {
    const L = _e.getPrimitive();
    wt(s, I, L), L.applyMatrix4(t);
    const N = $t(c), x = jt(c, E);
    wt(N, f, Ge), wt(x, f, He);
    const k = L.intersectsBox(Ge), w = L.intersectsBox(He);
    S = k && Qt(
      s,
      N,
      e,
      t,
      i,
      r,
      n,
      a,
      o + 1,
      L,
      !h
    ) || w && Qt(
      s,
      x,
      e,
      t,
      i,
      r,
      n,
      a,
      o + 1,
      L,
      !h
    ), _e.releasePrimitive(L);
  } else {
    const L = $t(s), N = jt(s, m);
    wt(L, I, Di), wt(N, I, Ui);
    const x = l.intersectsBox(Di), k = l.intersectsBox(Ui);
    if (x && k)
      S = Qt(
        c,
        L,
        t,
        e,
        i,
        n,
        r,
        o,
        a + 1,
        l,
        h
      ) || Qt(
        c,
        N,
        t,
        e,
        i,
        n,
        r,
        o,
        a + 1,
        l,
        h
      );
    else if (x)
      if (y)
        S = Qt(
          c,
          L,
          t,
          e,
          i,
          n,
          r,
          o,
          a + 1,
          l,
          h
        );
      else {
        const w = _e.getPrimitive();
        w.copy(Di).applyMatrix4(t);
        const P = $t(c), _ = jt(c, E);
        wt(P, f, Ge), wt(_, f, He);
        const v = w.intersectsBox(Ge), Q = w.intersectsBox(He);
        S = v && Qt(
          L,
          P,
          e,
          t,
          i,
          r,
          n,
          a,
          o + 1,
          w,
          !h
        ) || Q && Qt(
          L,
          _,
          e,
          t,
          i,
          r,
          n,
          a,
          o + 1,
          w,
          !h
        ), _e.releasePrimitive(w);
      }
    else if (k)
      if (y)
        S = Qt(
          c,
          N,
          t,
          e,
          i,
          n,
          r,
          o,
          a + 1,
          l,
          h
        );
      else {
        const w = _e.getPrimitive();
        w.copy(Ui).applyMatrix4(t);
        const P = $t(c), _ = jt(c, E);
        wt(P, f, Ge), wt(_, f, He);
        const v = w.intersectsBox(Ge), Q = w.intersectsBox(He);
        S = v && Qt(
          N,
          P,
          e,
          t,
          i,
          r,
          n,
          a,
          o + 1,
          w,
          !h
        ) || Q && Qt(
          N,
          _,
          e,
          t,
          i,
          r,
          n,
          a,
          o + 1,
          w,
          !h
        ), _e.releasePrimitive(w);
      }
  }
  return S;
}
const $s = /* @__PURE__ */ new Bt(), jn = /* @__PURE__ */ new se();
class _n {
  static serialize(s, t = {}) {
    t = {
      cloneBuffers: !0,
      ...t
    };
    const e = s.geometry, i = s._roots, n = s._indirectBuffer, r = e.getIndex();
    let o;
    return t.cloneBuffers ? o = {
      roots: i.map((a) => a.slice()),
      index: r.array.slice(),
      indirectBuffer: n ? n.slice() : null
    } : o = {
      roots: i,
      index: r.array,
      indirectBuffer: n
    }, o;
  }
  static deserialize(s, t, e = {}) {
    e = {
      setIndex: !0,
      indirect: !!s.indirectBuffer,
      ...e
    };
    const { index: i, roots: n, indirectBuffer: r } = s, o = new _n(t, { ...e, [bi]: !0 });
    if (o._roots = n, o._indirectBuffer = r || null, e.setIndex) {
      const a = t.getIndex();
      if (a === null) {
        const l = new Nr(s.index, 1, !1);
        t.setIndex(l);
      } else
        a.array !== i && (a.array.set(i), a.needsUpdate = !0);
    }
    return o;
  }
  get indirect() {
    return !!this._indirectBuffer;
  }
  constructor(s, t = {}) {
    if (s.isBufferGeometry) {
      if (s.index && s.index.isInterleavedBufferAttribute)
        throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    } else
      throw new Error("MeshBVH: Only BufferGeometries are supported.");
    if (t = Object.assign({
      strategy: Lr,
      maxDepth: 40,
      maxLeafTris: 10,
      verbose: !0,
      useSharedArrayBuffer: !1,
      setBoundingBox: !0,
      onProgress: null,
      indirect: !1,
      // undocumented options
      // Whether to skip generating the tree. Used for deserialization.
      [bi]: !1
    }, t), t.useSharedArrayBuffer && !fa())
      throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    this.geometry = s, this._roots = null, this._indirectBuffer = null, t[bi] || (Po(this, t), !s.boundingBox && t.setBoundingBox && (s.boundingBox = this.getBoundingBox(new se())));
    const { _indirectBuffer: e } = this;
    this.resolveTriangleIndex = t.indirect ? (i) => e[i] : (i) => i;
  }
  refit(s = null) {
    return (this.indirect ? ia : Ho)(this, s);
  }
  traverse(s, t = 0) {
    const e = this._roots[t], i = new Uint32Array(e), n = new Uint16Array(e);
    r(0);
    function r(o, a = 0) {
      const l = o * 2, h = n[l + 15] === wi;
      if (h) {
        const d = i[o + 6], u = n[l + 14];
        s(a, h, new Float32Array(e, o * 4, 6), d, u);
      } else {
        const d = o + ri / 4, u = i[o + 6], f = i[o + 7];
        s(a, h, new Float32Array(e, o * 4, 6), f) || (r(d, a + 1), r(u, a + 1));
      }
    }
  }
  /* Core Cast Functions */
  raycast(s, t = Pn) {
    const e = this._roots, i = this.geometry, n = [], r = t.isMaterial, o = Array.isArray(t), a = i.groups, l = r ? t.side : t, h = this.indirect ? na : $o;
    for (let d = 0, u = e.length; d < u; d++) {
      const f = o ? t[a[d].materialIndex].side : l, E = n.length;
      if (h(this, d, f, s, n), o) {
        const p = a[d].materialIndex;
        for (let I = E, m = n.length; I < m; I++)
          n[I].face.materialIndex = p;
      }
    }
    return n;
  }
  raycastFirst(s, t = Pn) {
    const e = this._roots, i = this.geometry, n = t.isMaterial, r = Array.isArray(t);
    let o = null;
    const a = i.groups, l = n ? t.side : t, h = this.indirect ? oa : Qo;
    for (let d = 0, u = e.length; d < u; d++) {
      const f = r ? t[a[d].materialIndex].side : l, E = h(this, d, f, s);
      E != null && (o == null || E.distance < o.distance) && (o = E, r && (E.face.materialIndex = a[d].materialIndex));
    }
    return o;
  }
  intersectsGeometry(s, t) {
    let e = !1;
    const i = this._roots, n = this.indirect ? aa : qo;
    for (let r = 0, o = i.length; r < o && (e = n(this, r, s, t), !e); r++)
      ;
    return e;
  }
  shapecast(s) {
    const t = Xt.getPrimitive(), e = this.indirect ? Zo : Go;
    let {
      boundsTraverseOrder: i,
      intersectsBounds: n,
      intersectsRange: r,
      intersectsTriangle: o
    } = s;
    if (r && o) {
      const d = r;
      r = (u, f, E, p, I) => d(u, f, E, p, I) ? !0 : e(u, f, this, o, E, p, t);
    } else
      r || (o ? r = (d, u, f, E) => e(d, u, this, o, f, E, t) : r = (d, u, f) => f);
    let a = !1, l = 0;
    const h = this._roots;
    for (let d = 0, u = h.length; d < u; d++) {
      const f = h[d];
      if (a = Uo(this, d, n, r, i, l), a)
        break;
      l += f.byteLength;
    }
    return Xt.releasePrimitive(t), a;
  }
  bvhcast(s, t, e) {
    let {
      intersectsRanges: i,
      intersectsTriangles: n
    } = e;
    const r = Xt.getPrimitive(), o = this.geometry.index, a = this.geometry.attributes.position, l = this.indirect ? (E) => {
      const p = this.resolveTriangleIndex(E);
      Pt(r, p * 3, o, a);
    } : (E) => {
      Pt(r, E * 3, o, a);
    }, h = Xt.getPrimitive(), d = s.geometry.index, u = s.geometry.attributes.position, f = s.indirect ? (E) => {
      const p = s.resolveTriangleIndex(E);
      Pt(h, p * 3, d, u);
    } : (E) => {
      Pt(h, E * 3, d, u);
    };
    if (n) {
      const E = (p, I, m, C, R, g, y, F) => {
        for (let S = m, L = m + C; S < L; S++) {
          f(S), h.a.applyMatrix4(t), h.b.applyMatrix4(t), h.c.applyMatrix4(t), h.needsUpdate = !0;
          for (let N = p, x = p + I; N < x; N++)
            if (l(N), r.needsUpdate = !0, n(r, h, N, S, R, g, y, F))
              return !0;
        }
        return !1;
      };
      if (i) {
        const p = i;
        i = function(I, m, C, R, g, y, F, S) {
          return p(I, m, C, R, g, y, F, S) ? !0 : E(I, m, C, R, g, y, F, S);
        };
      } else
        i = E;
    }
    return pa(this, s, t, i);
  }
  /* Derived Cast Functions */
  intersectsBox(s, t) {
    return $s.set(s.min, s.max, t), $s.needsUpdate = !0, this.shapecast(
      {
        intersectsBounds: (e) => $s.intersectsBox(e),
        intersectsTriangle: (e) => $s.intersectsTriangle(e)
      }
    );
  }
  intersectsSphere(s) {
    return this.shapecast(
      {
        intersectsBounds: (t) => s.intersectsBox(t),
        intersectsTriangle: (t) => t.intersectsSphere(s)
      }
    );
  }
  closestPointToGeometry(s, t, e = {}, i = {}, n = 0, r = 1 / 0) {
    return (this.indirect ? ua : sa)(
      this,
      s,
      t,
      e,
      i,
      n,
      r
    );
  }
  closestPointToPoint(s, t = {}, e = 0, i = 1 / 0) {
    return Bo(
      this,
      s,
      t,
      e,
      i
    );
  }
  getBoundingBox(s) {
    return s.makeEmpty(), this._roots.forEach((e) => {
      wt(0, new Float32Array(e), jn), s.union(jn);
    }), s;
  }
}
function Qn(c, s, t) {
  return c === null || (c.point.applyMatrix4(s.matrixWorld), c.distance = c.point.distanceTo(t.ray.origin), c.object = s, c.distance < t.near || c.distance > t.far) ? null : c;
}
const zi = /* @__PURE__ */ new oo(), qn = /* @__PURE__ */ new de(), Ea = rt.prototype.raycast;
function ma(c, s) {
  if (this.geometry.boundsTree) {
    if (this.material === void 0)
      return;
    qn.copy(this.matrixWorld).invert(), zi.copy(c.ray).applyMatrix4(qn);
    const t = this.geometry.boundsTree;
    if (c.firstHitOnly === !0) {
      const e = Qn(t.raycastFirst(zi, this.material), this, c);
      e && s.push(e);
    } else {
      const e = t.raycast(zi, this.material);
      for (let i = 0, n = e.length; i < n; i++) {
        const r = Qn(e[i], this, c);
        r && s.push(r);
      }
    }
  } else
    Ea.call(this, c, s);
}
function Ia(c) {
  return this.boundsTree = new _n(this, c), this.boundsTree;
}
function ga() {
  this.boundsTree = null;
}
class j {
  constructor() {
    /** Triggers all the callbacks assigned to this event. */
    T(this, "trigger", (s) => {
      const t = this.handlers.slice(0);
      for (const e of t)
        e(s);
    });
    T(this, "handlers", []);
  }
  /**
   * Add a callback to this event instance.
   * @param handler - the callback to be added to this event.
   */
  add(s) {
    this.handlers.push(s);
  }
  /**
   * Removes a callback from this event instance.
   * @param handler - the callback to be removed from this event.
   */
  remove(s) {
    this.handlers = this.handlers.filter((t) => t !== s);
  }
  /** Gets rid of all the suscribed events. */
  reset() {
    this.handlers.length = 0;
  }
}
class oi {
  constructor() {
    /** Triggers all the callbacks assigned to this event. */
    T(this, "trigger", async (s) => {
      const t = this.handlers.slice(0);
      for (const e of t)
        await e(s);
    });
    T(this, "handlers", []);
  }
  /**
   * Add a callback to this event instance.
   * @param handler - the callback to be added to this event.
   */
  add(s) {
    this.handlers.push(s);
  }
  /**
   * Removes a callback from this event instance.
   * @param handler - the callback to be removed from this event.
   */
  remove(s) {
    this.handlers = this.handlers.filter((t) => t !== s);
  }
  /** Gets rid of all the suscribed events. */
  reset() {
    this.handlers.length = 0;
  }
}
class An {
  constructor(s) {
    /** Whether is component is {@link Disposable}. */
    T(this, "isDisposeable", () => "dispose" in this && "onDisposed" in this);
    /** Whether is component is {@link Resizeable}. */
    T(this, "isResizeable", () => "resize" in this && "getSize" in this);
    /** Whether is component is {@link Updateable}. */
    T(this, "isUpdateable", () => "onAfterUpdate" in this && "onBeforeUpdate" in this && "update" in this);
    /** Whether is component is {@link Hideable}. */
    T(this, "isHideable", () => "visible" in this);
    /** Whether is component is {@link Configurable}. */
    T(this, "isConfigurable", () => "setup" in this && "config" in this && "onSetup" in this);
    this.components = s;
  }
}
class St extends An {
}
class Rn extends An {
  constructor(t) {
    super(t);
    T(this, "worlds", /* @__PURE__ */ new Map());
    /**
     * Event that is triggered when a world is added or removed from the `worlds` map.
     * The event payload contains the world instance and the action ("added" or "removed").
     */
    T(this, "onWorldChanged", new j());
    /**
     * The current world this item is associated with. It can be null if no world is currently active.
     */
    T(this, "currentWorld", null);
    this.onWorldChanged.add(({ world: e, action: i }) => {
      i === "removed" && this.worlds.delete(e.uuid);
    });
  }
}
class Ca extends Rn {
  constructor() {
    super(...arguments);
    /**
     * Checks whether the instance is {@link CameraControllable}.
     *
     * @returns True if the instance is controllable, false otherwise.
     */
    T(this, "hasCameraControls", () => "controls" in this);
  }
}
class Ta extends Rn {
  constructor() {
    super(...arguments);
    /** {@link Updateable.onBeforeUpdate} */
    T(this, "onAfterUpdate", new j());
    /** {@link Updateable.onAfterUpdate} */
    T(this, "onBeforeUpdate", new j());
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    /** {@link Resizeable.onResize} */
    T(this, "onResize", new j());
    /**
     * Event that fires when there has been a change to the list of clipping
     * planes used by the active renderer.
     */
    T(this, "onClippingPlanesUpdated", new j());
    /**
     * The list of [clipping planes](https://threejs.org/docs/#api/en/renderers/WebGLRenderer.clippingPlanes) used by this instance of the renderer.
     */
    T(this, "clippingPlanes", []);
  }
  /**
   * Updates the clipping planes and triggers the `onClippingPlanesUpdated` event.
   *
   * @remarks
   * This method is typically called when there is a change to the list of clipping planes
   * used by the active renderer.
   */
  updateClippingPlanes() {
    this.onClippingPlanesUpdated.trigger();
  }
  /**
   * Sets or removes a clipping plane from the renderer.
   *
   * @param active - A boolean indicating whether the clipping plane should be active or not.
   * @param plane - The clipping plane to be added or removed.
   * @param isLocal - An optional boolean indicating whether the clipping plane is local to the object. If not provided, it defaults to `false`.
   *
   * @remarks
   * This method adds or removes a clipping plane from the `clippingPlanes` array.
   * If `active` is `true` and the plane is not already in the array, it is added.
   * If `active` is `false` and the plane is in the array, it is removed.
   * The `three.clippingPlanes` property is then updated to reflect the current state of the `clippingPlanes` array,
   * excluding any planes marked as local.
   */
  setPlane(t, e, i) {
    e.isLocal = i;
    const n = this.clippingPlanes.indexOf(e);
    t && n === -1 ? this.clippingPlanes.push(e) : !t && n > -1 && this.clippingPlanes.splice(n, 1), this.three.clippingPlanes = this.clippingPlanes.filter(
      (r) => !r.isLocal
    );
  }
}
const ys = class ys extends St {
  constructor(t) {
    super(t);
    T(this, "_disposedComponents", /* @__PURE__ */ new Set());
    /** {@link Component.enabled} */
    T(this, "enabled", !0);
    t.add(ys.uuid, this);
  }
  // TODO: Remove this?
  /**
   * Return the UUIDs of all disposed components.
   */
  get() {
    return this._disposedComponents;
  }
  /**
   * Removes a mesh, its geometry and its materials from memory. If you are
   * using any of these in other parts of the application, make sure that you
   * remove them from the mesh before disposing it.
   *
   * @param object - the [object](https://threejs.org/docs/#api/en/core/Object3D)
   * to remove.
   *
   * @param materials - whether to dispose the materials of the mesh.
   *
   * @param recursive - whether to recursively dispose the children of the mesh.
   */
  destroy(t, e = !0, i = !0) {
    t.removeFromParent();
    const n = t;
    n.dispose && n.dispose(), this.disposeGeometryAndMaterials(t, e), i && n.children && n.children.length && this.disposeChildren(n), t.children.length = 0;
  }
  /**
   * Disposes a geometry from memory.
   *
   * @param geometry - the
   * [geometry](https://threejs.org/docs/#api/en/core/BufferGeometry)
   * to remove.
   */
  disposeGeometry(t) {
    t.boundsTree && t.disposeBoundsTree && t.disposeBoundsTree(), t.dispose();
  }
  disposeGeometryAndMaterials(t, e) {
    const i = t;
    i.geometry && this.disposeGeometry(i.geometry), e && i.material && ys.disposeMaterial(i), i.material = [], i.geometry = null;
  }
  disposeChildren(t) {
    for (const e of t.children)
      this.destroy(e);
  }
  static disposeMaterial(t) {
    if (t.material)
      if (Array.isArray(t.material))
        for (const e of t.material)
          e.dispose();
      else
        t.material.dispose();
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
T(ys, "uuid", "76e9cd8e-ad8f-4753-9ef6-cbc60f7247fe");
let Fe = ys;
class _a extends Rn {
  constructor(t) {
    super(t);
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    /** The set of directional lights managed by this scene component. */
    T(this, "directionalLights", /* @__PURE__ */ new Map());
    /** The set of ambient lights managed by this scene component. */
    T(this, "ambientLights", /* @__PURE__ */ new Map());
  }
  /** {@link Disposable.dispose} */
  dispose() {
    const t = this.components.get(Fe);
    for (const e of this.three.children) {
      const i = e;
      i.geometry && t.destroy(i);
    }
    for (const [, e] of this.directionalLights)
      e.removeFromParent(), e.target.removeFromParent(), e.dispose();
    for (const [, e] of this.ambientLights)
      e.removeFromParent(), e.dispose();
    this.three.children = [], this.onDisposed.trigger(), this.onDisposed.reset();
  }
}
class qe extends Set {
  /**
   * Constructs a new instance of the DataSet class.
   *
   * @param iterable - An optional iterable object to initialize the set with.
   */
  constructor(t) {
    super(t);
    /**
     * An event that is triggered when a new item is added to the set.
     */
    T(this, "onItemAdded", new j());
    /**
     * An event that is triggered when an item is deleted from the set.
     */
    T(this, "onItemDeleted", new j());
    /**
     * An event that is triggered when the set is cleared.
     */
    T(this, "onCleared", new j());
    /**
     * A function that acts as a guard for adding items to the set.
     * It determines whether a given value should be allowed to be added to the set.
     *
     * @param value - The value to be checked against the guard.
     * @returns A boolean indicating whether the value should be allowed to be added to the set.
     *          By default, this function always returns true, allowing all values to be added.
     *          You can override this behavior by providing a custom implementation.
     */
    T(this, "guard", () => !0);
  }
  /**
   * Clears the set and triggers the onCleared event.
   */
  clear() {
    super.clear(), this.onCleared.trigger();
  }
  /**
   * Adds one or multiple values to the set and triggers the onItemAdded event per each.
   *
   * @param value - The value to add to the set.
   * @returns - The set instance.
   */
  add(...t) {
    for (const e of t)
      this.has(e) || !this.guard(e) || (super.add(e), this.onItemAdded || (this.onItemAdded = new j()), this.onItemAdded.trigger(e));
    return this;
  }
  /**
   * Deletes a value from the set and triggers the onItemDeleted event.
   *
   * @param value - The value to delete from the set.
   * @returns - True if the value was successfully deleted, false otherwise.
   */
  delete(t) {
    const e = super.delete(t);
    return e && this.onItemDeleted.trigger(), e;
  }
  /**
   * Clears the set and resets the onItemAdded, onItemDeleted, and onCleared events.
   */
  dispose() {
    this.clear(), this.onItemAdded.reset(), this.onItemDeleted.reset(), this.onCleared.reset();
  }
}
class Ee extends Map {
  /**
   * Constructs a new DataMap instance.
   *
   * @param iterable - An iterable object containing key-value pairs to populate the map.
   */
  constructor(t) {
    super(t);
    /**
     * An event triggered when a new item is set in the map.
     */
    T(this, "onItemSet", new j());
    /**
     * An event triggered when an existing item in the map is updated.
     */
    T(this, "onItemUpdated", new j());
    /**
     * An event triggered when an item is deleted from the map.
     */
    T(this, "onItemDeleted", new j());
    /**
     * An event triggered when the map is cleared.
     */
    T(this, "onCleared", new j());
    /**
     * A function that acts as a guard for adding items to the set.
     * It determines whether a given value should be allowed to be added to the set.
     *
     * @param key - The key of the entry to be checked against the guard.
     * @param value - The value of the entry to be checked against the guard.
     * @returns A boolean indicating whether the value should be allowed to be added to the set.
     *          By default, this function always returns true, allowing all values to be added.
     *          You can override this behavior by providing a custom implementation.
     */
    T(this, "guard", () => !0);
  }
  /**
   * Clears the map and triggers the onCleared event.
   */
  clear() {
    super.clear(), this.onCleared.trigger();
  }
  /**
   * Sets the value for the specified key in the map and triggers the appropriate event (onItemSet or onItemUpdated).
   *
   * @param key - The key of the item to set.
   * @param value - The value of the item to set.
   * @returns The DataMap instance.
   */
  set(t, e) {
    const i = this.has(t);
    if (!(this.guard ?? (() => !0))(t, e))
      return this;
    const o = super.set(t, e);
    return i ? (this.onItemUpdated || (this.onItemUpdated = new j()), this.onItemUpdated.trigger({ key: t, value: e })) : (this.onItemSet || (this.onItemSet = new j()), this.onItemSet.trigger({ key: t, value: e })), o;
  }
  /**
   * Deletes the specified key from the map and triggers the onItemDeleted event if the key was found.
   *
   * @param key - The key of the item to delete.
   * @returns True if the key was found and deleted; otherwise, false.
   */
  delete(t) {
    const e = super.delete(t);
    return e && this.onItemDeleted.trigger(t), e;
  }
  /**
   * Clears the map and resets the events.
   */
  dispose() {
    this.clear(), this.onItemSet.reset(), this.onItemDeleted.reset(), this.onCleared.reset();
  }
}
const ai = 0, Aa = 1, Ra = new q(), Kn = new he(), ki = new gn(), Jn = new q(), js = new je();
class ya {
  constructor() {
    this.tolerance = -1, this.faces = [], this.newFaces = [], this.assigned = new tr(), this.unassigned = new tr(), this.vertices = [];
  }
  setFromPoints(s) {
    if (s.length >= 4) {
      this.makeEmpty();
      for (let t = 0, e = s.length; t < e; t++)
        this.vertices.push(new wa(s[t]));
      this.compute();
    }
    return this;
  }
  setFromObject(s) {
    const t = [];
    return s.updateMatrixWorld(!0), s.traverse(function(e) {
      const i = e.geometry;
      if (i !== void 0) {
        const n = i.attributes.position;
        if (n !== void 0)
          for (let r = 0, o = n.count; r < o; r++) {
            const a = new q();
            a.fromBufferAttribute(n, r).applyMatrix4(e.matrixWorld), t.push(a);
          }
      }
    }), this.setFromPoints(t);
  }
  containsPoint(s) {
    const t = this.faces;
    for (let e = 0, i = t.length; e < i; e++)
      if (t[e].distanceToPoint(s) > this.tolerance)
        return !1;
    return !0;
  }
  intersectRay(s, t) {
    const e = this.faces;
    let i = -1 / 0, n = 1 / 0;
    for (let r = 0, o = e.length; r < o; r++) {
      const a = e[r], l = a.distanceToPoint(s.origin), h = a.normal.dot(s.direction);
      if (l > 0 && h >= 0)
        return null;
      const d = h !== 0 ? -l / h : 0;
      if (!(d <= 0) && (h > 0 ? n = Math.min(d, n) : i = Math.max(d, i), i > n))
        return null;
    }
    return i !== -1 / 0 ? s.at(i, t) : s.at(n, t), t;
  }
  intersectsRay(s) {
    return this.intersectRay(s, Ra) !== null;
  }
  makeEmpty() {
    return this.faces = [], this.vertices = [], this;
  }
  // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face
  addVertexToFace(s, t) {
    return s.face = t, t.outside === null ? this.assigned.append(s) : this.assigned.insertBefore(t.outside, s), t.outside = s, this;
  }
  // Removes a vertex from the 'assigned' list of vertices and from the given face
  removeVertexFromFace(s, t) {
    return s === t.outside && (s.next !== null && s.next.face === t ? t.outside = s.next : t.outside = null), this.assigned.remove(s), this;
  }
  // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list
  removeAllVerticesFromFace(s) {
    if (s.outside !== null) {
      const t = s.outside;
      let e = s.outside;
      for (; e.next !== null && e.next.face === s; )
        e = e.next;
      return this.assigned.removeSubList(t, e), t.prev = e.next = null, s.outside = null, t;
    }
  }
  // Removes all the visible vertices that 'face' is able to see
  deleteFaceVertices(s, t) {
    const e = this.removeAllVerticesFromFace(s);
    if (e !== void 0)
      if (t === void 0)
        this.unassigned.appendChain(e);
      else {
        let i = e;
        do {
          const n = i.next;
          t.distanceToPoint(i.point) > this.tolerance ? this.addVertexToFace(i, t) : this.unassigned.append(i), i = n;
        } while (i !== null);
      }
    return this;
  }
  // Reassigns as many vertices as possible from the unassigned list to the new faces
  resolveUnassignedPoints(s) {
    if (this.unassigned.isEmpty() === !1) {
      let t = this.unassigned.first();
      do {
        const e = t.next;
        let i = this.tolerance, n = null;
        for (let r = 0; r < s.length; r++) {
          const o = s[r];
          if (o.mark === ai) {
            const a = o.distanceToPoint(t.point);
            if (a > i && (i = a, n = o), i > 1e3 * this.tolerance)
              break;
          }
        }
        n !== null && this.addVertexToFace(t, n), t = e;
      } while (t !== null);
    }
    return this;
  }
  // Computes the extremes of a simplex which will be the initial hull
  computeExtremes() {
    const s = new q(), t = new q(), e = [], i = [];
    for (let n = 0; n < 3; n++)
      e[n] = i[n] = this.vertices[0];
    s.copy(this.vertices[0].point), t.copy(this.vertices[0].point);
    for (let n = 0, r = this.vertices.length; n < r; n++) {
      const o = this.vertices[n], a = o.point;
      for (let l = 0; l < 3; l++)
        a.getComponent(l) < s.getComponent(l) && (s.setComponent(l, a.getComponent(l)), e[l] = o);
      for (let l = 0; l < 3; l++)
        a.getComponent(l) > t.getComponent(l) && (t.setComponent(l, a.getComponent(l)), i[l] = o);
    }
    return this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(s.x), Math.abs(t.x)) + Math.max(Math.abs(s.y), Math.abs(t.y)) + Math.max(Math.abs(s.z), Math.abs(t.z))), { min: e, max: i };
  }
  // Computes the initial simplex assigning to its faces all the points
  // that are candidates to form part of the hull
  computeInitialHull() {
    const s = this.vertices, t = this.computeExtremes(), e = t.min, i = t.max;
    let n = 0, r = 0;
    for (let u = 0; u < 3; u++) {
      const f = i[u].point.getComponent(u) - e[u].point.getComponent(u);
      f > n && (n = f, r = u);
    }
    const o = e[r], a = i[r];
    let l, h;
    n = 0, Kn.set(o.point, a.point);
    for (let u = 0, f = this.vertices.length; u < f; u++) {
      const E = s[u];
      if (E !== o && E !== a) {
        Kn.closestPointToPoint(E.point, !0, Jn);
        const p = Jn.distanceToSquared(E.point);
        p > n && (n = p, l = E);
      }
    }
    n = -1, ki.setFromCoplanarPoints(o.point, a.point, l.point);
    for (let u = 0, f = this.vertices.length; u < f; u++) {
      const E = s[u];
      if (E !== o && E !== a && E !== l) {
        const p = Math.abs(ki.distanceToPoint(E.point));
        p > n && (n = p, h = E);
      }
    }
    const d = [];
    if (ki.distanceToPoint(h.point) < 0) {
      d.push(
        Kt.create(o, a, l),
        Kt.create(h, a, o),
        Kt.create(h, l, a),
        Kt.create(h, o, l)
      );
      for (let u = 0; u < 3; u++) {
        const f = (u + 1) % 3;
        d[u + 1].getEdge(2).setTwin(d[0].getEdge(f)), d[u + 1].getEdge(1).setTwin(d[f + 1].getEdge(0));
      }
    } else {
      d.push(
        Kt.create(o, l, a),
        Kt.create(h, o, a),
        Kt.create(h, a, l),
        Kt.create(h, l, o)
      );
      for (let u = 0; u < 3; u++) {
        const f = (u + 1) % 3;
        d[u + 1].getEdge(2).setTwin(d[0].getEdge((3 - u) % 3)), d[u + 1].getEdge(0).setTwin(d[f + 1].getEdge(1));
      }
    }
    for (let u = 0; u < 4; u++)
      this.faces.push(d[u]);
    for (let u = 0, f = s.length; u < f; u++) {
      const E = s[u];
      if (E !== o && E !== a && E !== l && E !== h) {
        n = this.tolerance;
        let p = null;
        for (let I = 0; I < 4; I++) {
          const m = this.faces[I].distanceToPoint(E.point);
          m > n && (n = m, p = this.faces[I]);
        }
        p !== null && this.addVertexToFace(E, p);
      }
    }
    return this;
  }
  // Removes inactive faces
  reindexFaces() {
    const s = [];
    for (let t = 0; t < this.faces.length; t++) {
      const e = this.faces[t];
      e.mark === ai && s.push(e);
    }
    return this.faces = s, this;
  }
  // Finds the next vertex to create faces with the current hull
  nextVertexToAdd() {
    if (this.assigned.isEmpty() === !1) {
      let s, t = 0;
      const e = this.assigned.first().face;
      let i = e.outside;
      do {
        const n = e.distanceToPoint(i.point);
        n > t && (t = n, s = i), i = i.next;
      } while (i !== null && i.face === e);
      return s;
    }
  }
  // Computes a chain of half edges in CCW order called the 'horizon'.
  // For an edge to be part of the horizon it must join a face that can see
  // 'eyePoint' and a face that cannot see 'eyePoint'.
  computeHorizon(s, t, e, i) {
    this.deleteFaceVertices(e), e.mark = Aa;
    let n;
    t === null ? n = t = e.getEdge(0) : n = t.next;
    do {
      const r = n.twin, o = r.face;
      o.mark === ai && (o.distanceToPoint(s) > this.tolerance ? this.computeHorizon(s, r, o, i) : i.push(n)), n = n.next;
    } while (n !== t);
    return this;
  }
  // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order
  addAdjoiningFace(s, t) {
    const e = Kt.create(s, t.tail(), t.head());
    return this.faces.push(e), e.getEdge(-1).setTwin(t.twin), e.getEdge(0);
  }
  //  Adds 'horizon.length' faces to the hull, each face will be linked with the
  //  horizon opposite face and the face on the left/right
  addNewFaces(s, t) {
    this.newFaces = [];
    let e = null, i = null;
    for (let n = 0; n < t.length; n++) {
      const r = t[n], o = this.addAdjoiningFace(s, r);
      e === null ? e = o : o.next.setTwin(i), this.newFaces.push(o.face), i = o;
    }
    return e.next.setTwin(i), this;
  }
  // Adds a vertex to the hull
  addVertexToHull(s) {
    const t = [];
    return this.unassigned.clear(), this.removeVertexFromFace(s, s.face), this.computeHorizon(s.point, null, s.face, t), this.addNewFaces(s, t), this.resolveUnassignedPoints(this.newFaces), this;
  }
  cleanup() {
    return this.assigned.clear(), this.unassigned.clear(), this.newFaces = [], this;
  }
  compute() {
    let s;
    for (this.computeInitialHull(); (s = this.nextVertexToAdd()) !== void 0; )
      this.addVertexToHull(s);
    return this.reindexFaces(), this.cleanup(), this;
  }
}
class Kt {
  constructor() {
    this.normal = new q(), this.midpoint = new q(), this.area = 0, this.constant = 0, this.outside = null, this.mark = ai, this.edge = null;
  }
  static create(s, t, e) {
    const i = new Kt(), n = new Vi(s, i), r = new Vi(t, i), o = new Vi(e, i);
    return n.next = o.prev = r, r.next = n.prev = o, o.next = r.prev = n, i.edge = n, i.compute();
  }
  getEdge(s) {
    let t = this.edge;
    for (; s > 0; )
      t = t.next, s--;
    for (; s < 0; )
      t = t.prev, s++;
    return t;
  }
  compute() {
    const s = this.edge.tail(), t = this.edge.head(), e = this.edge.next.head();
    return js.set(s.point, t.point, e.point), js.getNormal(this.normal), js.getMidpoint(this.midpoint), this.area = js.getArea(), this.constant = this.normal.dot(this.midpoint), this;
  }
  distanceToPoint(s) {
    return this.normal.dot(s) - this.constant;
  }
}
class Vi {
  constructor(s, t) {
    this.vertex = s, this.prev = null, this.next = null, this.twin = null, this.face = t;
  }
  head() {
    return this.vertex;
  }
  tail() {
    return this.prev ? this.prev.vertex : null;
  }
  length() {
    const s = this.head(), t = this.tail();
    return t !== null ? t.point.distanceTo(s.point) : -1;
  }
  lengthSquared() {
    const s = this.head(), t = this.tail();
    return t !== null ? t.point.distanceToSquared(s.point) : -1;
  }
  setTwin(s) {
    return this.twin = s, s.twin = this, this;
  }
}
class wa {
  constructor(s) {
    this.point = s, this.prev = null, this.next = null, this.face = null;
  }
}
class tr {
  constructor() {
    this.head = null, this.tail = null;
  }
  first() {
    return this.head;
  }
  last() {
    return this.tail;
  }
  clear() {
    return this.head = this.tail = null, this;
  }
  // Inserts a vertex before the target vertex
  insertBefore(s, t) {
    return t.prev = s.prev, t.next = s, t.prev === null ? this.head = t : t.prev.next = t, s.prev = t, this;
  }
  // Inserts a vertex after the target vertex
  insertAfter(s, t) {
    return t.prev = s, t.next = s.next, t.next === null ? this.tail = t : t.next.prev = t, s.next = t, this;
  }
  // Appends a vertex to the end of the linked list
  append(s) {
    return this.head === null ? this.head = s : this.tail.next = s, s.prev = this.tail, s.next = null, this.tail = s, this;
  }
  // Appends a chain of vertices where 'vertex' is the head.
  appendChain(s) {
    for (this.head === null ? this.head = s : this.tail.next = s, s.prev = this.tail; s.next !== null; )
      s = s.next;
    return this.tail = s, this;
  }
  // Removes a vertex from the linked list
  remove(s) {
    return s.prev === null ? this.head = s.next : s.prev.next = s.next, s.next === null ? this.tail = s.prev : s.next.prev = s.prev, this;
  }
  // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b
  removeSubList(s, t) {
    return s.prev === null ? this.head = t.next : s.prev.next = t.next, t.next === null ? this.tail = s.prev : t.next.prev = s.prev, this;
  }
  isEmpty() {
    return this.head === null;
  }
}
const rn = [2, 2, 1], on = [1, 0, 0];
function ae(c, s) {
  return c * 3 + s;
}
function Fa(c) {
  const s = c.elements;
  let t = 0;
  for (let e = 0; e < 9; e++)
    t += s[e] * s[e];
  return Math.sqrt(t);
}
function Sa(c) {
  const s = c.elements;
  let t = 0;
  for (let e = 0; e < 3; e++) {
    const i = s[ae(rn[e], on[e])];
    t += 2 * i * i;
  }
  return Math.sqrt(t);
}
function Oa(c, s) {
  let t = 0, e = 1;
  const i = c.elements;
  for (let l = 0; l < 3; l++) {
    const h = Math.abs(i[ae(rn[l], on[l])]);
    h > t && (t = h, e = l);
  }
  let n = 1, r = 0;
  const o = on[e], a = rn[e];
  if (Math.abs(i[ae(a, o)]) > Number.EPSILON) {
    const l = i[ae(a, a)], h = i[ae(o, o)], d = i[ae(a, o)], u = (l - h) / 2 / d;
    let f;
    u < 0 ? f = -1 / (-u + Math.sqrt(1 + u * u)) : f = 1 / (u + Math.sqrt(1 + u * u)), n = 1 / Math.sqrt(1 + f * f), r = f * n;
  }
  return s.identity(), s.elements[ae(o, o)] = n, s.elements[ae(a, a)] = n, s.elements[ae(a, o)] = r, s.elements[ae(o, a)] = -r, s;
}
function Na(c, s) {
  let t = 0, e = 0;
  const i = 10;
  s.unitary.identity(), s.diagonal.copy(c);
  const n = s.unitary, r = s.diagonal, o = new M.Matrix3(), a = new M.Matrix3(), l = Number.EPSILON * Fa(r);
  for (; e < i && Sa(r) > l; )
    Oa(r, o), a.copy(o).transpose(), r.multiply(o), r.premultiply(a), n.multiply(o), ++t > 2 && (e++, t = 0);
  return s;
}
function ba(c) {
  const s = [];
  for (let at = 0; at < c.length - 2; at += 3) {
    const ft = c[at], ut = c[at + 1], It = c[at + 2];
    s.push(new M.Vector3(ft, ut, It));
  }
  const t = new ya();
  t.setFromPoints(s);
  const e = {
    unitary: new M.Matrix3(),
    diagonal: new M.Matrix3()
  }, i = t.faces, n = [], r = [];
  for (let at = 0, ft = i.length; at < ft; at++) {
    const ut = i[at];
    let It = ut.edge;
    n.length = 0;
    do
      n.push(It), It = It.next;
    while (It !== ut.edge);
    const Gt = n.length - 2;
    for (let Mt = 1, A = Gt; Mt <= A; Mt++) {
      const W = n[0].vertex, Y = n[Mt + 0].vertex, b = n[Mt + 1].vertex;
      r.push(W.point.x, W.point.y, W.point.z), r.push(Y.point.x, Y.point.y, Y.point.z), r.push(b.point.x, b.point.y, b.point.z);
    }
  }
  const o = new M.Vector3(), a = new M.Vector3(), l = new M.Vector3(), h = new M.Vector3(), d = new M.Vector3(), u = new M.Vector3(), f = new M.Vector3(), E = new M.Vector3();
  let p = 0, I = 0, m = 0, C = 0, R = 0, g = 0, y = 0;
  for (let at = 0, ft = r.length; at < ft; at += 9) {
    o.fromArray(r, at), a.fromArray(r, at + 3), l.fromArray(r, at + 6), f.set(0, 0, 0), f.add(o).add(a).add(l).divideScalar(3), h.subVectors(a, o), d.subVectors(l, o);
    const ut = u.crossVectors(h, d).length() / 2;
    E.add(u.copy(f).multiplyScalar(ut)), p += ut, I += (9 * f.x * f.x + o.x * o.x + a.x * a.x + l.x * l.x) * (ut / 12), m += (9 * f.x * f.y + o.x * o.y + a.x * a.y + l.x * l.y) * (ut / 12), C += (9 * f.x * f.z + o.x * o.z + a.x * a.z + l.x * l.z) * (ut / 12), R += (9 * f.y * f.y + o.y * o.y + a.y * a.y + l.y * l.y) * (ut / 12), g += (9 * f.y * f.z + o.y * o.z + a.y * a.z + l.y * l.z) * (ut / 12), y += (9 * f.z * f.z + o.z * o.z + a.z * a.z + l.z * l.z) * (ut / 12);
  }
  E.divideScalar(p), I /= p, m /= p, C /= p, R /= p, g /= p, y /= p, I -= E.x * E.x, m -= E.x * E.y, C -= E.x * E.z, R -= E.y * E.y, g -= E.y * E.z, y -= E.z * E.z;
  const F = new M.Matrix3();
  F.elements[0] = I, F.elements[1] = m, F.elements[2] = C, F.elements[3] = m, F.elements[4] = R, F.elements[5] = g, F.elements[6] = C, F.elements[7] = g, F.elements[8] = y, Na(F, e);
  const S = e.unitary, L = new M.Vector3(), N = new M.Vector3(), x = new M.Vector3();
  S.extractBasis(L, N, x);
  let k = -1 / 0, w = -1 / 0, P = -1 / 0, _ = 1 / 0, v = 1 / 0, Q = 1 / 0;
  for (let at = 0, ft = s.length; at < ft; at++) {
    const ut = s[at];
    k = Math.max(L.dot(ut), k), w = Math.max(N.dot(ut), w), P = Math.max(x.dot(ut), P), _ = Math.min(L.dot(ut), _), v = Math.min(N.dot(ut), v), Q = Math.min(x.dot(ut), Q);
  }
  L.multiplyScalar(0.5 * (_ + k)), N.multiplyScalar(0.5 * (v + w)), x.multiplyScalar(0.5 * (Q + P));
  const V = new M.Vector3(), et = new M.Vector3(), H = new M.Matrix3();
  V.add(L).add(N).add(x), et.x = k - _, et.y = w - v, et.z = P - Q, et.multiplyScalar(0.5), H.copy(S);
  const { x: nt, y: z, z: U } = et, ot = new M.Matrix4();
  ot.makeScale(nt * 2, z * 2, U * 2);
  const st = new M.Matrix4();
  st.makeTranslation(-nt, -z, -U);
  const tt = new M.Matrix4();
  tt.makeTranslation(V.x, V.y, V.z);
  const Rt = new M.Matrix4();
  Rt.setFromMatrix3(H);
  const Ft = new M.Matrix4();
  return Ft.multiply(tt), Ft.multiply(Rt), Ft.multiply(st), Ft.multiply(ot), { center: V, halfSizes: et, rotation: H, transformation: Ft };
}
function Pa(c, s, t) {
  const e = [
    c[0] - s[0],
    c[1] - s[1],
    c[2] - s[2]
  ];
  return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] > 0;
}
class er {
  static isTransparent(s) {
    return s.transparent && s.opacity < 1;
  }
}
const Nt = class Nt {
  // Copied from three.js source
  // Original source: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
  static create() {
    const s = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
    return `${Nt._lut[s & 255] + Nt._lut[s >> 8 & 255] + Nt._lut[s >> 16 & 255] + Nt._lut[s >> 24 & 255]}-${Nt._lut[t & 255]}${Nt._lut[t >> 8 & 255]}-${Nt._lut[t >> 16 & 15 | 64]}${Nt._lut[t >> 24 & 255]}-${Nt._lut[e & 63 | 128]}${Nt._lut[e >> 8 & 255]}-${Nt._lut[e >> 16 & 255]}${Nt._lut[e >> 24 & 255]}${Nt._lut[i & 255]}${Nt._lut[i >> 8 & 255]}${Nt._lut[i >> 16 & 255]}${Nt._lut[i >> 24 & 255]}`.toLowerCase();
  }
  static validate(s) {
    if (!Nt._pattern.test(s))
      throw new Error(
        `${s} is not a valid UUID v4.

- If you're the tool creator, you can take one from https://www.uuidgenerator.net/.

- If you're using a platform tool, verify the uuid isn't misspelled or contact the tool creator.`
      );
  }
};
T(Nt, "_pattern", /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/), // prettier-ignore
T(Nt, "_lut", [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff"
]);
let me = Nt;
class xl extends St {
  constructor(t, e) {
    super(t);
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    /**
     * An event that is triggered when a vertex is found.
     * The event passes a THREE.Vector3 representing the position of the found vertex.
     */
    T(this, "onVertexFound", new j());
    /**
     * An event that is triggered when a vertex is lost.
     * The event passes a THREE.Vector3 representing the position of the lost vertex.
     */
    T(this, "onVertexLost", new j());
    /**
     * An event that is triggered when the picker is enabled or disabled
     */
    T(this, "onEnabled", new j());
    /**
     * A reference to the Components instance associated with this VertexPicker.
     */
    T(this, "components");
    /**
     * A reference to the working plane used for vertex picking.
     * This plane is used to determine which vertices are considered valid for picking.
     * If this value is null, all vertices are considered valid.
     */
    T(this, "workingPlane", null);
    T(this, "_pickedPoint", null);
    T(this, "_config");
    T(this, "_enabled", !1);
    this.components = t, this.config = {
      snapDistance: 0.25,
      showOnlyVertex: !1,
      ...e
    }, this.enabled = !1;
  }
  /**
   * Sets the enabled state of the VertexPicker.
   * When enabled, the VertexPicker will actively search for vertices in the 3D scene.
   * When disabled, the VertexPicker will stop searching for vertices and reset the picked point.
   *
   * @param value - The new enabled state.
   */
  set enabled(t) {
    this._enabled = t, t || (this._pickedPoint = null), this.onEnabled.trigger(t);
  }
  /**
   * Gets the current enabled state of the VertexPicker.
   *
   * @returns The current enabled state.
   */
  get enabled() {
    return this._enabled;
  }
  /**
   * Sets the configuration for the VertexPicker component.
   *
   * @param value - A Partial object containing the configuration properties to update.
   * The properties not provided in the value object will retain their current values.
   *
   * @example
   * ```typescript
   * vertexPicker.config = {
   *   snapDistance: 0.5,
   *   showOnlyVertex: true,
   * };
   * ```
   */
  set config(t) {
    this._config = { ...this._config, ...t };
  }
  /**
   * Gets the current configuration for the VertexPicker component.
   *
   * @returns A copy of the current VertexPickerConfig object.
   *
   * @example
   * ```typescript
   * const currentConfig = vertexPicker.config;
   * console.log(currentConfig.snapDistance); // Output: 0.25
   * ```
   */
  get config() {
    return this._config;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.onVertexFound.reset(), this.onVertexLost.reset(), this.components = null, this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Performs the vertex picking operation based on the current state of the VertexPicker.
   *
   * @param world - The World instance to use for raycasting.
   *
   * @returns The current picked point, or null if no point is picked.
   *
   * @remarks
   * This method checks if the VertexPicker is enabled. If not, it returns the current picked point.
   * If enabled, it performs raycasting to find the closest intersecting object.
   * It then determines the closest vertex or point on the face, based on the configuration settings.
   * If the picked point is on the working plane (if defined), it triggers the `onVertexFound` event and updates the `pickedPoint`.
   * If the picked point is not on the working plane, it resets the `pickedPoint`.
   * If no intersecting object is found, it triggers the `onVertexLost` event and resets the `pickedPoint`.
   */
  get(t) {
    if (!this.enabled)
      return this._pickedPoint;
    const n = this.components.get(ts).get(t).castRay();
    if (!n)
      return this._pickedPoint !== null && (this.onVertexLost.trigger(), this._pickedPoint = null), this._pickedPoint;
    const r = this.getClosestVertex(n);
    return r ? (this.workingPlane ? Math.abs(this.workingPlane.distanceToPoint(r)) < 1e-3 : !0) ? ((this._pickedPoint === null || !this._pickedPoint.equals(r)) && (this._pickedPoint = r.clone(), this.onVertexFound.trigger(this._pickedPoint)), this._pickedPoint) : (this._pickedPoint = null, this._pickedPoint) : (this._pickedPoint !== null && (this.onVertexLost.trigger(), this._pickedPoint = null), this._pickedPoint);
  }
  getClosestVertex(t) {
    let e = new M.Vector3(), i = !1, n = Number.MAX_SAFE_INTEGER;
    const r = this.getVertices(t);
    if (r === null)
      return null;
    for (const o of r) {
      if (!o)
        continue;
      const a = t.point.distanceTo(o);
      a > n || a > this._config.snapDistance || (i = !0, e = o, n = t.point.distanceTo(o));
    }
    return i ? e : this.config.showOnlyVertex ? null : t.point;
  }
  getVertices(t) {
    const e = t.object;
    if (!t.face || !e)
      return null;
    const i = e.geometry, n = new M.Matrix4(), { instanceId: r } = t, o = r !== void 0, a = e instanceof M.InstancedMesh;
    return a && o && e.getMatrixAt(r, n), [
      this.getVertex(t.face.a, i),
      this.getVertex(t.face.b, i),
      this.getVertex(t.face.c, i)
    ].map((l) => (l && (a && o && l.applyMatrix4(n), l.applyMatrix4(e.matrixWorld)), l));
  }
  getVertex(t, e) {
    if (t === void 0)
      return null;
    const i = e.attributes.position;
    return new M.Vector3(
      i.getX(t),
      i.getY(t),
      i.getZ(t)
    );
  }
}
const ui = class ui {
  constructor() {
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    /**
     * The list of components created in this app.
     * The keys are UUIDs and the values are instances of the components.
     */
    T(this, "list", /* @__PURE__ */ new Map());
    /**
     * If disabled, the animation loop will be stopped.
     * Default value is false.
     */
    T(this, "enabled", !1);
    T(this, "_clock");
    /**
     * Event that triggers the Components instance is initialized.
     *
     * @remarks
     * This event is triggered once when the {@link Components.init} method has been called and finish processing.
     * This is useful to set configuration placeholders that need to be executed when the components instance is initialized.
     * For example, enabling and configuring custom effects in a post-production renderer.
     *
     * @example
     * ```typescript
     * const components = new Components();
     * components.onInit.add(() => {
     *   // Enable custom effects in the post-production renderer
     *   // or any other operation dependant on the component initialization
     * });
     * components.init();
     * ```
     */
    T(this, "onInit", new j());
    T(this, "update", () => {
      if (!this.enabled)
        return;
      const s = this._clock.getDelta();
      for (const [t, e] of this.list)
        e.enabled && e.isUpdateable() && e.update(s);
      requestAnimationFrame(this.update);
    });
    this._clock = new M.Clock(), ui.setupBVH();
  }
  /**
   * Adds a component to the list of components.
   * Throws an error if a component with the same UUID already exists.
   *
   * @param uuid - The unique identifier of the component.
   * @param instance - The instance of the component to be added.
   *
   * @throws Will throw an error if a component with the same UUID already exists.
   *
   * @internal
   */
  add(s, t) {
    if (this.list.has(s))
      throw new Error(
        "You're trying to add a component that already exists in the components instance. Use Components.get() instead."
      );
    me.validate(s), this.list.set(s, t);
  }
  /**
   * Retrieves a component instance by its constructor function.
   * If the component does not exist in the list, it will be created and added.
   *
   * @template U - The type of the component to retrieve.
   * @param Component - The constructor function of the component to retrieve.
   *
   * @returns The instance of the requested component.
   *
   * @throws Will throw an error if a component with the same UUID already exists.
   *
   * @internal
   */
  get(s) {
    const t = s.uuid;
    if (!this.list.has(t)) {
      const e = new s(this);
      return this.list.has(t) || this.add(t, e), e;
    }
    return this.list.get(t);
  }
  /**
   * Initializes the Components instance.
   * This method starts the animation loop, sets the enabled flag to true,
   * and calls the update method.
   */
  init() {
    this.enabled = !0, this._clock.start(), this.update(), this.onInit.trigger();
  }
  /**
   * Disposes the memory of all the components and tools of this instance of
   * the library. A memory leak will be created if:
   *
   * - An instance of the library ends up out of scope and this function isn't
   * called. This is especially relevant in Single Page Applications (React,
   * Angular, Vue, etc).
   *
   * - Any of the objects of this instance (meshes, geometries,materials, etc) is
   * referenced by a reference type (object or array).
   *
   * You can learn more about how Three.js handles memory leaks
   * [here](https://threejs.org/docs/#manual/en/introduction/How-to-dispose-of-objects).
   *
   */
  dispose() {
    this.enabled = !1;
    for (const [s, t] of this.list)
      t.enabled = !1, t.isDisposeable() && t.dispose();
    this._clock.stop(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  static setupBVH() {
    M.BufferGeometry.prototype.computeBoundsTree = Ia, M.BufferGeometry.prototype.disposeBoundsTree = ga, M.Mesh.prototype.raycast = ma;
  }
};
/**
 * The version of the @thatopen/components library.
 */
T(ui, "release", "2.2.12");
let an = ui;
class La extends An {
  constructor() {
    super(...arguments);
    /**
     * All the loaded [meshes](https://threejs.org/docs/#api/en/objects/Mesh). These meshes will be taken into account in operations like raycasting.
     */
    T(this, "meshes", /* @__PURE__ */ new Set());
    /** {@link Updateable.onAfterUpdate} */
    T(this, "onAfterUpdate", new j());
    /** {@link Updateable.onBeforeUpdate} */
    T(this, "onBeforeUpdate", new j());
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    /**
     * Indicates whether the world is currently being disposed. This is useful to prevent trying to access world's elements when it's being disposed, which could cause errors when you dispose a world.
     */
    T(this, "isDisposing", !1);
    /**
     * Indicates whether the world is currently enabled.
     * When disabled, the world will not be updated.
     */
    T(this, "enabled", !0);
    /**
     * A unique identifier for the world. Is not meant to be changed at any moment.
     */
    T(this, "uuid", me.create());
    /**
     * An optional name for the world.
     */
    T(this, "name");
    T(this, "_scene");
    T(this, "_camera");
    T(this, "_renderer", null);
  }
  /**
   * Getter for the scene. If no scene is initialized, it throws an error.
   * @returns The current scene.
   */
  get scene() {
    if (!this._scene)
      throw new Error("No scene initialized!");
    return this._scene;
  }
  /**
   * Setter for the scene. It sets the current scene, adds the world to the scene's worlds set,
   * sets the current world in the scene, and triggers the scene's onWorldChanged event with the added action.
   * @param scene - The new scene to be set.
   */
  set scene(t) {
    this._scene = t, t.worlds.set(this.uuid, this), t.currentWorld = this, t.onWorldChanged.trigger({ world: this, action: "added" });
  }
  /**
   * Getter for the camera. If no camera is initialized, it throws an error.
   * @returns The current camera.
   */
  get camera() {
    if (!this._camera)
      throw new Error("No camera initialized!");
    return this._camera;
  }
  /**
   * Setter for the camera. It sets the current camera, adds the world to the camera's worlds set,
   * sets the current world in the camera, and triggers the camera's onWorldChanged event with the added action.
   * @param camera - The new camera to be set.
   */
  set camera(t) {
    this._camera = t, t.worlds.set(this.uuid, this), t.currentWorld = this, t.onWorldChanged.trigger({ world: this, action: "added" });
  }
  /**
   * Getter for the renderer.
   * @returns The current renderer or null if no renderer is set. Some worlds don't need a renderer to work (when your mail goal is not to display a 3D viewport to the user).
   */
  get renderer() {
    return this._renderer;
  }
  /**
   * Setter for the renderer. It sets the current renderer, adds the world to the renderer's worlds set,
   * sets the current world in the renderer, and triggers the renderer's onWorldChanged event with the added action.
   * If a new renderer is set, it also triggers the onWorldChanged event with the removed action for the old renderer.
   * @param renderer - The new renderer to be set or null to remove the current renderer.
   */
  set renderer(t) {
    this._renderer = t, t && (t.worlds.set(this.uuid, this), t.currentWorld = this, t.onWorldChanged.trigger({ world: this, action: "added" }));
  }
  /** {@link Updateable.update} */
  update(t) {
    this.enabled && (!this._scene || !this._camera || (this.scene.currentWorld = this, this.camera.currentWorld = this, this.renderer && (this.renderer.currentWorld = this), this.onBeforeUpdate.trigger(), this.scene.isUpdateable() && this.scene.update(t), this.camera.isUpdateable() && this.camera.update(t), this.renderer && this.renderer.update(t), this.onAfterUpdate.trigger()));
  }
  /** {@link Disposable.dispose} */
  dispose(t = !0) {
    if (this.enabled = !1, this.isDisposing = !0, this.scene.onWorldChanged.trigger({ world: this, action: "removed" }), this.camera.onWorldChanged.trigger({ world: this, action: "removed" }), this.renderer && this.renderer.onWorldChanged.trigger({ world: this, action: "removed" }), t) {
      const i = this.components.get(Fe);
      this.scene.dispose(), this.camera.isDisposeable() && this.camera.dispose(), this.renderer && this.renderer.dispose();
      for (const n of this.meshes)
        i.destroy(n);
      this.meshes.clear();
    }
    this._scene = null, this._camera = null, this._renderer = null, this.components.get(hi).list.delete(this.uuid), this.onDisposed.trigger(), this.onDisposed.reset();
  }
}
class Ma extends _a {
  constructor(t) {
    super(t);
    /** {@link Configurable.isSetup} */
    T(this, "isSetup", !1);
    /**
     * The underlying Three.js scene object.
     * It is used to define the 3D space containing objects, lights, and cameras.
     */
    T(this, "three");
    /** {@link Configurable.onSetup} */
    T(this, "onSetup", new j());
    /**
     * Configuration interface for the {@link SimpleScene}.
     * Defines properties for directional and ambient lights.
     */
    T(this, "config", {
      directionalLight: {
        color: new M.Color("white"),
        intensity: 1.5,
        position: new M.Vector3(5, 10, 3)
      },
      ambientLight: {
        color: new M.Color("white"),
        intensity: 1
      }
    });
    this.three = new M.Scene(), this.three.background = new M.Color(2107698);
  }
  /** {@link Configurable.setup} */
  setup(t) {
    this.config = { ...this.config, ...t };
    const e = new M.DirectionalLight(
      this.config.directionalLight.color,
      this.config.directionalLight.intensity
    );
    e.position.copy(this.config.directionalLight.position);
    const i = new M.AmbientLight(
      this.config.ambientLight.color,
      this.config.ambientLight.intensity
    );
    this.three.add(e, i), this.directionalLights.set(e.uuid, e), this.ambientLights.set(i.uuid, i), this.isSetup = !0, this.onSetup.trigger(this);
  }
}
class vl extends Ta {
  /**
   * Constructor for the SimpleRenderer class.
   *
   * @param components - The components instance.
   * @param container - The HTML container where the THREE.js canvas will be rendered.
   * @param parameters - Optional parameters for the THREE.js WebGLRenderer.
   */
  constructor(t, e, i) {
    super(t);
    /**
     * Indicates whether the renderer is enabled. If it's not, it won't be updated.
     * Default is `true`.
     */
    T(this, "enabled", !0);
    /**
     * The HTML container of the THREE.js canvas where the scene is rendered.
     */
    T(this, "container");
    /**
     * The THREE.js WebGLRenderer instance.
     */
    T(this, "three");
    T(this, "_canvas");
    T(this, "_parameters");
    T(this, "_resizeObserver", null);
    T(this, "onContainerUpdated", new j());
    T(this, "_resizing", !1);
    /** {@link Resizeable.resize} */
    T(this, "resize", (t) => {
      if (this._resizing)
        return;
      this._resizing = !0, this.onContainerUpdated.trigger();
      const e = t ? t.x : this.container.clientWidth, i = t ? t.y : this.container.clientHeight;
      this.three.setSize(e, i), this.onResize.trigger(new M.Vector2(e, i)), this._resizing = !1;
    });
    T(this, "resizeEvent", () => {
      this.resize();
    });
    T(this, "onContextLost", (t) => {
      t.preventDefault(), this.enabled = !1;
    });
    T(this, "onContextBack", () => {
      this.three.setRenderTarget(null), this.three.dispose(), this.three = new M.WebGLRenderer({
        canvas: this._canvas,
        antialias: !0,
        alpha: !0,
        ...this._parameters
      }), this.enabled = !0;
    });
    this.container = e, this._parameters = i, this.three = new M.WebGLRenderer({
      antialias: !0,
      alpha: !0,
      ...i
    }), this.three.setPixelRatio(Math.min(window.devicePixelRatio, 2)), this.setupRenderer(), this.setupEvents(!0), this.resize(), this._canvas = this.three.domElement;
    const n = this.three.getContext(), { canvas: r } = n;
    r.addEventListener("webglcontextlost", this.onContextLost, !1), r.addEventListener("webglcontextrestored", this.onContextBack, !1);
  }
  /** {@link Updateable.update} */
  update() {
    if (!this.enabled || !this.currentWorld)
      return;
    this.onBeforeUpdate.trigger(this);
    const t = this.currentWorld.scene.three, e = this.currentWorld.camera.three;
    this.three.render(t, e), this.onAfterUpdate.trigger(this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = !1, this.setupEvents(!1), this.three.domElement.remove(), this.three.forceContextLoss(), this.three.dispose(), this.onResize.reset(), this.onAfterUpdate.reset(), this.onBeforeUpdate.reset(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /** {@link Resizeable.getSize}. */
  getSize() {
    return new M.Vector2(
      this.three.domElement.clientWidth,
      this.three.domElement.clientHeight
    );
  }
  /**
   * Sets up and manages the event listeners for the renderer.
   *
   * @param active - A boolean indicating whether to activate or deactivate the event listeners.
   *
   * @throws Will throw an error if the renderer does not have an HTML container.
   */
  setupEvents(t) {
    const e = this.three.domElement.parentElement;
    if (!e)
      throw new Error("This renderer needs to have an HTML container!");
    this._resizeObserver && (this._resizeObserver.disconnect(), this._resizeObserver = null), window.removeEventListener("resize", this.resizeEvent), t && (this._resizeObserver = new ResizeObserver(this.resizeEvent), this._resizeObserver.observe(e), window.addEventListener("resize", this.resizeEvent));
  }
  setupRenderer() {
    this.three.localClippingEnabled = !0, this.container && this.container.appendChild(this.three.domElement), this.onContainerUpdated.trigger();
  }
}
/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */
const ht = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
}, G = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  OFFSET: 4,
  DOLLY: 8,
  ZOOM: 16,
  TOUCH_ROTATE: 32,
  TOUCH_TRUCK: 64,
  TOUCH_OFFSET: 128,
  TOUCH_DOLLY: 256,
  TOUCH_ZOOM: 512,
  TOUCH_DOLLY_TRUCK: 1024,
  TOUCH_DOLLY_OFFSET: 2048,
  TOUCH_DOLLY_ROTATE: 4096,
  TOUCH_ZOOM_TRUCK: 8192,
  TOUCH_ZOOM_OFFSET: 16384,
  TOUCH_ZOOM_ROTATE: 32768
}), We = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function Oe(c) {
  return c.isPerspectiveCamera;
}
function Te(c) {
  return c.isOrthographicCamera;
}
const Xe = Math.PI * 2, sr = Math.PI / 2, Dr = 1e-5, us = Math.PI / 180;
function qt(c, s, t) {
  return Math.max(s, Math.min(t, c));
}
function Tt(c, s = Dr) {
  return Math.abs(c) < s;
}
function mt(c, s, t = Dr) {
  return Tt(c - s, t);
}
function ir(c, s) {
  return Math.round(c / s) * s;
}
function fs(c) {
  return isFinite(c) ? c : c < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
}
function ps(c) {
  return Math.abs(c) < Number.MAX_VALUE ? c : c * (1 / 0);
}
function Qs(c, s, t, e, i = 1 / 0, n) {
  e = Math.max(1e-4, e);
  const r = 2 / e, o = r * n, a = 1 / (1 + o + 0.48 * o * o + 0.235 * o * o * o);
  let l = c - s;
  const h = s, d = i * e;
  l = qt(l, -d, d), s = c - l;
  const u = (t.value + r * l) * n;
  t.value = (t.value - r * u) * a;
  let f = s + (l + u) * a;
  return h - c > 0 == f > h && (f = h, t.value = (f - h) / n), f;
}
function nr(c, s, t, e, i = 1 / 0, n, r) {
  e = Math.max(1e-4, e);
  const o = 2 / e, a = o * n, l = 1 / (1 + a + 0.48 * a * a + 0.235 * a * a * a);
  let h = s.x, d = s.y, u = s.z, f = c.x - h, E = c.y - d, p = c.z - u;
  const I = h, m = d, C = u, R = i * e, g = R * R, y = f * f + E * E + p * p;
  if (y > g) {
    const v = Math.sqrt(y);
    f = f / v * R, E = E / v * R, p = p / v * R;
  }
  h = c.x - f, d = c.y - E, u = c.z - p;
  const F = (t.x + o * f) * n, S = (t.y + o * E) * n, L = (t.z + o * p) * n;
  t.x = (t.x - o * F) * l, t.y = (t.y - o * S) * l, t.z = (t.z - o * L) * l, r.x = h + (f + F) * l, r.y = d + (E + S) * l, r.z = u + (p + L) * l;
  const N = I - c.x, x = m - c.y, k = C - c.z, w = r.x - I, P = r.y - m, _ = r.z - C;
  return N * w + x * P + k * _ > 0 && (r.x = I, r.y = m, r.z = C, t.x = (r.x - I) / n, t.y = (r.y - m) / n, t.z = (r.z - C) / n), r;
}
function Yi(c, s) {
  s.set(0, 0), c.forEach((t) => {
    s.x += t.clientX, s.y += t.clientY;
  }), s.x /= c.length, s.y /= c.length;
}
function Gi(c, s) {
  return Te(c) ? (console.warn(`${s} is not supported in OrthographicCamera`), !0) : !1;
}
class xa {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(s, t) {
    const e = this._listeners;
    e[s] === void 0 && (e[s] = []), e[s].indexOf(t) === -1 && e[s].push(t);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(s, t) {
    const e = this._listeners;
    return e[s] !== void 0 && e[s].indexOf(t) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(s, t) {
    const i = this._listeners[s];
    if (i !== void 0) {
      const n = i.indexOf(t);
      n !== -1 && i.splice(n, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(s) {
    if (!s) {
      this._listeners = {};
      return;
    }
    Array.isArray(this._listeners[s]) && (this._listeners[s].length = 0);
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(s) {
    const e = this._listeners[s.type];
    if (e !== void 0) {
      s.target = this;
      const i = e.slice(0);
      for (let n = 0, r = i.length; n < r; n++)
        i[n].call(this, s);
    }
  }
}
const va = "2.7.3", qs = 1 / 8, Ur = typeof window < "u", Da = Ur && /Mac/.test(navigator.platform), Ua = !(Ur && "PointerEvent" in window);
let lt, rr, Ks, Hi, kt, dt, Et, Ze, Es, ne, re, Ne, or, ar, Wt, ms, $e, cr, Wi, lr, Xi, Zi, Js;
class vt extends xa {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(s) {
    lt = s.THREE, rr = Object.freeze(new lt.Vector3(0, 0, 0)), Ks = Object.freeze(new lt.Vector3(0, 1, 0)), Hi = Object.freeze(new lt.Vector3(0, 0, 1)), kt = new lt.Vector2(), dt = new lt.Vector3(), Et = new lt.Vector3(), Ze = new lt.Vector3(), Es = new lt.Vector3(), ne = new lt.Vector3(), re = new lt.Vector3(), Ne = new lt.Vector3(), or = new lt.Vector3(), ar = new lt.Vector3(), Wt = new lt.Spherical(), ms = new lt.Spherical(), $e = new lt.Box3(), cr = new lt.Box3(), Wi = new lt.Sphere(), lr = new lt.Quaternion(), Xi = new lt.Quaternion(), Zi = new lt.Matrix4(), Js = new lt.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return G;
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(s, t) {
    super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = Number.EPSILON, this.maxDistance = 1 / 0, this.infinityDolly = !1, this.minZoom = 0.01, this.maxZoom = 1 / 0, this.smoothTime = 0.25, this.draggingSmoothTime = 0.125, this.maxSpeed = 1 / 0, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.dollyDragInverted = !1, this.truckSpeed = 2, this.dollyToCursor = !1, this.dragToOffset = !1, this.verticalDragToForward = !1, this.boundaryFriction = 0, this.restThreshold = 0.01, this.colliderMeshes = [], this.cancel = () => {
    }, this._enabled = !0, this._state = G.NONE, this._viewport = null, this._changedDolly = 0, this._changedZoom = 0, this._hasRested = !0, this._boundaryEnclosesCamera = !1, this._needsUpdate = !0, this._updatedLastTime = !1, this._elementRect = new DOMRect(), this._isDragging = !1, this._dragNeedsUpdate = !0, this._activePointers = [], this._lockedPointer = null, this._interactiveArea = new DOMRect(0, 0, 1, 1), this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._isUserControllingOffset = !1, this._isUserControllingZoom = !1, this._lastDollyDirection = We.NONE, this._thetaVelocity = { value: 0 }, this._phiVelocity = { value: 0 }, this._radiusVelocity = { value: 0 }, this._targetVelocity = new lt.Vector3(), this._focalOffsetVelocity = new lt.Vector3(), this._zoomVelocity = { value: 0 }, this._truckInternal = (g, y, F) => {
      let S, L;
      if (Oe(this._camera)) {
        const N = dt.copy(this._camera.position).sub(this._target), x = this._camera.getEffectiveFOV() * us, k = N.length() * Math.tan(x * 0.5);
        S = this.truckSpeed * g * k / this._elementRect.height, L = this.truckSpeed * y * k / this._elementRect.height;
      } else if (Te(this._camera)) {
        const N = this._camera;
        S = g * (N.right - N.left) / N.zoom / this._elementRect.width, L = y * (N.top - N.bottom) / N.zoom / this._elementRect.height;
      } else
        return;
      this.verticalDragToForward ? (F ? this.setFocalOffset(this._focalOffsetEnd.x + S, this._focalOffsetEnd.y, this._focalOffsetEnd.z, !0) : this.truck(S, 0, !0), this.forward(-L, !0)) : F ? this.setFocalOffset(this._focalOffsetEnd.x + S, this._focalOffsetEnd.y + L, this._focalOffsetEnd.z, !0) : this.truck(S, L, !0);
    }, this._rotateInternal = (g, y) => {
      const F = Xe * this.azimuthRotateSpeed * g / this._elementRect.height, S = Xe * this.polarRotateSpeed * y / this._elementRect.height;
      this.rotate(F, S, !0);
    }, this._dollyInternal = (g, y, F) => {
      const S = Math.pow(0.95, -g * this.dollySpeed), L = this._sphericalEnd.radius, N = this._sphericalEnd.radius * S, x = qt(N, this.minDistance, this.maxDistance), k = x - N;
      this.infinityDolly && this.dollyToCursor ? this._dollyToNoClamp(N, !0) : this.infinityDolly && !this.dollyToCursor ? (this.dollyInFixed(k, !0), this._dollyToNoClamp(x, !0)) : this._dollyToNoClamp(x, !0), this.dollyToCursor && (this._changedDolly += (this.infinityDolly ? N : x) - L, this._dollyControlCoord.set(y, F)), this._lastDollyDirection = Math.sign(-g);
    }, this._zoomInternal = (g, y, F) => {
      const S = Math.pow(0.95, g * this.dollySpeed), L = this._zoom, N = this._zoom * S;
      this.zoomTo(N, !0), this.dollyToCursor && (this._changedZoom += N - L, this._dollyControlCoord.set(y, F));
    }, typeof lt > "u" && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = s, this._yAxisUpSpace = new lt.Quaternion().setFromUnitVectors(this._camera.up, Ks), this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(), this._state = G.NONE, this._target = new lt.Vector3(), this._targetEnd = this._target.clone(), this._focalOffset = new lt.Vector3(), this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = new lt.Spherical().setFromVector3(dt.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._lastDistance = this._spherical.radius, this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._lastZoom = this._zoom, this._nearPlaneCorners = [
      new lt.Vector3(),
      new lt.Vector3(),
      new lt.Vector3(),
      new lt.Vector3()
    ], this._updateNearPlaneCorners(), this._boundary = new lt.Box3(new lt.Vector3(-1 / 0, -1 / 0, -1 / 0), new lt.Vector3(1 / 0, 1 / 0, 1 / 0)), this._cameraUp0 = this._camera.up.clone(), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlCoord = new lt.Vector2(), this.mouseButtons = {
      left: G.ROTATE,
      middle: G.DOLLY,
      right: G.TRUCK,
      wheel: Oe(this._camera) ? G.DOLLY : Te(this._camera) ? G.ZOOM : G.NONE
    }, this.touches = {
      one: G.TOUCH_ROTATE,
      two: Oe(this._camera) ? G.TOUCH_DOLLY_TRUCK : Te(this._camera) ? G.TOUCH_ZOOM_TRUCK : G.NONE,
      three: G.TOUCH_TRUCK
    };
    const e = new lt.Vector2(), i = new lt.Vector2(), n = new lt.Vector2(), r = (g) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const S = this._domElement.getBoundingClientRect(), L = g.clientX / S.width, N = g.clientY / S.height;
        if (L < this._interactiveArea.left || L > this._interactiveArea.right || N < this._interactiveArea.top || N > this._interactiveArea.bottom)
          return;
      }
      const y = g.pointerType !== "mouse" ? null : (g.buttons & ht.LEFT) === ht.LEFT ? ht.LEFT : (g.buttons & ht.MIDDLE) === ht.MIDDLE ? ht.MIDDLE : (g.buttons & ht.RIGHT) === ht.RIGHT ? ht.RIGHT : null;
      if (y !== null) {
        const S = this._findPointerByMouseButton(y);
        S && this._disposePointer(S);
      }
      if ((g.buttons & ht.LEFT) === ht.LEFT && this._lockedPointer)
        return;
      const F = {
        pointerId: g.pointerId,
        clientX: g.clientX,
        clientY: g.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: y
      };
      this._activePointers.push(F), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", h), this._domElement.ownerDocument.addEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", h), this._isDragging = !0, p(g);
    }, o = (g) => {
      if (!this._enabled || !this._domElement || this._lockedPointer)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const S = this._domElement.getBoundingClientRect(), L = g.clientX / S.width, N = g.clientY / S.height;
        if (L < this._interactiveArea.left || L > this._interactiveArea.right || N < this._interactiveArea.top || N > this._interactiveArea.bottom)
          return;
      }
      const y = (g.buttons & ht.LEFT) === ht.LEFT ? ht.LEFT : (g.buttons & ht.MIDDLE) === ht.MIDDLE ? ht.MIDDLE : (g.buttons & ht.RIGHT) === ht.RIGHT ? ht.RIGHT : null;
      if (y !== null) {
        const S = this._findPointerByMouseButton(y);
        S && this._disposePointer(S);
      }
      const F = {
        pointerId: 1,
        clientX: g.clientX,
        clientY: g.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: (g.buttons & ht.LEFT) === ht.LEFT ? ht.LEFT : (g.buttons & ht.MIDDLE) === ht.LEFT ? ht.MIDDLE : (g.buttons & ht.RIGHT) === ht.LEFT ? ht.RIGHT : null
      };
      this._activePointers.push(F), this._domElement.ownerDocument.removeEventListener("mousemove", l), this._domElement.ownerDocument.removeEventListener("mouseup", d), this._domElement.ownerDocument.addEventListener("mousemove", l), this._domElement.ownerDocument.addEventListener("mouseup", d), this._isDragging = !0, p(g);
    }, a = (g) => {
      g.cancelable && g.preventDefault();
      const y = g.pointerId, F = this._lockedPointer || this._findPointerById(y);
      if (F) {
        if (F.clientX = g.clientX, F.clientY = g.clientY, F.deltaX = g.movementX, F.deltaY = g.movementY, this._state = 0, g.pointerType === "touch")
          switch (this._activePointers.length) {
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          (!this._isDragging && this._lockedPointer || this._isDragging && (g.buttons & ht.LEFT) === ht.LEFT) && (this._state = this._state | this.mouseButtons.left), this._isDragging && (g.buttons & ht.MIDDLE) === ht.MIDDLE && (this._state = this._state | this.mouseButtons.middle), this._isDragging && (g.buttons & ht.RIGHT) === ht.RIGHT && (this._state = this._state | this.mouseButtons.right);
        I();
      }
    }, l = (g) => {
      const y = this._lockedPointer || this._findPointerById(1);
      y && (y.clientX = g.clientX, y.clientY = g.clientY, y.deltaX = g.movementX, y.deltaY = g.movementY, this._state = 0, (this._lockedPointer || (g.buttons & ht.LEFT) === ht.LEFT) && (this._state = this._state | this.mouseButtons.left), (g.buttons & ht.MIDDLE) === ht.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (g.buttons & ht.RIGHT) === ht.RIGHT && (this._state = this._state | this.mouseButtons.right), I());
    }, h = (g) => {
      const y = this._findPointerById(g.pointerId);
      if (!(y && y === this._lockedPointer)) {
        if (y && this._disposePointer(y), g.pointerType === "touch")
          switch (this._activePointers.length) {
            case 0:
              this._state = G.NONE;
              break;
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          this._state = G.NONE;
        m();
      }
    }, d = () => {
      const g = this._findPointerById(1);
      g && g === this._lockedPointer || (g && this._disposePointer(g), this._state = G.NONE, m());
    };
    let u = -1;
    const f = (g) => {
      if (!this._domElement || !this._enabled || this.mouseButtons.wheel === G.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const N = this._domElement.getBoundingClientRect(), x = g.clientX / N.width, k = g.clientY / N.height;
        if (x < this._interactiveArea.left || x > this._interactiveArea.right || k < this._interactiveArea.top || k > this._interactiveArea.bottom)
          return;
      }
      if (g.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === G.ROTATE || this.mouseButtons.wheel === G.TRUCK) {
        const N = performance.now();
        u - N < 1e3 && this._getClientRect(this._elementRect), u = N;
      }
      const y = Da ? -1 : -3, F = g.deltaMode === 1 ? g.deltaY / y : g.deltaY / (y * 10), S = this.dollyToCursor ? (g.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, L = this.dollyToCursor ? (g.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case G.ROTATE: {
          this._rotateInternal(g.deltaX, g.deltaY), this._isUserControllingRotate = !0;
          break;
        }
        case G.TRUCK: {
          this._truckInternal(g.deltaX, g.deltaY, !1), this._isUserControllingTruck = !0;
          break;
        }
        case G.OFFSET: {
          this._truckInternal(g.deltaX, g.deltaY, !0), this._isUserControllingOffset = !0;
          break;
        }
        case G.DOLLY: {
          this._dollyInternal(-F, S, L), this._isUserControllingDolly = !0;
          break;
        }
        case G.ZOOM: {
          this._zoomInternal(-F, S, L), this._isUserControllingZoom = !0;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    }, E = (g) => {
      if (!(!this._domElement || !this._enabled)) {
        if (this.mouseButtons.right === vt.ACTION.NONE) {
          const y = g instanceof PointerEvent ? g.pointerId : (g instanceof MouseEvent, 0), F = this._findPointerById(y);
          F && this._disposePointer(F), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", h), this._domElement.ownerDocument.removeEventListener("mousemove", l), this._domElement.ownerDocument.removeEventListener("mouseup", d);
          return;
        }
        g.preventDefault();
      }
    }, p = (g) => {
      if (!this._enabled)
        return;
      if (Yi(this._activePointers, kt), this._getClientRect(this._elementRect), e.copy(kt), i.copy(kt), this._activePointers.length >= 2) {
        const F = kt.x - this._activePointers[1].clientX, S = kt.y - this._activePointers[1].clientY, L = Math.sqrt(F * F + S * S);
        n.set(0, L);
        const N = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5, x = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        i.set(N, x);
      }
      if (this._state = 0, !g)
        this._lockedPointer && (this._state = this._state | this.mouseButtons.left);
      else if ("pointerType" in g && g.pointerType === "touch")
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      else
        !this._lockedPointer && (g.buttons & ht.LEFT) === ht.LEFT && (this._state = this._state | this.mouseButtons.left), (g.buttons & ht.MIDDLE) === ht.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (g.buttons & ht.RIGHT) === ht.RIGHT && (this._state = this._state | this.mouseButtons.right);
      ((this._state & G.ROTATE) === G.ROTATE || (this._state & G.TOUCH_ROTATE) === G.TOUCH_ROTATE || (this._state & G.TOUCH_DOLLY_ROTATE) === G.TOUCH_DOLLY_ROTATE || (this._state & G.TOUCH_ZOOM_ROTATE) === G.TOUCH_ZOOM_ROTATE) && (this._sphericalEnd.theta = this._spherical.theta, this._sphericalEnd.phi = this._spherical.phi, this._thetaVelocity.value = 0, this._phiVelocity.value = 0), ((this._state & G.TRUCK) === G.TRUCK || (this._state & G.TOUCH_TRUCK) === G.TOUCH_TRUCK || (this._state & G.TOUCH_DOLLY_TRUCK) === G.TOUCH_DOLLY_TRUCK || (this._state & G.TOUCH_ZOOM_TRUCK) === G.TOUCH_ZOOM_TRUCK) && (this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)), ((this._state & G.DOLLY) === G.DOLLY || (this._state & G.TOUCH_DOLLY) === G.TOUCH_DOLLY || (this._state & G.TOUCH_DOLLY_TRUCK) === G.TOUCH_DOLLY_TRUCK || (this._state & G.TOUCH_DOLLY_OFFSET) === G.TOUCH_DOLLY_OFFSET || (this._state & G.TOUCH_DOLLY_ROTATE) === G.TOUCH_DOLLY_ROTATE) && (this._sphericalEnd.radius = this._spherical.radius, this._radiusVelocity.value = 0), ((this._state & G.ZOOM) === G.ZOOM || (this._state & G.TOUCH_ZOOM) === G.TOUCH_ZOOM || (this._state & G.TOUCH_ZOOM_TRUCK) === G.TOUCH_ZOOM_TRUCK || (this._state & G.TOUCH_ZOOM_OFFSET) === G.TOUCH_ZOOM_OFFSET || (this._state & G.TOUCH_ZOOM_ROTATE) === G.TOUCH_ZOOM_ROTATE) && (this._zoomEnd = this._zoom, this._zoomVelocity.value = 0), ((this._state & G.OFFSET) === G.OFFSET || (this._state & G.TOUCH_OFFSET) === G.TOUCH_OFFSET || (this._state & G.TOUCH_DOLLY_OFFSET) === G.TOUCH_DOLLY_OFFSET || (this._state & G.TOUCH_ZOOM_OFFSET) === G.TOUCH_ZOOM_OFFSET) && (this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)), this.dispatchEvent({ type: "controlstart" });
    }, I = () => {
      if (!this._enabled || !this._dragNeedsUpdate)
        return;
      this._dragNeedsUpdate = !1, Yi(this._activePointers, kt);
      const y = this._domElement && document.pointerLockElement === this._domElement ? this._lockedPointer || this._activePointers[0] : null, F = y ? -y.deltaX : i.x - kt.x, S = y ? -y.deltaY : i.y - kt.y;
      if (i.copy(kt), ((this._state & G.ROTATE) === G.ROTATE || (this._state & G.TOUCH_ROTATE) === G.TOUCH_ROTATE || (this._state & G.TOUCH_DOLLY_ROTATE) === G.TOUCH_DOLLY_ROTATE || (this._state & G.TOUCH_ZOOM_ROTATE) === G.TOUCH_ZOOM_ROTATE) && (this._rotateInternal(F, S), this._isUserControllingRotate = !0), (this._state & G.DOLLY) === G.DOLLY || (this._state & G.ZOOM) === G.ZOOM) {
        const L = this.dollyToCursor ? (e.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, N = this.dollyToCursor ? (e.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0, x = this.dollyDragInverted ? -1 : 1;
        (this._state & G.DOLLY) === G.DOLLY ? (this._dollyInternal(x * S * qs, L, N), this._isUserControllingDolly = !0) : (this._zoomInternal(x * S * qs, L, N), this._isUserControllingZoom = !0);
      }
      if ((this._state & G.TOUCH_DOLLY) === G.TOUCH_DOLLY || (this._state & G.TOUCH_ZOOM) === G.TOUCH_ZOOM || (this._state & G.TOUCH_DOLLY_TRUCK) === G.TOUCH_DOLLY_TRUCK || (this._state & G.TOUCH_ZOOM_TRUCK) === G.TOUCH_ZOOM_TRUCK || (this._state & G.TOUCH_DOLLY_OFFSET) === G.TOUCH_DOLLY_OFFSET || (this._state & G.TOUCH_ZOOM_OFFSET) === G.TOUCH_ZOOM_OFFSET || (this._state & G.TOUCH_DOLLY_ROTATE) === G.TOUCH_DOLLY_ROTATE || (this._state & G.TOUCH_ZOOM_ROTATE) === G.TOUCH_ZOOM_ROTATE) {
        const L = kt.x - this._activePointers[1].clientX, N = kt.y - this._activePointers[1].clientY, x = Math.sqrt(L * L + N * N), k = n.y - x;
        n.set(0, x);
        const w = this.dollyToCursor ? (i.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, P = this.dollyToCursor ? (i.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        (this._state & G.TOUCH_DOLLY) === G.TOUCH_DOLLY || (this._state & G.TOUCH_DOLLY_ROTATE) === G.TOUCH_DOLLY_ROTATE || (this._state & G.TOUCH_DOLLY_TRUCK) === G.TOUCH_DOLLY_TRUCK || (this._state & G.TOUCH_DOLLY_OFFSET) === G.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(k * qs, w, P), this._isUserControllingDolly = !0) : (this._zoomInternal(k * qs, w, P), this._isUserControllingZoom = !0);
      }
      ((this._state & G.TRUCK) === G.TRUCK || (this._state & G.TOUCH_TRUCK) === G.TOUCH_TRUCK || (this._state & G.TOUCH_DOLLY_TRUCK) === G.TOUCH_DOLLY_TRUCK || (this._state & G.TOUCH_ZOOM_TRUCK) === G.TOUCH_ZOOM_TRUCK) && (this._truckInternal(F, S, !1), this._isUserControllingTruck = !0), ((this._state & G.OFFSET) === G.OFFSET || (this._state & G.TOUCH_OFFSET) === G.TOUCH_OFFSET || (this._state & G.TOUCH_DOLLY_OFFSET) === G.TOUCH_DOLLY_OFFSET || (this._state & G.TOUCH_ZOOM_OFFSET) === G.TOUCH_ZOOM_OFFSET) && (this._truckInternal(F, S, !0), this._isUserControllingOffset = !0), this.dispatchEvent({ type: "control" });
    }, m = () => {
      Yi(this._activePointers, kt), i.copy(kt), this._dragNeedsUpdate = !1, (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) && (this._isDragging = !1), this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("mousemove", l), this._domElement.ownerDocument.removeEventListener("pointerup", h), this._domElement.ownerDocument.removeEventListener("mouseup", d), this.dispatchEvent({ type: "controlend" }));
    };
    this.lockPointer = () => {
      !this._enabled || !this._domElement || (this.cancel(), this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      }, this._activePointers.push(this._lockedPointer), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", h), this._domElement.requestPointerLock(), this._domElement.ownerDocument.addEventListener("pointerlockchange", C), this._domElement.ownerDocument.addEventListener("pointerlockerror", R), this._domElement.ownerDocument.addEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", h), p());
    }, this.unlockPointer = () => {
      this._lockedPointer !== null && (this._disposePointer(this._lockedPointer), this._lockedPointer = null), document.exitPointerLock(), this.cancel(), this._domElement && (this._domElement.ownerDocument.removeEventListener("pointerlockchange", C), this._domElement.ownerDocument.removeEventListener("pointerlockerror", R));
    };
    const C = () => {
      this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement || this.unlockPointer();
    }, R = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (g) => {
      this._domElement = g, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", r), Ua && this._domElement.addEventListener("mousedown", o), this._domElement.addEventListener("pointercancel", h), this._domElement.addEventListener("wheel", f, { passive: !1 }), this._domElement.addEventListener("contextmenu", E);
    }, this._removeAllEventListeners = () => {
      this._domElement && (this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "", this._domElement.removeEventListener("pointerdown", r), this._domElement.removeEventListener("mousedown", o), this._domElement.removeEventListener("pointercancel", h), this._domElement.removeEventListener("wheel", f, { passive: !1 }), this._domElement.removeEventListener("contextmenu", E), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("mousemove", l), this._domElement.ownerDocument.removeEventListener("pointerup", h), this._domElement.ownerDocument.removeEventListener("mouseup", d), this._domElement.ownerDocument.removeEventListener("pointerlockchange", C), this._domElement.ownerDocument.removeEventListener("pointerlockerror", R));
    }, this.cancel = () => {
      this._state !== G.NONE && (this._state = G.NONE, this._activePointers.length = 0, m());
    }, t && this.connect(t), this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(s) {
    this._camera = s, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(s) {
    this._enabled = s, this._domElement && (s ? (this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none") : (this.cancel(), this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = ""));
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(s) {
    this._spherical.radius === s && this._sphericalEnd.radius === s || (this._spherical.radius = s, this._sphericalEnd.radius = s, this._needsUpdate = !0);
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(s) {
    this._spherical.theta === s && this._sphericalEnd.theta === s || (this._spherical.theta = s, this._sphericalEnd.theta = s, this._needsUpdate = !0);
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(s) {
    this._spherical.phi === s && this._sphericalEnd.phi === s || (this._spherical.phi = s, this._sphericalEnd.phi = s, this._needsUpdate = !0);
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(s) {
    this._boundaryEnclosesCamera = s, this._needsUpdate = !0;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(s) {
    this._interactiveArea.width = qt(s.width, 0, 1), this._interactiveArea.height = qt(s.height, 0, 1), this._interactiveArea.x = qt(s.x, 0, 1 - this._interactiveArea.width), this._interactiveArea.y = qt(s.y, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches.  |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera.  |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` . |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(s, t) {
    super.addEventListener(s, t);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(s, t) {
    super.removeEventListener(s, t);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(s, t, e = !1) {
    return this.rotateTo(this._sphericalEnd.theta + s, this._sphericalEnd.phi + t, e);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(s, t = !1) {
    return this.rotateTo(s, this._sphericalEnd.phi, t);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(s, t = !1) {
    return this.rotateTo(this._sphericalEnd.theta, s, t);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0
   *         \
   * 90 -----+----- -90
   *           \
   *           180
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0                     |
   * | left      | 90 (`Math.PI / 2`)    |
   * | right     | -90 (`- Math.PI / 2`) |
   * | back      | 180 (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180
   *      |
   *      90
   *      |
   *      0
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180 (`Math.PI`)       |
   * | horizontal from view | 90 (`Math.PI / 2`)    |
   * | bottom/floor         | 0                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(s, t, e = !1) {
    this._isUserControllingRotate = !1;
    const i = qt(s, this.minAzimuthAngle, this.maxAzimuthAngle), n = qt(t, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = i, this._sphericalEnd.phi = n, this._sphericalEnd.makeSafe(), this._needsUpdate = !0, e || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi);
    const r = !e || mt(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && mt(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(r);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(s, t = !1) {
    return this.dollyTo(this._sphericalEnd.radius - s, t);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(s, t = !1) {
    return this._isUserControllingDolly = !1, this._lastDollyDirection = We.NONE, this._changedDolly = 0, this._dollyToNoClamp(qt(s, this.minDistance, this.maxDistance), t);
  }
  _dollyToNoClamp(s, t = !1) {
    const e = this._sphericalEnd.radius;
    if (this.colliderMeshes.length >= 1) {
      const r = this._collisionTest(), o = mt(r, this._spherical.radius);
      if (!(e > s) && o)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(s, r);
    } else
      this._sphericalEnd.radius = s;
    this._needsUpdate = !0, t || (this._spherical.radius = this._sphericalEnd.radius);
    const n = !t || mt(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(n);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(s, t = !1) {
    this._targetEnd.add(this._getCameraDirection(Es).multiplyScalar(s)), t || this._target.copy(this._targetEnd);
    const e = !t || mt(this._target.x, this._targetEnd.x, this.restThreshold) && mt(this._target.y, this._targetEnd.y, this.restThreshold) && mt(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(e);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(s, t = !1) {
    return this.zoomTo(this._zoomEnd + s, t);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(s, t = !1) {
    this._isUserControllingZoom = !1, this._zoomEnd = qt(s, this.minZoom, this.maxZoom), this._needsUpdate = !0, t || (this._zoom = this._zoomEnd);
    const e = !t || mt(this._zoom, this._zoomEnd, this.restThreshold);
    return this._changedZoom = 0, this._createOnRestPromise(e);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(s, t, e = !1) {
    return console.warn("`pan` has been renamed to `truck`"), this.truck(s, t, e);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(s, t, e = !1) {
    this._camera.updateMatrix(), ne.setFromMatrixColumn(this._camera.matrix, 0), re.setFromMatrixColumn(this._camera.matrix, 1), ne.multiplyScalar(s), re.multiplyScalar(-t);
    const i = dt.copy(ne).add(re), n = Et.copy(this._targetEnd).add(i);
    return this.moveTo(n.x, n.y, n.z, e);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(s, t = !1) {
    dt.setFromMatrixColumn(this._camera.matrix, 0), dt.crossVectors(this._camera.up, dt), dt.multiplyScalar(s);
    const e = Et.copy(this._targetEnd).add(dt);
    return this.moveTo(e.x, e.y, e.z, t);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(s, t = !1) {
    return dt.copy(this._camera.up).multiplyScalar(s), this.moveTo(this._targetEnd.x + dt.x, this._targetEnd.y + dt.y, this._targetEnd.z + dt.z, t);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(s, t, e, i = !1) {
    this._isUserControllingTruck = !1;
    const n = dt.set(s, t, e).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, n, this.boundaryFriction), this._needsUpdate = !0, i || this._target.copy(this._targetEnd);
    const r = !i || mt(this._target.x, this._targetEnd.x, this.restThreshold) && mt(this._target.y, this._targetEnd.y, this.restThreshold) && mt(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(r);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(s, t, e, i = !1) {
    const o = dt.set(s, t, e).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius);
    return this.setPosition(o.x, o.y, o.z, i);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(s, t, { cover: e = !1, paddingLeft: i = 0, paddingRight: n = 0, paddingBottom: r = 0, paddingTop: o = 0 } = {}) {
    const a = [], l = s.isBox3 ? $e.copy(s) : $e.setFromObject(s);
    l.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"), Promise.resolve());
    const h = ir(this._sphericalEnd.theta, sr), d = ir(this._sphericalEnd.phi, sr);
    a.push(this.rotateTo(h, d, t));
    const u = dt.setFromSpherical(this._sphericalEnd).normalize(), f = lr.setFromUnitVectors(u, Hi), E = mt(Math.abs(u.y), 1);
    E && f.multiply(Xi.setFromAxisAngle(Ks, h)), f.multiply(this._yAxisUpSpaceInverse);
    const p = cr.makeEmpty();
    Et.copy(l.min).applyQuaternion(f), p.expandByPoint(Et), Et.copy(l.min).setX(l.max.x).applyQuaternion(f), p.expandByPoint(Et), Et.copy(l.min).setY(l.max.y).applyQuaternion(f), p.expandByPoint(Et), Et.copy(l.max).setZ(l.min.z).applyQuaternion(f), p.expandByPoint(Et), Et.copy(l.min).setZ(l.max.z).applyQuaternion(f), p.expandByPoint(Et), Et.copy(l.max).setY(l.min.y).applyQuaternion(f), p.expandByPoint(Et), Et.copy(l.max).setX(l.min.x).applyQuaternion(f), p.expandByPoint(Et), Et.copy(l.max).applyQuaternion(f), p.expandByPoint(Et), p.min.x -= i, p.min.y -= r, p.max.x += n, p.max.y += o, f.setFromUnitVectors(Hi, u), E && f.premultiply(Xi.invert()), f.premultiply(this._yAxisUpSpace);
    const I = p.getSize(dt), m = p.getCenter(Et).applyQuaternion(f);
    if (Oe(this._camera)) {
      const C = this.getDistanceToFitBox(I.x, I.y, I.z, e);
      a.push(this.moveTo(m.x, m.y, m.z, t)), a.push(this.dollyTo(C, t)), a.push(this.setFocalOffset(0, 0, 0, t));
    } else if (Te(this._camera)) {
      const C = this._camera, R = C.right - C.left, g = C.top - C.bottom, y = e ? Math.max(R / I.x, g / I.y) : Math.min(R / I.x, g / I.y);
      a.push(this.moveTo(m.x, m.y, m.z, t)), a.push(this.zoomTo(y, t)), a.push(this.setFocalOffset(0, 0, 0, t));
    }
    return Promise.all(a);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(s, t) {
    const e = [], n = s instanceof lt.Sphere ? Wi.copy(s) : vt.createBoundingSphere(s, Wi);
    if (e.push(this.moveTo(n.center.x, n.center.y, n.center.z, t)), Oe(this._camera)) {
      const r = this.getDistanceToFitSphere(n.radius);
      e.push(this.dollyTo(r, t));
    } else if (Te(this._camera)) {
      const r = this._camera.right - this._camera.left, o = this._camera.top - this._camera.bottom, a = 2 * n.radius, l = Math.min(r / a, o / a);
      e.push(this.zoomTo(l, t));
    }
    return e.push(this.setFocalOffset(0, 0, 0, t)), Promise.all(e);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(s, t, e, i, n, r, o = !1) {
    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = We.NONE, this._changedDolly = 0;
    const a = Et.set(i, n, r), l = dt.set(s, t, e);
    this._targetEnd.copy(a), this._sphericalEnd.setFromVector3(l.sub(a).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = !0, o || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const h = !o || mt(this._target.x, this._targetEnd.x, this.restThreshold) && mt(this._target.y, this._targetEnd.y, this.restThreshold) && mt(this._target.z, this._targetEnd.z, this.restThreshold) && mt(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && mt(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && mt(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(h);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(s, t, e, i, n, r, o, a, l, h, d, u, f, E = !1) {
    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = We.NONE, this._changedDolly = 0;
    const p = dt.set(i, n, r), I = Et.set(s, t, e);
    Wt.setFromVector3(I.sub(p).applyQuaternion(this._yAxisUpSpace));
    const m = Ze.set(h, d, u), C = Et.set(o, a, l);
    ms.setFromVector3(C.sub(m).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(p.lerp(m, f));
    const R = ms.theta - Wt.theta, g = ms.phi - Wt.phi, y = ms.radius - Wt.radius;
    this._sphericalEnd.set(Wt.radius + y * f, Wt.phi + g * f, Wt.theta + R * f), this.normalizeRotations(), this._needsUpdate = !0, E || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const F = !E || mt(this._target.x, this._targetEnd.x, this.restThreshold) && mt(this._target.y, this._targetEnd.y, this.restThreshold) && mt(this._target.z, this._targetEnd.z, this.restThreshold) && mt(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && mt(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && mt(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(F);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(s, t, e, i = !1) {
    return this.setLookAt(s, t, e, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, i);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(s, t, e, i = !1) {
    const n = this.getPosition(dt), r = this.setLookAt(n.x, n.y, n.z, s, t, e, i);
    return this._sphericalEnd.phi = qt(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle), r;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(s, t, e, i = !1) {
    this._isUserControllingOffset = !1, this._focalOffsetEnd.set(s, t, e), this._needsUpdate = !0, i || this._focalOffset.copy(this._focalOffsetEnd);
    const n = !i || mt(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && mt(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && mt(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(n);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(s, t, e) {
    this._camera.updateMatrixWorld(), ne.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), re.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), Ne.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const i = dt.set(s, t, e), n = i.distanceTo(this._camera.position), r = i.sub(this._camera.position);
    ne.multiplyScalar(r.x), re.multiplyScalar(r.y), Ne.multiplyScalar(r.z), dt.copy(ne).add(re).add(Ne), dt.z = dt.z + n, this.dollyTo(n, !1), this.setFocalOffset(-dt.x, dt.y, -dt.z, !1), this.moveTo(s, t, e, !1);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(s) {
    if (!s) {
      this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), this._needsUpdate = !0;
      return;
    }
    this._boundary.copy(s), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = !0;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(s, t, e, i) {
    if (s === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new lt.Vector4(), typeof s == "number" ? this._viewport.set(s, t, e, i) : this._viewport.copy(s);
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(s, t, e, i = !1) {
    if (Gi(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const n = s / t, r = this._camera.getEffectiveFOV() * us, o = this._camera.aspect;
    return ((i ? n > o : n < o) ? t : s / o) * 0.5 / Math.tan(r * 0.5) + e * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(s) {
    if (Gi(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const t = this._camera.getEffectiveFOV() * us, e = Math.atan(Math.tan(t * 0.5) * this._camera.aspect) * 2, i = 1 < this._camera.aspect ? t : e;
    return s / Math.sin(i * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(s, t = !0) {
    return (s && s.isVector3 ? s : new lt.Vector3()).copy(t ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(s, t = !0) {
    return (s && s.isVector3 ? s : new lt.Vector3()).setFromSpherical(t ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(t ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(s, t = !0) {
    return (s && s instanceof lt.Spherical ? s : new lt.Spherical()).copy(t ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(s, t = !0) {
    return (s && s.isVector3 ? s : new lt.Vector3()).copy(t ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % Xe, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += Xe), this._spherical.theta += Xe * Math.round((this._sphericalEnd.theta - this._spherical.theta) / Xe);
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(s = !1) {
    if (!mt(this._camera.up.x, this._cameraUp0.x) || !mt(this._camera.up.y, this._cameraUp0.y) || !mt(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const e = this.getPosition(dt);
      this.updateCameraUp(), this.setPosition(e.x, e.y, e.z);
    }
    const t = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, s),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, s),
      this.zoomTo(this._zoom0, s)
    ];
    return Promise.all(t);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up), this.getTarget(this._target0), this.getPosition(this._position0), this._zoom0 = this._zoom, this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, Ks), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const s = dt.subVectors(this._target, this._camera.position).normalize(), t = Et.crossVectors(s, this._camera.up);
    this._camera.up.crossVectors(t, s).normalize(), this._camera.updateMatrixWorld();
    const e = this.getPosition(dt);
    this.updateCameraUp(), this.setPosition(e.x, e.y, e.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(s) {
    const t = this._sphericalEnd.theta - this._spherical.theta, e = this._sphericalEnd.phi - this._spherical.phi, i = this._sphericalEnd.radius - this._spherical.radius, n = or.subVectors(this._targetEnd, this._target), r = ar.subVectors(this._focalOffsetEnd, this._focalOffset), o = this._zoomEnd - this._zoom;
    if (Tt(t))
      this._thetaVelocity.value = 0, this._spherical.theta = this._sphericalEnd.theta;
    else {
      const d = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = Qs(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, d, 1 / 0, s), this._needsUpdate = !0;
    }
    if (Tt(e))
      this._phiVelocity.value = 0, this._spherical.phi = this._sphericalEnd.phi;
    else {
      const d = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = Qs(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, d, 1 / 0, s), this._needsUpdate = !0;
    }
    if (Tt(i))
      this._radiusVelocity.value = 0, this._spherical.radius = this._sphericalEnd.radius;
    else {
      const d = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = Qs(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, d, this.maxSpeed, s), this._needsUpdate = !0;
    }
    if (Tt(n.x) && Tt(n.y) && Tt(n.z))
      this._targetVelocity.set(0, 0, 0), this._target.copy(this._targetEnd);
    else {
      const d = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      nr(this._target, this._targetEnd, this._targetVelocity, d, this.maxSpeed, s, this._target), this._needsUpdate = !0;
    }
    if (Tt(r.x) && Tt(r.y) && Tt(r.z))
      this._focalOffsetVelocity.set(0, 0, 0), this._focalOffset.copy(this._focalOffsetEnd);
    else {
      const d = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      nr(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, d, this.maxSpeed, s, this._focalOffset), this._needsUpdate = !0;
    }
    if (Tt(o))
      this._zoomVelocity.value = 0, this._zoom = this._zoomEnd;
    else {
      const d = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = Qs(this._zoom, this._zoomEnd, this._zoomVelocity, d, 1 / 0, s);
    }
    if (this.dollyToCursor) {
      if (Oe(this._camera) && this._changedDolly !== 0) {
        const d = this._spherical.radius - this._lastDistance, u = this._camera, f = this._getCameraDirection(Es), E = dt.copy(f).cross(u.up).normalize();
        E.lengthSq() === 0 && (E.x = 1);
        const p = Et.crossVectors(E, f), I = this._sphericalEnd.radius * Math.tan(u.getEffectiveFOV() * us * 0.5), C = (this._sphericalEnd.radius - d - this._sphericalEnd.radius) / this._sphericalEnd.radius, R = Ze.copy(this._targetEnd).add(E.multiplyScalar(this._dollyControlCoord.x * I * u.aspect)).add(p.multiplyScalar(this._dollyControlCoord.y * I)), g = dt.copy(this._targetEnd).lerp(R, C), y = this._lastDollyDirection === We.IN && this._spherical.radius <= this.minDistance, F = this._lastDollyDirection === We.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (y || F)) {
          this._sphericalEnd.radius -= d, this._spherical.radius -= d;
          const L = Et.copy(f).multiplyScalar(-d);
          g.add(L);
        }
        this._boundary.clampPoint(g, g);
        const S = Et.subVectors(g, this._targetEnd);
        this._targetEnd.copy(g), this._target.add(S), this._changedDolly -= d, Tt(this._changedDolly) && (this._changedDolly = 0);
      } else if (Te(this._camera) && this._changedZoom !== 0) {
        const d = this._zoom - this._lastZoom, u = this._camera, f = dt.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (u.near + u.far) / (u.near - u.far)).unproject(u), E = Et.set(0, 0, -1).applyQuaternion(u.quaternion), p = Ze.copy(f).add(E.multiplyScalar(-f.dot(u.up))), m = -(this._zoom - d - this._zoom) / this._zoom, C = this._getCameraDirection(Es), R = this._targetEnd.dot(C), g = dt.copy(this._targetEnd).lerp(p, m), y = g.dot(C), F = C.multiplyScalar(y - R);
        g.sub(F), this._boundary.clampPoint(g, g);
        const S = Et.subVectors(g, this._targetEnd);
        this._targetEnd.copy(g), this._target.add(S), this._changedZoom -= d, Tt(this._changedZoom) && (this._changedZoom = 0);
      }
    }
    this._camera.zoom !== this._zoom && (this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0), this._dragNeedsUpdate = !0;
    const a = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, a), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!Tt(this._focalOffset.x) || !Tt(this._focalOffset.y) || !Tt(this._focalOffset.z)) && (this._camera.updateMatrixWorld(), ne.setFromMatrixColumn(this._camera.matrix, 0), re.setFromMatrixColumn(this._camera.matrix, 1), Ne.setFromMatrixColumn(this._camera.matrix, 2), ne.multiplyScalar(this._focalOffset.x), re.multiplyScalar(-this._focalOffset.y), Ne.multiplyScalar(this._focalOffset.z), dt.copy(ne).add(re).add(Ne), this._camera.position.add(dt)), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), dt.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    const h = this._needsUpdate;
    return h && !this._updatedLastTime ? (this._hasRested = !1, this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : h ? (this.dispatchEvent({ type: "update" }), Tt(t, this.restThreshold) && Tt(e, this.restThreshold) && Tt(i, this.restThreshold) && Tt(n.x, this.restThreshold) && Tt(n.y, this.restThreshold) && Tt(n.z, this.restThreshold) && Tt(r.x, this.restThreshold) && Tt(r.y, this.restThreshold) && Tt(r.z, this.restThreshold) && Tt(o, this.restThreshold) && !this._hasRested && (this._hasRested = !0, this.dispatchEvent({ type: "rest" }))) : !h && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._lastDistance = this._spherical.radius, this._lastZoom = this._zoom, this._updatedLastTime = h, this._needsUpdate = !1, h;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: fs(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: fs(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: fs(this.maxPolarAngle),
      minAzimuthAngle: fs(this.minAzimuthAngle),
      maxAzimuthAngle: fs(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      verticalDragToForward: this.verticalDragToForward,
      target: this._targetEnd.toArray(),
      position: dt.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(s, t = !1) {
    const e = JSON.parse(s);
    this.enabled = e.enabled, this.minDistance = e.minDistance, this.maxDistance = ps(e.maxDistance), this.minZoom = e.minZoom, this.maxZoom = ps(e.maxZoom), this.minPolarAngle = e.minPolarAngle, this.maxPolarAngle = ps(e.maxPolarAngle), this.minAzimuthAngle = ps(e.minAzimuthAngle), this.maxAzimuthAngle = ps(e.maxAzimuthAngle), this.smoothTime = e.smoothTime, this.draggingSmoothTime = e.draggingSmoothTime, this.dollySpeed = e.dollySpeed, this.truckSpeed = e.truckSpeed, this.dollyToCursor = e.dollyToCursor, this.verticalDragToForward = e.verticalDragToForward, this._target0.fromArray(e.target0), this._position0.fromArray(e.position0), this._zoom0 = e.zoom0, this._focalOffset0.fromArray(e.focalOffset0), this.moveTo(e.target[0], e.target[1], e.target[2], t), Wt.setFromVector3(dt.fromArray(e.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(Wt.theta, Wt.phi, t), this.dollyTo(Wt.radius, t), this.zoomTo(e.zoom, t), this.setFocalOffset(e.focalOffset[0], e.focalOffset[1], e.focalOffset[2], t), this._needsUpdate = !0;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(s) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    s.setAttribute("data-camera-controls-version", va), this._addAllEventListeners(s), this._getClientRect(this._elementRect);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel(), this._removeAllEventListeners(), this._domElement && (this._domElement.removeAttribute("data-camera-controls-version"), this._domElement = void 0);
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners(), this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(s) {
    return s.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(s) {
    return this._getTargetDirection(s).negate();
  }
  _findPointerById(s) {
    return this._activePointers.find((t) => t.pointerId === s);
  }
  _findPointerByMouseButton(s) {
    return this._activePointers.find((t) => t.mouseButton === s);
  }
  _disposePointer(s) {
    this._activePointers.splice(this._activePointers.indexOf(s), 1);
  }
  _encloseToBoundary(s, t, e) {
    const i = t.lengthSq();
    if (i === 0)
      return s;
    const n = Et.copy(t).add(s), o = this._boundary.clampPoint(n, Ze).sub(n), a = o.lengthSq();
    if (a === 0)
      return s.add(t);
    if (a === i)
      return s;
    if (e === 0)
      return s.add(t).add(o);
    {
      const l = 1 + e * a / t.dot(o);
      return s.add(Et.copy(t).multiplyScalar(l)).add(o.multiplyScalar(1 - e));
    }
  }
  _updateNearPlaneCorners() {
    if (Oe(this._camera)) {
      const s = this._camera, t = s.near, e = s.getEffectiveFOV() * us, i = Math.tan(e * 0.5) * t, n = i * s.aspect;
      this._nearPlaneCorners[0].set(-n, -i, 0), this._nearPlaneCorners[1].set(n, -i, 0), this._nearPlaneCorners[2].set(n, i, 0), this._nearPlaneCorners[3].set(-n, i, 0);
    } else if (Te(this._camera)) {
      const s = this._camera, t = 1 / s.zoom, e = s.left * t, i = s.right * t, n = s.top * t, r = s.bottom * t;
      this._nearPlaneCorners[0].set(e, n, 0), this._nearPlaneCorners[1].set(i, n, 0), this._nearPlaneCorners[2].set(i, r, 0), this._nearPlaneCorners[3].set(e, r, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let s = 1 / 0;
    if (!(this.colliderMeshes.length >= 1) || Gi(this._camera, "_collisionTest"))
      return s;
    const e = this._getTargetDirection(Es);
    Zi.lookAt(rr, e, this._camera.up);
    for (let i = 0; i < 4; i++) {
      const n = Et.copy(this._nearPlaneCorners[i]);
      n.applyMatrix4(Zi);
      const r = Ze.addVectors(this._target, n);
      Js.set(r, e), Js.far = this._spherical.radius + 1;
      const o = Js.intersectObjects(this.colliderMeshes);
      o.length !== 0 && o[0].distance < s && (s = o[0].distance);
    }
    return s;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(s) {
    if (!this._domElement)
      return;
    const t = this._domElement.getBoundingClientRect();
    return s.x = t.left, s.y = t.top, this._viewport ? (s.x += this._viewport.x, s.y += t.height - this._viewport.w - this._viewport.y, s.width = this._viewport.z, s.height = this._viewport.w) : (s.width = t.width, s.height = t.height), s;
  }
  _createOnRestPromise(s) {
    return s ? Promise.resolve() : (this._hasRested = !1, this.dispatchEvent({ type: "transitionstart" }), new Promise((t) => {
      const e = () => {
        this.removeEventListener("rest", e), t();
      };
      this.addEventListener("rest", e);
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(s) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(s) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(s) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(s, t = new lt.Sphere()) {
    const e = t, i = e.center;
    $e.makeEmpty(), s.traverseVisible((r) => {
      r.isMesh && $e.expandByObject(r);
    }), $e.getCenter(i);
    let n = 0;
    return s.traverseVisible((r) => {
      if (!r.isMesh)
        return;
      const o = r, a = o.geometry.clone();
      a.applyMatrix4(o.matrixWorld);
      const h = a.attributes.position;
      for (let d = 0, u = h.count; d < u; d++)
        dt.fromBufferAttribute(h, d), n = Math.max(n, i.distanceToSquared(dt));
    }), e.radius = Math.sqrt(n), e;
  }
}
class Ns extends Ca {
  constructor(t) {
    super(t);
    /** {@link Updateable.onBeforeUpdate} */
    T(this, "onBeforeUpdate", new j());
    /** {@link Updateable.onAfterUpdate} */
    T(this, "onAfterUpdate", new j());
    /**
     * Event that is triggered when the aspect of the camera has been updated.
     * This event is useful when you need to perform actions after the aspect of the camera has been changed.
     */
    T(this, "onAspectUpdated", new j());
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    /**
     * A three.js PerspectiveCamera or OrthographicCamera instance.
     * This camera is used for rendering the scene.
     */
    T(this, "three");
    T(this, "_allControls", /* @__PURE__ */ new Map());
    /**
     * Updates the aspect of the camera to match the size of the
     * {@link Components.renderer}.
     */
    T(this, "updateAspect", () => {
      var t;
      if (!(!this.currentWorld || !this.currentWorld.renderer)) {
        if (this.three instanceof M.OrthographicCamera) {
          this.onAspectUpdated.trigger();
          return;
        }
        if ((t = this.currentWorld.renderer) != null && t.isResizeable()) {
          const e = this.currentWorld.renderer.getSize();
          this.three.aspect = e.width / e.height, this.three.updateProjectionMatrix(), this.onAspectUpdated.trigger();
        }
      }
    });
    this.three = this.setupCamera(), this.setupEvents(!0), this.onWorldChanged.add(({ action: e, world: i }) => {
      if (e === "added") {
        const n = this.newCameraControls();
        this._allControls.set(i.uuid, n);
      }
      if (e === "removed") {
        const n = this._allControls.get(i.uuid);
        n && (n.dispose(), this._allControls.delete(i.uuid));
      }
    });
  }
  /**
   * The object that controls the camera. An instance of
   * [yomotsu's cameracontrols](https://github.com/yomotsu/camera-controls).
   * Transforming the camera directly will have no effect: you need to use this
   * object to move, rotate, look at objects, etc.
   */
  get controls() {
    if (!this.currentWorld)
      throw new Error("This camera needs a world to work!");
    const t = this._allControls.get(this.currentWorld.uuid);
    if (!t)
      throw new Error("Controls not found!");
    return t;
  }
  /**
   * Getter for the enabled state of the camera controls.
   * If the current world is null, it returns false.
   * Otherwise, it returns the enabled state of the camera controls.
   *
   * @returns {boolean} The enabled state of the camera controls.
   */
  get enabled() {
    return this.currentWorld === null ? !1 : this.controls.enabled;
  }
  /**
   * Setter for the enabled state of the camera controls.
   * If the current world is not null, it sets the enabled state of the camera controls to the provided value.
   *
   * @param {boolean} enabled - The new enabled state of the camera controls.
   */
  set enabled(t) {
    this.currentWorld !== null && (this.controls.enabled = t);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(!1), this.onAspectUpdated.reset(), this.onBeforeUpdate.reset(), this.onAfterUpdate.reset(), this.three.removeFromParent(), this.onDisposed.trigger(), this.onDisposed.reset();
    for (const [t, e] of this._allControls)
      e.dispose();
  }
  /** {@link Updateable.update} */
  update(t) {
    this.enabled && (this.onBeforeUpdate.trigger(this), this.controls.update(t), this.onAfterUpdate.trigger(this));
  }
  setupCamera() {
    const t = window.innerWidth / window.innerHeight, e = new M.PerspectiveCamera(60, t, 1, 1e3);
    return e.position.set(50, 50, 50), e.lookAt(new M.Vector3(0, 0, 0)), e;
  }
  newCameraControls() {
    if (!this.currentWorld)
      throw new Error("This camera needs a world to work!");
    if (!this.currentWorld.renderer)
      throw new Error("This camera needs a renderer to work!");
    vt.install({ THREE: Ns.getSubsetOfThree() });
    const { domElement: t } = this.currentWorld.renderer.three, e = new vt(this.three, t);
    return e.smoothTime = 0.2, e.dollyToCursor = !0, e.infinityDolly = !0, e.minDistance = 6, e;
  }
  setupEvents(t) {
    t ? window.addEventListener("resize", this.updateAspect) : window.removeEventListener("resize", this.updateAspect);
  }
  static getSubsetOfThree() {
    return {
      MOUSE: M.MOUSE,
      Vector2: M.Vector2,
      Vector3: M.Vector3,
      Vector4: M.Vector4,
      Quaternion: M.Quaternion,
      Matrix4: M.Matrix4,
      Spherical: M.Spherical,
      Box3: M.Box3,
      Sphere: M.Sphere,
      Raycaster: M.Raycaster,
      MathUtils: M.MathUtils
    };
  }
}
const fi = class fi extends St {
  constructor(t) {
    super(t);
    /** {@link Updateable.onAfterUpdate} */
    T(this, "onAfterUpdate", new j());
    /** {@link Updateable.onBeforeUpdate} */
    T(this, "onBeforeUpdate", new j());
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    /**
     * A collection of worlds managed by this component.
     * The key is the unique identifier (UUID) of the world, and the value is the World instance.
     */
    T(this, "list", new Ee());
    /** {@link Component.enabled} */
    T(this, "enabled", !0);
    t.add(fi.uuid, this);
  }
  /**
   * Creates a new instance of a SimpleWorld and adds it to the list of worlds.
   *
   * @template T - The type of the scene, extending from BaseScene. Defaults to BaseScene.
   * @template U - The type of the camera, extending from BaseCamera. Defaults to BaseCamera.
   * @template S - The type of the renderer, extending from BaseRenderer. Defaults to BaseRenderer.
   *
   * @throws {Error} - Throws an error if a world with the same UUID already exists in the list.
   */
  create() {
    const t = new La(this.components), e = t.uuid;
    if (this.list.has(e))
      throw new Error("There is already a world with this name!");
    return this.list.set(e, t), t;
  }
  /**
   * Deletes a world from the list of worlds.
   *
   * @param {World} world - The world to be deleted.
   *
   * @throws {Error} - Throws an error if the provided world is not found in the list.
   */
  delete(t) {
    if (!this.list.has(t.uuid))
      throw new Error("The provided world is not found in the list!");
    this.list.delete(t.uuid), t.dispose();
  }
  /**
   * Disposes of the Worlds component and all its managed worlds.
   * This method sets the enabled flag to false, disposes of all worlds, clears the list,
   * and triggers the onDisposed event.
   */
  dispose() {
    this.enabled = !1;
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger();
  }
  /** {@link Updateable.update} */
  update(t) {
    if (this.enabled)
      for (const [e, i] of this.list)
        i.update(t);
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
T(fi, "uuid", "fdb61dc4-2ec1-4966-b83d-54ea795fad4a");
let hi = fi;
function Ba(c, s, t, e) {
  return new Promise((i, n) => {
    function r() {
      const o = c.clientWaitSync(s, t, 0);
      if (o === c.WAIT_FAILED) {
        n();
        return;
      }
      if (o === c.TIMEOUT_EXPIRED) {
        setTimeout(r, e);
        return;
      }
      i();
    }
    r();
  });
}
async function za(c, s, t, e, i, n, r) {
  const o = c.fenceSync(c.SYNC_GPU_COMMANDS_COMPLETE, 0);
  c.flush(), await Ba(c, o, 0, 10), c.deleteSync(o), c.bindBuffer(s, t), c.getBufferSubData(s, e, i, n, r), c.bindBuffer(s, null);
}
async function Br(c, s, t, e, i, n, r, o) {
  const a = c.createBuffer();
  return c.bindBuffer(c.PIXEL_PACK_BUFFER, a), c.bufferData(c.PIXEL_PACK_BUFFER, o.byteLength, c.STREAM_READ), c.readPixels(s, t, e, i, n, r, 0), c.bindBuffer(c.PIXEL_PACK_BUFFER, null), await za(c, c.PIXEL_PACK_BUFFER, a, 0, o), c.deleteBuffer(a), o;
}
class ka {
  constructor(s, t, e) {
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    /**
     * Fires after making the visibility check to the meshes. It lists the
     * meshes that are currently visible, and the ones that were visible
     * just before but not anymore.
     */
    T(this, "onViewUpdated", new oi());
    /**
     * Whether this renderer is active or not. If not, it won't render anything.
     */
    T(this, "enabled", !0);
    /**
     * Needs to check whether there are objects that need to be hidden or shown.
     * You can bind this to the camera movement, to a certain interval, etc.
     */
    T(this, "needsUpdate", !1);
    /**
     * Render the internal scene used to determine the object visibility. Used
     * for debugging purposes.
     */
    T(this, "renderDebugFrame", !1);
    /** The components instance to which this renderer belongs. */
    T(this, "components");
    /** The world instance to which this renderer belongs. */
    T(this, "world");
    /** The THREE.js renderer used to make the visibility test. */
    T(this, "renderer");
    T(this, "autoUpdate", !0);
    T(this, "updateInterval", 1e3);
    T(this, "worker");
    T(this, "scene", new M.Scene());
    T(this, "_width", 512);
    T(this, "_height", 512);
    T(this, "_availableColor", 1);
    T(this, "renderTarget");
    T(this, "bufferSize");
    T(this, "_buffer");
    // Prevents worker being fired multiple times
    T(this, "_isWorkerBusy", !1);
    /**
     * The function that the culler uses to reprocess the scene. Generally it's
     * better to call needsUpdate, but you can also call this to force it.
     * @param force if true, it will refresh the scene even if needsUpdate is
     * not true.
     */
    T(this, "updateVisibility", async (s) => {
      if (!this.enabled || !this.needsUpdate && !s || this._isWorkerBusy)
        return;
      this._isWorkerBusy = !0;
      const t = this.world.camera.three;
      t.updateMatrix(), this.renderer.setSize(this._width, this._height), this.renderer.setRenderTarget(this.renderTarget), this.renderer.render(this.scene, t);
      const e = this.renderer.getContext();
      try {
        await Br(
          e,
          0,
          0,
          this._width,
          this._height,
          e.RGBA,
          e.UNSIGNED_BYTE,
          this._buffer
        );
      } catch {
        this.needsUpdate = !1, this._isWorkerBusy = !1, this.renderer.setRenderTarget(null);
        return;
      }
      this.renderer.setRenderTarget(null), this.renderDebugFrame && this.renderer.render(this.scene, t), this.worker.postMessage({
        buffer: this._buffer
      }), this.needsUpdate = !1;
    });
    if (!t.renderer)
      throw new Error("The given world must have a renderer!");
    this.components = s, this.applySettings(e), this.world = t, this.renderer = new M.WebGLRenderer(), this.renderTarget = new M.WebGLRenderTarget(this._width, this._height), this.bufferSize = this._width * this._height * 4, this._buffer = new Uint8Array(this.bufferSize), this.renderer.clippingPlanes = t.renderer.clippingPlanes;
    const i = `
      addEventListener("message", (event) => {
        const { buffer } = event.data;
        const colors = new Map();
        for (let i = 0; i < buffer.length; i += 4) {
          const r = buffer[i];
          const g = buffer[i + 1];
          const b = buffer[i + 2];
          const code = "" + r + "-" + g + "-" + b;
          if(colors.has(code)) {
            colors.set(code, colors.get(code) + 1);
          } else {
            colors.set(code, 1);
          }
        }
        postMessage({ colors });
      });
    `, n = new Blob([i], { type: "application/javascript" });
    this.worker = new Worker(URL.createObjectURL(n));
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = !1;
    for (const s of this.scene.children)
      s.removeFromParent();
    this.onViewUpdated.reset(), this.worker.terminate(), this.renderer.forceContextLoss(), this.renderer.dispose(), this.renderTarget.dispose(), this._buffer = null, this.onDisposed.reset();
  }
  getAvailableColor() {
    let s = BigInt(this._availableColor.toString());
    const t = [];
    do
      t.unshift(Number(s % 256n)), s /= 256n;
    while (s);
    for (; t.length !== 3; )
      t.unshift(0);
    const [e, i, n] = t, r = `${e}-${i}-${n}`;
    return { r: e, g: i, b: n, code: r };
  }
  increaseColor() {
    if (this._availableColor === 256 * 256 * 256) {
      console.warn("Color can't be increased over 256 x 256 x 256!");
      return;
    }
    this._availableColor++;
  }
  decreaseColor() {
    if (this._availableColor === 1) {
      console.warn("Color can't be decreased under 0!");
      return;
    }
    this._availableColor--;
  }
  applySettings(s) {
    s && (s.updateInterval !== void 0 && (this.updateInterval = s.updateInterval), s.height !== void 0 && (this._height = s.height), s.width !== void 0 && (this._width = s.width), s.autoUpdate !== void 0 && (this.autoUpdate = s.autoUpdate));
  }
}
class Va extends ka {
  constructor(t, e, i) {
    super(t, e, i);
    /**
     * Event triggered when the visibility of meshes is updated.
     * Contains two sets: seen and unseen.
     */
    T(this, "onViewUpdated", new j());
    /**
     * Pixels in screen a geometry must occupy to be considered "seen".
     * Default value is 100.
     */
    T(this, "threshold", 100);
    /**
     * Map of color code to THREE.InstancedMesh.
     * Used to keep track of color-coded meshes.
     */
    T(this, "colorMeshes", /* @__PURE__ */ new Map());
    /**
     * Flag to indicate if the renderer is currently processing.
     * Used to prevent concurrent processing.
     */
    T(this, "isProcessing", !1);
    T(this, "_interval", null);
    T(this, "_colorCodeMeshMap", /* @__PURE__ */ new Map());
    T(this, "_meshIDColorCodeMap", /* @__PURE__ */ new Map());
    T(this, "_currentVisibleMeshes", /* @__PURE__ */ new Set());
    T(this, "_recentlyHiddenMeshes", /* @__PURE__ */ new Set());
    T(this, "_intervalID", null);
    T(this, "_transparentMat", new M.MeshBasicMaterial({
      transparent: !0,
      opacity: 0
    }));
    T(this, "handleWorkerMessage", async (t) => {
      if (this.isProcessing)
        return;
      const e = t.data.colors;
      this._recentlyHiddenMeshes = new Set(this._currentVisibleMeshes), this._currentVisibleMeshes.clear();
      for (const [i, n] of e) {
        if (n < this.threshold)
          continue;
        const r = this._colorCodeMeshMap.get(i);
        r && (this._currentVisibleMeshes.add(r), this._recentlyHiddenMeshes.delete(r));
      }
      this.onViewUpdated.trigger({
        seen: this._currentVisibleMeshes,
        unseen: this._recentlyHiddenMeshes
      }), this._isWorkerBusy = !1;
    });
    this.worker.addEventListener("message", this.handleWorkerMessage), this.autoUpdate && (this._interval = window.setInterval(async () => {
      this.isProcessing || await this.updateVisibility();
    }, this.updateInterval)), this.onViewUpdated.add(({ seen: n, unseen: r }) => {
      for (const o of n)
        o.visible = !0;
      for (const o of r)
        o.visible = !1;
    });
  }
  /** {@link Disposable.dispose} */
  dispose() {
    super.dispose(), this._intervalID !== null && (window.clearInterval(this._intervalID), this._intervalID = null), this._interval !== null && (window.clearInterval(this._interval), this._intervalID = null), this._currentVisibleMeshes.clear(), this._recentlyHiddenMeshes.clear(), this._meshIDColorCodeMap.clear(), this._transparentMat.dispose(), this._colorCodeMeshMap.clear();
    const t = this.components.get(Fe);
    for (const e in this.colorMeshes) {
      const i = this.colorMeshes.get(e);
      i && t.destroy(i, !0);
    }
    this.colorMeshes.clear();
  }
  /**
   * Adds a mesh to the culler. When the mesh is not visibile anymore, it will be removed from the scene. When it's visible again, it will be added to the scene.
   * @param mesh - The mesh to add. It can be a regular THREE.Mesh or an instance of THREE.InstancedMesh.
   * @returns {void}
   */
  add(t) {
    if (!this.enabled)
      return;
    if (this.isProcessing) {
      console.log("Culler processing not finished yet.");
      return;
    }
    this.isProcessing = !0;
    const e = t instanceof M.InstancedMesh, { geometry: i, material: n } = t, { colorMaterial: r, code: o } = this.getAvailableMaterial();
    let a;
    if (Array.isArray(n)) {
      let d = !0;
      const u = [];
      for (const f of n)
        er.isTransparent(f) ? u.push(this._transparentMat) : (d = !1, u.push(r));
      if (d) {
        r.dispose(), this.isProcessing = !1;
        return;
      }
      a = u;
    } else if (er.isTransparent(n)) {
      r.dispose(), this.isProcessing = !1;
      return;
    } else
      a = r;
    this._colorCodeMeshMap.set(o, t), this._meshIDColorCodeMap.set(t.uuid, o);
    const l = e ? t.count : 1, h = new M.InstancedMesh(i, a, l);
    e ? h.instanceMatrix = t.instanceMatrix : h.setMatrixAt(0, new M.Matrix4()), t.visible = !1, t.updateWorldMatrix(!0, !1), h.applyMatrix4(t.matrixWorld), h.updateMatrix(), this.scene.add(h), this.colorMeshes.set(t.uuid, h), this.increaseColor(), this.isProcessing = !1;
  }
  /**
   * Removes a mesh from the culler, so its visibility is not controlled by the culler anymore.
   * When the mesh is removed, it will be hidden from the scene and its color-coded mesh will be destroyed.
   * @param mesh - The mesh to remove. It can be a regular THREE.Mesh or an instance of THREE.InstancedMesh.
   * @returns {void}
   */
  remove(t) {
    if (this.isProcessing) {
      console.log("Culler processing not finished yet.");
      return;
    }
    this.isProcessing = !0;
    const e = this.components.get(Fe);
    this._currentVisibleMeshes.delete(t), this._recentlyHiddenMeshes.delete(t);
    const i = this.colorMeshes.get(t.uuid), n = this._meshIDColorCodeMap.get(t.uuid);
    if (!i || !n) {
      this.isProcessing = !1;
      return;
    }
    this._colorCodeMeshMap.delete(n), this._meshIDColorCodeMap.delete(t.uuid), this.colorMeshes.delete(t.uuid), i.geometry = void 0, i.material = [], e.destroy(i, !0), this._recentlyHiddenMeshes.delete(t), this._currentVisibleMeshes.delete(t), this.isProcessing = !1;
  }
  /**
   * Updates the given instanced meshes inside the culler. You should use this if you change the count property, e.g. when changing the visibility of fragments.
   *
   * @param meshes - The meshes to update.
   *
   * @returns {void}
   */
  updateInstanced(t) {
    for (const e of t) {
      const i = this.colorMeshes.get(e.uuid);
      i && (i.count = e.count);
    }
  }
  getAvailableMaterial() {
    const { r: t, g: e, b: i, code: n } = this.getAvailableColor(), r = M.ColorManagement.enabled;
    M.ColorManagement.enabled = !1;
    const o = new M.Color(`rgb(${t}, ${e}, ${i})`);
    if (!this.world.renderer)
      throw new Error("Renderer not found in the world!");
    const a = this.world.renderer.clippingPlanes, l = new M.MeshBasicMaterial({
      color: o,
      clippingPlanes: a,
      side: M.DoubleSide
    });
    return M.ColorManagement.enabled = r, { colorMaterial: l, code: n };
  }
}
const ws = class ws extends St {
  constructor(t) {
    super(t);
    /**
     * An event that is triggered when the Cullers component is disposed.
     */
    T(this, "onDisposed", new j());
    T(this, "_enabled", !0);
    /**
     * A map of MeshCullerRenderer instances, keyed by their world UUIDs.
     */
    T(this, "list", /* @__PURE__ */ new Map());
    t.add(ws.uuid, this);
  }
  /** {@link Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link Component.enabled} */
  set enabled(t) {
    this._enabled = t;
    for (const [e, i] of this.list)
      i.enabled = t;
  }
  /**
   * Creates a new MeshCullerRenderer for the given world.
   * If a MeshCullerRenderer already exists for the world, it will return the existing one.
   *
   * @param world - The world for which to create the MeshCullerRenderer.
   * @param config - Optional configuration settings for the MeshCullerRenderer.
   *
   * @returns The newly created or existing MeshCullerRenderer for the given world.
   */
  create(t, e) {
    if (this.list.has(t.uuid))
      return this.list.get(t.uuid);
    const i = new Va(this.components, t, e);
    return this.list.set(t.uuid, i), i;
  }
  /**
   * Deletes the MeshCullerRenderer associated with the given world.
   * If a MeshCullerRenderer exists for the given world, it will be disposed and removed from the list.
   *
   * @param world - The world for which to delete the MeshCullerRenderer.
   *
   * @returns {void}
   */
  delete(t) {
    const e = this.list.get(t.uuid);
    e && e.dispose(), this.list.delete(t.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = !1, this.onDisposed.trigger(ws.uuid), this.onDisposed.reset();
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear();
  }
  /**
   * Updates the given instanced meshes inside the all the cullers. You should use this if you change the count property, e.g. when changing the visibility of fragments.
   *
   * @param meshes - The meshes to update.
   *
   * @returns {void}
   */
  updateInstanced(t) {
    for (const [, e] of this.list)
      e.updateInstanced(t);
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
T(ws, "uuid", "69f2a50d-c266-44fc-b1bd-fa4d34be89e6");
let cn = ws;
class Ya {
  constructor(s, t) {
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    /**
     * Fires after making the visibility check to the meshes. It lists the
     * meshes that are currently visible, and the ones that were visible
     * just before but not anymore.
     */
    T(this, "onDistanceComputed", new j());
    /**
     * Objects that won't be taken into account in the distance check.
     */
    T(this, "excludedObjects", /* @__PURE__ */ new Set());
    /**
     * Whether this renderer is active or not. If not, it won't render anything.
     */
    T(this, "enabled", !0);
    /**
     * Render the internal scene used to determine the object visibility. Used
     * for debugging purposes.
     */
    T(this, "renderDebugFrame", !1);
    /** The components instance to which this renderer belongs. */
    T(this, "components");
    /**
     * The scene where the distance is computed.
     */
    T(this, "scene", new M.Scene());
    /**
     * The camera used to compute the distance.
     */
    T(this, "camera", new M.OrthographicCamera(-1, 1, 1, -1, 0, 1));
    /**
     * The material used to compute the distance.
     */
    T(this, "depthMaterial");
    /** The world instance to which this renderer belongs. */
    T(this, "world");
    /** The THREE.js renderer used to make the visibility test. */
    T(this, "renderer");
    T(this, "worker");
    T(this, "_width", 512);
    T(this, "_height", 512);
    T(this, "_postQuad");
    T(this, "tempRT");
    T(this, "resultRT");
    T(this, "bufferSize");
    T(this, "_buffer");
    // Prevents worker being fired multiple times
    T(this, "_isWorkerBusy", !1);
    /**
     * The function that the culler uses to reprocess the scene. Generally it's
     * better to call needsUpdate, but you can also call this to force it.
     * @param force if true, it will refresh the scene even if needsUpdate is
     * not true.
     */
    T(this, "compute", async () => {
      if (!this.enabled || this.world.isDisposing || this._isWorkerBusy)
        return;
      this._isWorkerBusy = !0, this.world.camera.three.updateMatrix(), this.renderer.setSize(this._width, this._height), this.renderer.setRenderTarget(this.tempRT);
      const s = "visibilityBeforeDistanceCheck";
      for (const e of this.excludedObjects)
        e.userData[s] = e.visible, e.visible = !1;
      this.renderer.render(this.world.scene.three, this.world.camera.three);
      for (const e of this.excludedObjects)
        e.userData[s] !== void 0 && (e.visible = e.userData[s]);
      this.depthMaterial.uniforms.tDiffuse.value = this.tempRT.texture, this.depthMaterial.uniforms.tDepth.value = this.tempRT.depthTexture, this.renderer.setRenderTarget(this.resultRT), this.renderer.render(this.scene, this.camera);
      const t = this.renderer.getContext();
      try {
        await Br(
          t,
          0,
          0,
          this._width,
          this._height,
          t.RGBA,
          t.UNSIGNED_BYTE,
          this._buffer
        );
      } catch {
        this.renderer.setRenderTarget(null), this._isWorkerBusy = !1;
        return;
      }
      this.renderer.setRenderTarget(null), this.renderDebugFrame && this.renderer.render(this.scene, this.camera), this.worker.postMessage({
        buffer: this._buffer
      });
    });
    T(this, "handleWorkerMessage", (s) => {
      if (!this.enabled || this.world.isDisposing)
        return;
      const t = s.data.colors;
      let e = Number.MAX_VALUE;
      for (const a of t)
        a !== 0 && a < e && (e = a);
      const i = this.world.camera.three || M.OrthographicCamera, r = (e / 255 - 1) * -1 * (i.far - i.near), o = Math.min(r, i.far);
      this.onDistanceComputed.trigger(o), this._isWorkerBusy = !1;
    });
    if (!t.renderer)
      throw new Error("The given world must have a renderer!");
    this.components = s, this.world = t;
    const e = t.camera.three;
    this.renderer = new M.WebGLRenderer(), this.tempRT = new M.WebGLRenderTarget(this._width, this._height), this.bufferSize = this._width * this._height * 4, this._buffer = new Uint8Array(this.bufferSize), this.tempRT.texture.minFilter = M.NearestFilter, this.tempRT.texture.magFilter = M.NearestFilter, this.tempRT.stencilBuffer = !1, this.tempRT.samples = 0, this.tempRT.depthTexture = new M.DepthTexture(
      this._width,
      this._height
    ), this.tempRT.depthTexture.format = M.DepthFormat, this.tempRT.depthTexture.type = M.UnsignedShortType, this.resultRT = new M.WebGLRenderTarget(this._width, this._height), this.depthMaterial = new M.ShaderMaterial({
      vertexShader: `
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
    `,
      fragmentShader: `
#include <packing>

varying vec2 vUv;
uniform sampler2D tDiffuse;
uniform sampler2D tDepth;
uniform float cameraNear;
uniform float cameraFar;


float readDepth( sampler2D depthSampler, vec2 coord ) {
  float fragCoordZ = texture2D( depthSampler, coord ).x;
  float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
  return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );
}

void main() {
  //vec3 diffuse = texture2D( tDiffuse, vUv ).rgb;
  float depth = readDepth( tDepth, vUv );

  gl_FragColor.rgb = 1.0 - vec3( depth );
  gl_FragColor.a = 1.0;
}
    `,
      uniforms: {
        cameraNear: { value: e.near },
        cameraFar: { value: e.far },
        tDiffuse: { value: null },
        tDepth: { value: null }
      }
    });
    const i = new M.PlaneGeometry(2, 2);
    this._postQuad = new M.Mesh(i, this.depthMaterial), this.scene.add(this._postQuad), this.renderer.clippingPlanes = t.renderer.clippingPlanes;
    const n = `
      addEventListener("message", (event) => {
        const { buffer } = event.data;
        const colors = new Set();
        for (let i = 0; i < buffer.length; i += 4) {
          const r = buffer[i];
          colors.add(r);
        }
        postMessage({ colors });
      });
    `, r = new Blob([n], { type: "application/javascript" });
    this.worker = new Worker(URL.createObjectURL(r)), this.worker.addEventListener("message", this.handleWorkerMessage);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = !1, this.onDistanceComputed.reset(), this.worker.terminate(), this.renderer.forceContextLoss(), this.renderer.dispose(), this.tempRT.dispose(), this.resultRT.dispose();
    const s = [...this.scene.children];
    this.excludedObjects.clear();
    for (const t of s)
      t.removeFromParent();
    this._postQuad.geometry.dispose(), this._postQuad.removeFromParent(), this._buffer = null, this.onDisposed.reset();
  }
}
class Dl extends Ma {
  constructor() {
    super(...arguments);
    T(this, "_distanceRenderer");
    /**
     * Whether the bias property should be set automatically depending on the shadow distance.
     */
    T(this, "autoBias", !0);
    /**
     * Configuration interface for the {@link ShadowedScene}.
     * Defines properties for directional and ambient lights, as well as shadows.
     */
    T(this, "config", {
      directionalLight: {
        color: new M.Color("white"),
        intensity: 1.5,
        position: new M.Vector3(5, 10, 3)
      },
      ambientLight: {
        color: new M.Color("white"),
        intensity: 1
      },
      shadows: {
        cascade: 1,
        resolution: 512
      }
    });
    T(this, "_lightsWithShadow", /* @__PURE__ */ new Map());
    T(this, "_isComputingShadows", !1);
    T(this, "_shadowsEnabled", !0);
    T(this, "_bias", 0);
    T(this, "recomputeShadows", (t) => {
      if (!this._shadowsEnabled)
        return;
      if (this.autoBias && (this.bias = t / -1e5), t *= 1.5, !this.currentWorld)
        throw new Error(
          "A world needs to be assigned to the scene before computing shadows!"
        );
      if (!this._lightsWithShadow.size)
        throw new Error("No shadows found!");
      const i = this.currentWorld.camera.three;
      if (!(i instanceof M.PerspectiveCamera) && !(i instanceof M.OrthographicCamera))
        throw new Error("Invalid camera type!");
      const n = new M.Vector3();
      i.getWorldDirection(n);
      let r = t;
      const o = new M.Vector3();
      o.copy(this.config.directionalLight.position), o.normalize();
      for (const [a, l] of this._lightsWithShadow) {
        const h = this.directionalLights.get(l);
        if (!h)
          throw new Error("Light not found.");
        const d = new M.Vector3();
        d.copy(n);
        const u = a === this._lightsWithShadow.size - 1, f = u ? r / 2 : r * 2 / 3;
        d.multiplyScalar(f), d.add(i.position);
        const E = r - f, p = new M.Vector3();
        p.copy(o), p.multiplyScalar(E), h.target.position.copy(d), h.position.copy(d), h.position.add(p), h.shadow.camera.right = E, h.shadow.camera.left = -E, h.shadow.camera.top = E, h.shadow.camera.bottom = -E, h.shadow.camera.far = E * 2, h.shadow.camera.updateProjectionMatrix(), h.shadow.camera.updateMatrix(), u || (r /= 3);
      }
      this._isComputingShadows = !1;
    });
  }
  /**
   * The getter for the bias to prevent artifacts (stripes). It usually ranges between 0 and -0.005.
   */
  get bias() {
    return this._bias;
  }
  /**
   * The setter for the bias to prevent artifacts (stripes). It usually ranges between 0 and -0.005.
   */
  set bias(t) {
    this._bias = t;
    for (const [, e] of this._lightsWithShadow) {
      const i = this.directionalLights.get(e);
      i && (i.shadow.bias = t);
    }
  }
  /**
   * Getter to see whether the shadows are enabled or not in this scene instance.
   */
  get shadowsEnabled() {
    return this._shadowsEnabled;
  }
  /**
   * Setter to control whether the shadows are enabled or not in this scene instance.
   */
  set shadowsEnabled(t) {
    this._shadowsEnabled = t;
    for (const [, e] of this.directionalLights)
      e.castShadow = t;
  }
  /**
   * Getter to get the renderer used to determine the farthest distance from the camera.
   */
  get distanceRenderer() {
    if (!this._distanceRenderer)
      throw new Error(
        "You must set up this component before accessing the distance renderer!"
      );
    return this._distanceRenderer;
  }
  /** {@link Configurable.setup} */
  setup(t) {
    if (super.setup(t), this.config = { ...this.config, ...t }, this.config.shadows.cascade <= 0)
      throw new Error(
        "Config.shadows.cascade must be a natural number greater than 0!"
      );
    if (this.config.shadows.cascade > 1)
      throw new Error("Multiple shadows not supported yet!");
    if (!this.currentWorld)
      throw new Error(
        "A world needs to be assigned to the scene before setting it up!"
      );
    for (const [, e] of this.directionalLights)
      e.target.removeFromParent(), e.removeFromParent(), e.dispose();
    this.directionalLights.clear(), this._distanceRenderer || (this._distanceRenderer = new Ya(
      this.components,
      this.currentWorld
    ), this._distanceRenderer.onDistanceComputed.add(this.recomputeShadows)), this._lightsWithShadow.clear();
    for (let e = 0; e < this.config.shadows.cascade; e++) {
      const i = new M.DirectionalLight();
      i.intensity = this.config.directionalLight.intensity, i.color = this.config.directionalLight.color, i.position.copy(this.config.directionalLight.position), i.shadow.mapSize.width = this.config.shadows.resolution, i.shadow.mapSize.height = this.config.shadows.resolution, this.three.add(i, i.target), this.directionalLights.set(i.uuid, i), this._lightsWithShadow.set(e, i.uuid), i.castShadow = !0, i.shadow.bias = this._bias;
    }
  }
  /** {@link Disposable.dispose} */
  dispose() {
    super.dispose(), this._distanceRenderer && this._distanceRenderer.dispose(), this._lightsWithShadow.clear();
  }
  /** Update all the shadows of the scene. */
  async updateShadows() {
    this._isComputingShadows || !this._shadowsEnabled || (this._isComputingShadows = !0, await this.distanceRenderer.compute());
  }
}
class Ga {
  constructor(s) {
    T(this, "_event");
    T(this, "_position", new M.Vector2());
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    T(this, "updateMouseInfo", (s) => {
      this._event = s;
    });
    this.dom = s, this.setupEvents(!0);
  }
  /**
   * The real position of the mouse of the Three.js canvas.
   */
  get position() {
    if (this._event) {
      const s = this.dom.getBoundingClientRect();
      this._position.x = this.getPositionX(s, this._event), this._position.y = this.getPositionY(s, this._event);
    }
    return this._position;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(!1), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  getPositionY(s, t) {
    return -((t.clientY - s.top) / (s.bottom - s.top)) * 2 + 1;
  }
  getPositionX(s, t) {
    return (t.clientX - s.left) / (s.right - s.left) * 2 - 1;
  }
  setupEvents(s) {
    s ? this.dom.addEventListener("pointermove", this.updateMouseInfo) : this.dom.removeEventListener("pointermove", this.updateMouseInfo);
  }
}
class Ha {
  constructor(s, t) {
    /** {@link Component.enabled} */
    T(this, "enabled", !0);
    /** The components instance to which this Raycaster belongs. */
    T(this, "components");
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    /** The position of the mouse in the screen. */
    T(this, "mouse");
    /**
     * A reference to the Three.js Raycaster instance.
     * This is used for raycasting operations.
     */
    T(this, "three", new M.Raycaster());
    /**
     * A reference to the world instance to which this Raycaster belongs.
     * This is used to access the camera and meshes.
     */
    T(this, "world");
    const e = t.renderer;
    if (!e)
      throw new Error("A renderer is needed for the raycaster to work!");
    this.world = t, this.mouse = new Ga(e.three.domElement), this.components = s;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.mouse.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Throws a ray from the camera to the mouse or touch event point and returns
   * the first item found. This also takes into account the clipping planes
   * used by the renderer.
   *
   * @param items - the [meshes](https://threejs.org/docs/#api/en/objects/Mesh)
   * to query. If not provided, it will query all the meshes stored in
   * {@link Components.meshes}.
   */
  castRay(s = Array.from(this.world.meshes)) {
    if (!this.world)
      throw new Error("A world is needed to cast rays!");
    const t = this.world.camera.three;
    return this.three.setFromCamera(this.mouse.position, t), this.intersect(s);
  }
  /**
   * Casts a ray from a given origin in a given direction and returns the first item found.
   * This method also takes into account the clipping planes used by the renderer.
   *
   * @param origin - The origin of the ray.
   * @param direction - The direction of the ray.
   * @param items - The meshes to query. If not provided, it will query all the meshes stored in {@link World.meshes}.
   * @returns The first intersection found or `null` if no intersection was found.
   */
  castRayFromVector(s, t, e = Array.from(this.world.meshes)) {
    return this.three.set(s, t), this.intersect(e);
  }
  intersect(s = Array.from(this.world.meshes)) {
    const t = this.three.intersectObjects(s), e = this.filterClippingPlanes(t);
    return e.length > 0 ? e[0] : null;
  }
  filterClippingPlanes(s) {
    if (!this.world.renderer)
      throw new Error("Renderer not found!");
    const t = this.world.renderer.three;
    if (!t.clippingPlanes)
      return s;
    const e = t.clippingPlanes;
    return s.length <= 0 || !e || (e == null ? void 0 : e.length) <= 0 ? s : s.filter(
      (i) => e.every((n) => n.distanceToPoint(i.point) > 0)
    );
  }
}
const pi = class pi extends St {
  constructor(t) {
    super(t);
    /** {@link Component.enabled} */
    T(this, "enabled", !0);
    /**
     * A Map that stores raycasters for each world.
     * The key is the world's UUID, and the value is the corresponding SimpleRaycaster instance.
     */
    T(this, "list", /* @__PURE__ */ new Map());
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    t.add(pi.uuid, this);
  }
  /**
   * Retrieves a SimpleRaycaster instance for the given world.
   * If a SimpleRaycaster instance already exists for the world, it will be returned.
   * Otherwise, a new SimpleRaycaster instance will be created and added to the list.
   *
   * @param world - The world for which to retrieve or create a SimpleRaycaster instance.
   * @returns The SimpleRaycaster instance for the given world.
   */
  get(t) {
    if (this.list.has(t.uuid))
      return this.list.get(t.uuid);
    const e = new Ha(this.components, t);
    return this.list.set(t.uuid, e), t.onDisposed.add(() => {
      this.delete(t);
    }), e;
  }
  /**
   * Deletes the SimpleRaycaster instance associated with the given world.
   * If a SimpleRaycaster instance exists for the given world, it will be disposed and removed from the list.
   *
   * @param world - The world for which to delete the SimpleRaycaster instance.
   * @returns {void}
   */
  delete(t) {
    const e = this.list.get(t.uuid);
    e && e.dispose(), this.list.delete(t.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger();
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
T(pi, "uuid", "d5d8bdf0-db25-4952-b951-b643af207ace");
let ts = pi;
class Wa {
  constructor(s, t, e) {
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    /** The world instance to which this Raycaster belongs. */
    T(this, "world");
    /** The components instance to which this grid belongs. */
    T(this, "components");
    /** The Three.js mesh that contains the infinite grid. */
    T(this, "three");
    T(this, "_fade", 3);
    T(this, "updateZoom", () => {
      this.world.camera instanceof Ns && (this.material.uniforms.uZoom.value = this.world.camera.three.zoom);
    });
    this.world = t;
    const { color: i, size1: n, size2: r, distance: o } = e;
    this.components = s;
    const a = new M.PlaneGeometry(2, 2, 1, 1), l = new M.ShaderMaterial({
      side: M.DoubleSide,
      uniforms: {
        uSize1: {
          value: n
        },
        uSize2: {
          value: r
        },
        uColor: {
          value: i
        },
        uDistance: {
          value: o
        },
        uFade: {
          value: this._fade
        },
        uZoom: {
          value: 1
        }
      },
      transparent: !0,
      vertexShader: `
            
            varying vec3 worldPosition;
            
            uniform float uDistance;
            
            void main() {
            
                    vec3 pos = position.xzy * uDistance;
                    pos.xz += cameraPosition.xz;
                    
                    worldPosition = pos;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            
            }
            `,
      fragmentShader: `
            
            varying vec3 worldPosition;
            
            uniform float uZoom;
            uniform float uFade;
            uniform float uSize1;
            uniform float uSize2;
            uniform vec3 uColor;
            uniform float uDistance;
                
                
                
                float getGrid(float size) {
                
                    vec2 r = worldPosition.xz / size;
                    
                    
                    vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);
                    float line = min(grid.x, grid.y);
                    
                
                    return 1.0 - min(line, 1.0);
                }
                
            void main() {
            
                    
                    float d = 1.0 - min(distance(cameraPosition.xz, worldPosition.xz) / uDistance, 1.0);
                    
                    float g1 = getGrid(uSize1);
                    float g2 = getGrid(uSize2);
                    
                    // Ortho camera fades the grid away when zooming out
                    float minZoom = step(0.2, uZoom);
                    float zoomFactor = pow(min(uZoom, 1.), 2.) * minZoom;
                    
                    gl_FragColor = vec4(uColor.rgb, mix(g2, g1, g1) * pow(d, uFade));
                    gl_FragColor.a = mix(0.5 * gl_FragColor.a, gl_FragColor.a, g2) * zoomFactor;
                    
                    if ( gl_FragColor.a <= 0.0 ) discard;
                    
            
            }
            
            `,
      extensions: {
        derivatives: !0
      }
    });
    this.three = new M.Mesh(a, l), this.three.frustumCulled = !1, t.scene.three.add(this.three), this.setupEvents(!0);
  }
  /** {@link Hideable.visible} */
  get visible() {
    return this.three.visible;
  }
  /** {@link Hideable.visible} */
  set visible(s) {
    s ? this.world.scene.three.add(this.three) : this.three.removeFromParent();
  }
  /** The material of the grid. */
  get material() {
    return this.three.material;
  }
  /**
   * Whether the grid should fade away with distance. Recommended to be true for
   * perspective cameras and false for orthographic cameras.
   */
  get fade() {
    return this._fade === 3;
  }
  /**
   * Whether the grid should fade away with distance. Recommended to be true for
   * perspective cameras and false for orthographic cameras.
   */
  set fade(s) {
    this._fade = s ? 3 : 0, this.material.uniforms.uFade.value = this._fade;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(!1), this.components.get(Fe).destroy(this.three), this.onDisposed.trigger(), this.onDisposed.reset(), this.world = null, this.components = null;
  }
  setupEvents(s) {
    if (this.world.isDisposing || !(this.world.camera instanceof Ns))
      return;
    const t = this.world.camera.controls;
    s ? t.addEventListener("update", this.updateZoom) : t.removeEventListener("update", this.updateZoom);
  }
}
const Ei = class Ei extends St {
  constructor(t) {
    super(t);
    /**
     * A map of world UUIDs to their corresponding grid instances.
     */
    T(this, "list", /* @__PURE__ */ new Map());
    /**
     * The default configuration for grid creation.
     */
    T(this, "config", {
      color: new M.Color(12303291),
      size1: 1,
      size2: 10,
      distance: 500
    });
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    /** {@link Component.enabled} */
    T(this, "enabled", !0);
    t.add(Ei.uuid, this);
  }
  /**
   * Creates a new grid for the given world.
   * Throws an error if a grid already exists for the world.
   *
   * @param world - The world to create the grid for.
   * @returns The newly created grid.
   *
   * @throws Will throw an error if a grid already exists for the given world.
   */
  create(t) {
    if (this.list.has(t.uuid))
      throw new Error("This world already has a grid!");
    const e = new Wa(this.components, t, this.config);
    return this.list.set(t.uuid, e), t.onDisposed.add(() => {
      this.delete(t);
    }), e;
  }
  /**
   * Deletes the grid associated with the given world.
   * If a grid does not exist for the given world, this method does nothing.
   *
   * @param world - The world for which to delete the grid.
   *
   * @remarks
   * This method will dispose of the grid and remove it from the internal list.
   * If the world is disposed before calling this method, the grid will be automatically deleted.
   */
  delete(t) {
    const e = this.list.get(t.uuid);
    e && e.dispose(), this.list.delete(t.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
T(Ei, "uuid", "d1e814d5-b81c-4452-87a2-f039375e0489");
let hr = Ei;
const be = new ao(), xt = new q(), Ce = new q(), yt = new le(), dr = {
  X: new q(1, 0, 0),
  Y: new q(0, 1, 0),
  Z: new q(0, 0, 1)
}, $i = { type: "change" }, ur = { type: "mouseDown" }, fr = { type: "mouseUp", mode: null }, pr = { type: "objectChange" };
class Xa extends Qi {
  constructor(s, t) {
    super(), t === void 0 && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'), t = document), this.isTransformControls = !0, this.visible = !1, this.domElement = t, this.domElement.style.touchAction = "none";
    const e = new Ka();
    this._gizmo = e, this.add(e);
    const i = new Ja();
    this._plane = i, this.add(i);
    const n = this;
    function r(C, R) {
      let g = R;
      Object.defineProperty(n, C, {
        get: function() {
          return g !== void 0 ? g : R;
        },
        set: function(y) {
          g !== y && (g = y, i[C] = y, e[C] = y, n.dispatchEvent({ type: C + "-changed", value: y }), n.dispatchEvent($i));
        }
      }), n[C] = R, i[C] = R, e[C] = R;
    }
    r("camera", s), r("object", void 0), r("enabled", !0), r("axis", null), r("mode", "translate"), r("translationSnap", null), r("rotationSnap", null), r("scaleSnap", null), r("space", "world"), r("size", 1), r("dragging", !1), r("showX", !0), r("showY", !0), r("showZ", !0);
    const o = new q(), a = new q(), l = new le(), h = new le(), d = new q(), u = new le(), f = new q(), E = new q(), p = new q(), I = 0, m = new q();
    r("worldPosition", o), r("worldPositionStart", a), r("worldQuaternion", l), r("worldQuaternionStart", h), r("cameraPosition", d), r("cameraQuaternion", u), r("pointStart", f), r("pointEnd", E), r("rotationAxis", p), r("rotationAngle", I), r("eye", m), this._offset = new q(), this._startNorm = new q(), this._endNorm = new q(), this._cameraScale = new q(), this._parentPosition = new q(), this._parentQuaternion = new le(), this._parentQuaternionInv = new le(), this._parentScale = new q(), this._worldScaleStart = new q(), this._worldQuaternionInv = new le(), this._worldScale = new q(), this._positionStart = new q(), this._quaternionStart = new le(), this._scaleStart = new q(), this._getPointer = Za.bind(this), this._onPointerDown = ja.bind(this), this._onPointerHover = $a.bind(this), this._onPointerMove = Qa.bind(this), this._onPointerUp = qa.bind(this), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  // updateMatrixWorld  updates key transformation variables
  updateMatrixWorld() {
    this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale), this._parentQuaternionInv.copy(this._parentQuaternion).invert(), this._worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale), this.camera.isOrthographicCamera ? this.camera.getWorldDirection(this.eye).negate() : this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld(this);
  }
  pointerHover(s) {
    if (this.object === void 0 || this.dragging === !0)
      return;
    be.setFromCamera(s, this.camera);
    const t = ji(this._gizmo.picker[this.mode], be);
    t ? this.axis = t.object.name : this.axis = null;
  }
  pointerDown(s) {
    if (!(this.object === void 0 || this.dragging === !0 || s.button !== 0) && this.axis !== null) {
      be.setFromCamera(s, this.camera);
      const t = ji(this._plane, be, !0);
      t && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(t.point).sub(this.worldPositionStart)), this.dragging = !0, ur.mode = this.mode, this.dispatchEvent(ur);
    }
  }
  pointerMove(s) {
    const t = this.axis, e = this.mode, i = this.object;
    let n = this.space;
    if (e === "scale" ? n = "local" : (t === "E" || t === "XYZE" || t === "XYZ") && (n = "world"), i === void 0 || t === null || this.dragging === !1 || s.button !== -1)
      return;
    be.setFromCamera(s, this.camera);
    const r = ji(this._plane, be, !0);
    if (r) {
      if (this.pointEnd.copy(r.point).sub(this.worldPositionStart), e === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), n === "local" && t !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), t.indexOf("X") === -1 && (this._offset.x = 0), t.indexOf("Y") === -1 && (this._offset.y = 0), t.indexOf("Z") === -1 && (this._offset.z = 0), n === "local" && t !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), i.position.copy(this._offset).add(this._positionStart), this.translationSnap && (n === "local" && (i.position.applyQuaternion(yt.copy(this._quaternionStart).invert()), t.search("X") !== -1 && (i.position.x = Math.round(i.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (i.position.y = Math.round(i.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (i.position.z = Math.round(i.position.z / this.translationSnap) * this.translationSnap), i.position.applyQuaternion(this._quaternionStart)), n === "world" && (i.parent && i.position.add(xt.setFromMatrixPosition(i.parent.matrixWorld)), t.search("X") !== -1 && (i.position.x = Math.round(i.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (i.position.y = Math.round(i.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (i.position.z = Math.round(i.position.z / this.translationSnap) * this.translationSnap), i.parent && i.position.sub(xt.setFromMatrixPosition(i.parent.matrixWorld))));
      else if (e === "scale") {
        if (t.search("XYZ") !== -1) {
          let o = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (o *= -1), Ce.set(o, o, o);
        } else
          xt.copy(this.pointStart), Ce.copy(this.pointEnd), xt.applyQuaternion(this._worldQuaternionInv), Ce.applyQuaternion(this._worldQuaternionInv), Ce.divide(xt), t.search("X") === -1 && (Ce.x = 1), t.search("Y") === -1 && (Ce.y = 1), t.search("Z") === -1 && (Ce.z = 1);
        i.scale.copy(this._scaleStart).multiply(Ce), this.scaleSnap && (t.search("X") !== -1 && (i.scale.x = Math.round(i.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Y") !== -1 && (i.scale.y = Math.round(i.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Z") !== -1 && (i.scale.z = Math.round(i.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (e === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const o = 20 / this.worldPosition.distanceTo(xt.setFromMatrixPosition(this.camera.matrixWorld));
        let a = !1;
        t === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(xt.copy(this.rotationAxis).cross(this.eye)) * o) : (t === "X" || t === "Y" || t === "Z") && (this.rotationAxis.copy(dr[t]), xt.copy(dr[t]), n === "local" && xt.applyQuaternion(this.worldQuaternion), xt.cross(this.eye), xt.length() === 0 ? a = !0 : this.rotationAngle = this._offset.dot(xt.normalize()) * o), (t === "E" || a) && (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), n === "local" && t !== "E" && t !== "XYZE" ? (i.quaternion.copy(this._quaternionStart), i.quaternion.multiply(yt.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), i.quaternion.copy(yt.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), i.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent($i), this.dispatchEvent(pr);
    }
  }
  pointerUp(s) {
    s.button === 0 && (this.dragging && this.axis !== null && (fr.mode = this.mode, this.dispatchEvent(fr)), this.dragging = !1, this.axis = null);
  }
  dispose() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.traverse(function(s) {
      s.geometry && s.geometry.dispose(), s.material && s.material.dispose();
    });
  }
  // Set current object
  attach(s) {
    return this.object = s, this.visible = !0, this;
  }
  // Detach from object
  detach() {
    return this.object = void 0, this.visible = !1, this.axis = null, this;
  }
  reset() {
    this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent($i), this.dispatchEvent(pr), this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return be;
  }
  // TODO: deprecate
  getMode() {
    return this.mode;
  }
  setMode(s) {
    this.mode = s;
  }
  setTranslationSnap(s) {
    this.translationSnap = s;
  }
  setRotationSnap(s) {
    this.rotationSnap = s;
  }
  setScaleSnap(s) {
    this.scaleSnap = s;
  }
  setSize(s) {
    this.size = s;
  }
  setSpace(s) {
    this.space = s;
  }
}
function Za(c) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return {
      x: 0,
      y: 0,
      button: c.button
    };
  {
    const s = this.domElement.getBoundingClientRect();
    return {
      x: (c.clientX - s.left) / s.width * 2 - 1,
      y: -(c.clientY - s.top) / s.height * 2 + 1,
      button: c.button
    };
  }
}
function $a(c) {
  if (this.enabled)
    switch (c.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(c));
        break;
    }
}
function ja(c) {
  this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(c.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(c)), this.pointerDown(this._getPointer(c)));
}
function Qa(c) {
  this.enabled && this.pointerMove(this._getPointer(c));
}
function qa(c) {
  this.enabled && (this.domElement.releasePointerCapture(c.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(c)));
}
function ji(c, s, t) {
  const e = s.intersectObject(c, !0);
  for (let i = 0; i < e.length; i++)
    if (e[i].object.visible || t)
      return e[i];
  return !1;
}
const ti = new co(), gt = new q(0, 1, 0), Er = new q(0, 0, 0), mr = new de(), ei = new le(), ci = new le(), oe = new q(), Ir = new de(), _s = new q(1, 0, 0), Pe = new q(0, 1, 0), As = new q(0, 0, 1), si = new q(), Is = new q(), gs = new q();
class Ka extends Qi {
  constructor() {
    super(), this.isTransformControlsGizmo = !0, this.type = "TransformControlsGizmo";
    const s = new Pr({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), t = new lo({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), e = s.clone();
    e.opacity = 0.15;
    const i = t.clone();
    i.opacity = 0.5;
    const n = s.clone();
    n.color.setHex(16711680);
    const r = s.clone();
    r.color.setHex(65280);
    const o = s.clone();
    o.color.setHex(255);
    const a = s.clone();
    a.color.setHex(16711680), a.opacity = 0.5;
    const l = s.clone();
    l.color.setHex(65280), l.opacity = 0.5;
    const h = s.clone();
    h.color.setHex(255), h.opacity = 0.5;
    const d = s.clone();
    d.opacity = 0.25;
    const u = s.clone();
    u.color.setHex(16776960), u.opacity = 0.25, s.clone().color.setHex(16776960);
    const E = s.clone();
    E.color.setHex(7895160);
    const p = new zt(0, 0.04, 0.1, 12);
    p.translate(0, 0.05, 0);
    const I = new Dt(0.08, 0.08, 0.08);
    I.translate(0, 0.04, 0);
    const m = new Ln();
    m.setAttribute("position", new Mn([0, 0, 0, 1, 0, 0], 3));
    const C = new zt(75e-4, 75e-4, 0.5, 3);
    C.translate(0, 0.25, 0);
    function R(v, Q) {
      const V = new rs(v, 75e-4, 3, 64, Q * Math.PI * 2);
      return V.rotateY(Math.PI / 2), V.rotateX(Math.PI / 2), V;
    }
    function g() {
      const v = new Ln();
      return v.setAttribute("position", new Mn([0, 0, 0, 1, 1, 1], 3)), v;
    }
    const y = {
      X: [
        [new rt(p, n), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new rt(p, n), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new rt(C, n), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new rt(p, r), [0, 0.5, 0]],
        [new rt(p, r), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new rt(C, r)]
      ],
      Z: [
        [new rt(p, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new rt(p, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new rt(C, o), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new rt(new Ms(0.1, 0), d.clone()), [0, 0, 0]]
      ],
      XY: [
        [new rt(new Dt(0.15, 0.15, 0.01), h.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new rt(new Dt(0.15, 0.15, 0.01), a.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new rt(new Dt(0.15, 0.15, 0.01), l.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, F = {
      X: [
        [new rt(new zt(0.2, 0, 0.6, 4), e), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new rt(new zt(0.2, 0, 0.6, 4), e), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new rt(new zt(0.2, 0, 0.6, 4), e), [0, 0.3, 0]],
        [new rt(new zt(0.2, 0, 0.6, 4), e), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new rt(new zt(0.2, 0, 0.6, 4), e), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new rt(new zt(0.2, 0, 0.6, 4), e), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new rt(new Ms(0.2, 0), e)]
      ],
      XY: [
        [new rt(new Dt(0.2, 0.2, 0.01), e), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new rt(new Dt(0.2, 0.2, 0.01), e), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new rt(new Dt(0.2, 0.2, 0.01), e), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, S = {
      START: [
        [new rt(new Ms(0.01, 2), i), null, null, null, "helper"]
      ],
      END: [
        [new rt(new Ms(0.01, 2), i), null, null, null, "helper"]
      ],
      DELTA: [
        [new Ie(g(), i), null, null, null, "helper"]
      ],
      X: [
        [new Ie(m, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Ie(m, i.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Ie(m, i.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    }, L = {
      XYZE: [
        [new rt(R(0.5, 1), E), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new rt(R(0.5, 0.5), n)]
      ],
      Y: [
        [new rt(R(0.5, 0.5), r), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new rt(R(0.5, 0.5), o), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new rt(R(0.75, 1), u), null, [0, Math.PI / 2, 0]]
      ]
    }, N = {
      AXIS: [
        [new Ie(m, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    }, x = {
      XYZE: [
        [new rt(new ho(0.25, 10, 8), e)]
      ],
      X: [
        [new rt(new rs(0.5, 0.1, 4, 24), e), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new rt(new rs(0.5, 0.1, 4, 24), e), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new rt(new rs(0.5, 0.1, 4, 24), e), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new rt(new rs(0.75, 0.1, 2, 24), e)]
      ]
    }, k = {
      X: [
        [new rt(I, n), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new rt(C, n), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new rt(I, n), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new rt(I, r), [0, 0.5, 0]],
        [new rt(C, r)],
        [new rt(I, r), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new rt(I, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new rt(C, o), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new rt(I, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new rt(new Dt(0.15, 0.15, 0.01), h), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new rt(new Dt(0.15, 0.15, 0.01), a), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new rt(new Dt(0.15, 0.15, 0.01), l), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new rt(new Dt(0.1, 0.1, 0.1), d.clone())]
      ]
    }, w = {
      X: [
        [new rt(new zt(0.2, 0, 0.6, 4), e), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new rt(new zt(0.2, 0, 0.6, 4), e), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new rt(new zt(0.2, 0, 0.6, 4), e), [0, 0.3, 0]],
        [new rt(new zt(0.2, 0, 0.6, 4), e), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new rt(new zt(0.2, 0, 0.6, 4), e), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new rt(new zt(0.2, 0, 0.6, 4), e), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new rt(new Dt(0.2, 0.2, 0.01), e), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new rt(new Dt(0.2, 0.2, 0.01), e), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new rt(new Dt(0.2, 0.2, 0.01), e), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new rt(new Dt(0.2, 0.2, 0.2), e), [0, 0, 0]]
      ]
    }, P = {
      X: [
        [new Ie(m, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Ie(m, i.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Ie(m, i.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function _(v) {
      const Q = new Qi();
      for (const V in v)
        for (let et = v[V].length; et--; ) {
          const H = v[V][et][0].clone(), nt = v[V][et][1], z = v[V][et][2], U = v[V][et][3], ot = v[V][et][4];
          H.name = V, H.tag = ot, nt && H.position.set(nt[0], nt[1], nt[2]), z && H.rotation.set(z[0], z[1], z[2]), U && H.scale.set(U[0], U[1], U[2]), H.updateMatrix();
          const st = H.geometry.clone();
          st.applyMatrix4(H.matrix), H.geometry = st, H.renderOrder = 1 / 0, H.position.set(0, 0, 0), H.rotation.set(0, 0, 0), H.scale.set(1, 1, 1), Q.add(H);
        }
      return Q;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = _(y)), this.add(this.gizmo.rotate = _(L)), this.add(this.gizmo.scale = _(k)), this.add(this.picker.translate = _(F)), this.add(this.picker.rotate = _(x)), this.add(this.picker.scale = _(w)), this.add(this.helper.translate = _(S)), this.add(this.helper.rotate = _(N)), this.add(this.helper.scale = _(P)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(s) {
    const e = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : ci;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let i = [];
    i = i.concat(this.picker[this.mode].children), i = i.concat(this.gizmo[this.mode].children), i = i.concat(this.helper[this.mode].children);
    for (let n = 0; n < i.length; n++) {
      const r = i[n];
      r.visible = !0, r.rotation.set(0, 0, 0), r.position.copy(this.worldPosition);
      let o;
      if (this.camera.isOrthographicCamera ? o = (this.camera.top - this.camera.bottom) / this.camera.zoom : o = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), r.scale.set(1, 1, 1).multiplyScalar(o * this.size / 4), r.tag === "helper") {
        r.visible = !1, r.name === "AXIS" ? (r.visible = !!this.axis, this.axis === "X" && (yt.setFromEuler(ti.set(0, 0, 0)), r.quaternion.copy(e).multiply(yt), Math.abs(gt.copy(_s).applyQuaternion(e).dot(this.eye)) > 0.9 && (r.visible = !1)), this.axis === "Y" && (yt.setFromEuler(ti.set(0, 0, Math.PI / 2)), r.quaternion.copy(e).multiply(yt), Math.abs(gt.copy(Pe).applyQuaternion(e).dot(this.eye)) > 0.9 && (r.visible = !1)), this.axis === "Z" && (yt.setFromEuler(ti.set(0, Math.PI / 2, 0)), r.quaternion.copy(e).multiply(yt), Math.abs(gt.copy(As).applyQuaternion(e).dot(this.eye)) > 0.9 && (r.visible = !1)), this.axis === "XYZE" && (yt.setFromEuler(ti.set(0, Math.PI / 2, 0)), gt.copy(this.rotationAxis), r.quaternion.setFromRotationMatrix(mr.lookAt(Er, gt, Pe)), r.quaternion.multiply(yt), r.visible = this.dragging), this.axis === "E" && (r.visible = !1)) : r.name === "START" ? (r.position.copy(this.worldPositionStart), r.visible = this.dragging) : r.name === "END" ? (r.position.copy(this.worldPosition), r.visible = this.dragging) : r.name === "DELTA" ? (r.position.copy(this.worldPositionStart), r.quaternion.copy(this.worldQuaternionStart), xt.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), xt.applyQuaternion(this.worldQuaternionStart.clone().invert()), r.scale.copy(xt), r.visible = this.dragging) : (r.quaternion.copy(e), this.dragging ? r.position.copy(this.worldPositionStart) : r.position.copy(this.worldPosition), this.axis && (r.visible = this.axis.search(r.name) !== -1));
        continue;
      }
      r.quaternion.copy(e), this.mode === "translate" || this.mode === "scale" ? (r.name === "X" && Math.abs(gt.copy(_s).applyQuaternion(e).dot(this.eye)) > 0.99 && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), r.name === "Y" && Math.abs(gt.copy(Pe).applyQuaternion(e).dot(this.eye)) > 0.99 && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), r.name === "Z" && Math.abs(gt.copy(As).applyQuaternion(e).dot(this.eye)) > 0.99 && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), r.name === "XY" && Math.abs(gt.copy(As).applyQuaternion(e).dot(this.eye)) < 0.2 && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), r.name === "YZ" && Math.abs(gt.copy(_s).applyQuaternion(e).dot(this.eye)) < 0.2 && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), r.name === "XZ" && Math.abs(gt.copy(Pe).applyQuaternion(e).dot(this.eye)) < 0.2 && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1)) : this.mode === "rotate" && (ei.copy(e), gt.copy(this.eye).applyQuaternion(yt.copy(e).invert()), r.name.search("E") !== -1 && r.quaternion.setFromRotationMatrix(mr.lookAt(this.eye, Er, Pe)), r.name === "X" && (yt.setFromAxisAngle(_s, Math.atan2(-gt.y, gt.z)), yt.multiplyQuaternions(ei, yt), r.quaternion.copy(yt)), r.name === "Y" && (yt.setFromAxisAngle(Pe, Math.atan2(gt.x, gt.z)), yt.multiplyQuaternions(ei, yt), r.quaternion.copy(yt)), r.name === "Z" && (yt.setFromAxisAngle(As, Math.atan2(gt.y, gt.x)), yt.multiplyQuaternions(ei, yt), r.quaternion.copy(yt))), r.visible = r.visible && (r.name.indexOf("X") === -1 || this.showX), r.visible = r.visible && (r.name.indexOf("Y") === -1 || this.showY), r.visible = r.visible && (r.name.indexOf("Z") === -1 || this.showZ), r.visible = r.visible && (r.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), r.material._color = r.material._color || r.material.color.clone(), r.material._opacity = r.material._opacity || r.material.opacity, r.material.color.copy(r.material._color), r.material.opacity = r.material._opacity, this.enabled && this.axis && (r.name === this.axis || this.axis.split("").some(function(a) {
        return r.name === a;
      })) && (r.material.color.setHex(16776960), r.material.opacity = 1);
    }
    super.updateMatrixWorld(s);
  }
}
class Ja extends rt {
  constructor() {
    super(
      new uo(1e5, 1e5, 2, 2),
      new Pr({ visible: !1, wireframe: !0, side: br, transparent: !0, opacity: 0.1, toneMapped: !1 })
    ), this.isTransformControlsPlane = !0, this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(s) {
    let t = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (t = "local"), si.copy(_s).applyQuaternion(t === "local" ? this.worldQuaternion : ci), Is.copy(Pe).applyQuaternion(t === "local" ? this.worldQuaternion : ci), gs.copy(As).applyQuaternion(t === "local" ? this.worldQuaternion : ci), gt.copy(Is), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            gt.copy(this.eye).cross(si), oe.copy(si).cross(gt);
            break;
          case "Y":
            gt.copy(this.eye).cross(Is), oe.copy(Is).cross(gt);
            break;
          case "Z":
            gt.copy(this.eye).cross(gs), oe.copy(gs).cross(gt);
            break;
          case "XY":
            oe.copy(gs);
            break;
          case "YZ":
            oe.copy(si);
            break;
          case "XZ":
            gt.copy(gs), oe.copy(Is);
            break;
          case "XYZ":
          case "E":
            oe.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        oe.set(0, 0, 0);
    }
    oe.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (Ir.lookAt(xt.set(0, 0, 0), oe, gt), this.quaternion.setFromRotationMatrix(Ir)), super.updateMatrixWorld(s);
  }
}
class yn {
  constructor(s, t, e, i, n, r = 5, o = !0) {
    /** Event that fires when the user starts dragging a clipping plane. */
    T(this, "onDraggingStarted", new j());
    /** Event that fires when the user stops dragging a clipping plane. */
    T(this, "onDraggingEnded", new j());
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    /**
     * The normal vector of the clipping plane.
     */
    T(this, "normal");
    /**
     * The origin point of the clipping plane.
     */
    T(this, "origin");
    /**
     * The THREE.js Plane object representing the clipping plane.
     */
    T(this, "three", new M.Plane());
    /** The components instance to which this plane belongs. */
    T(this, "components");
    /** The world instance to which this plane belongs. */
    T(this, "world");
    /** A custom string to identify what this plane is used for. */
    T(this, "type", "default");
    T(this, "_helper");
    T(this, "_visible", !0);
    T(this, "_enabled", !0);
    T(this, "_controlsActive", !1);
    T(this, "_arrowBoundBox", new M.Mesh());
    T(this, "_planeMesh");
    T(this, "_controls");
    T(this, "_hiddenMaterial", new M.MeshBasicMaterial({
      visible: !1
    }));
    /** {@link Updateable.update} */
    T(this, "update", () => {
      this._enabled && this.three.setFromNormalAndCoplanarPoint(
        this.normal,
        this._helper.position
      );
    });
    T(this, "changeDrag", (s) => {
      this._visible = !s.value, this.preventCameraMovement(), this.notifyDraggingChanged(s);
    });
    if (this.components = s, this.world = t, !t.renderer)
      throw new Error("The given world must have a renderer!");
    this.normal = i, this.origin = e, t.renderer.setPlane(!0, this.three), this._planeMesh = yn.newPlaneMesh(r, n), this._helper = this.newHelper(), this._controls = this.newTransformControls(), this.three.setFromNormalAndCoplanarPoint(i, e), o && this.toggleControls(!0);
  }
  /**
   * Getter for the enabled state of the clipping plane.
   * @returns {boolean} The current enabled state.
   */
  get enabled() {
    return this._enabled;
  }
  /**
   * Setter for the enabled state of the clipping plane.
   * Updates the clipping plane state in the renderer and throws an error if no renderer is found.
   * @param {boolean} state - The new enabled state.
   */
  set enabled(s) {
    if (!this.world.renderer)
      throw new Error("No renderer found for clipping plane!");
    this._enabled = s, this.world.renderer.setPlane(s, this.three);
  }
  /** {@link Hideable.visible } */
  get visible() {
    return this._visible;
  }
  /** {@link Hideable.visible } */
  set visible(s) {
    this._visible = s, this._controls.visible = s, this._helper.visible = s, this.toggleControls(s);
  }
  /** The meshes used for raycasting */
  get meshes() {
    return [this._planeMesh, this._arrowBoundBox];
  }
  /** The material of the clipping plane representation. */
  get planeMaterial() {
    return this._planeMesh.material;
  }
  /** The material of the clipping plane representation. */
  set planeMaterial(s) {
    this._planeMesh.material = s;
  }
  /** The size of the clipping plane representation. */
  get size() {
    return this._planeMesh.scale.x;
  }
  /** Sets the size of the clipping plane representation. */
  set size(s) {
    this._planeMesh.scale.set(s, s, s);
  }
  /**
   * Getter for the helper object of the clipping plane.
   * The helper object is a THREE.Object3D that contains the clipping plane mesh and other related objects.
   * It is used for positioning, rotating, and scaling the clipping plane in the 3D scene.
   *
   * @returns {THREE.Object3D} The helper object of the clipping plane.
   */
  get helper() {
    return this._helper;
  }
  /**
   * Sets the clipping plane's normal and origin from the given normal and point.
   * This method resets the clipping plane's state, updates the normal and origin,
   * and positions the helper object accordingly.
   *
   * @param normal - The new normal vector for the clipping plane.
   * @param point - The new origin point for the clipping plane.
   *
   * @returns {void}
   */
  setFromNormalAndCoplanarPoint(s, t) {
    this.reset(), this.normal.equals(s) || (this.normal.copy(s), this._helper.lookAt(s)), this.origin.copy(t), this._helper.position.copy(t), this._helper.updateMatrix(), this.update();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this._enabled = !1, this.onDraggingStarted.reset(), this.onDraggingEnded.reset(), this._helper.removeFromParent(), this.world.renderer && this.world.renderer.setPlane(!1, this.three), this._arrowBoundBox.removeFromParent(), this._arrowBoundBox.geometry.dispose(), this._planeMesh.geometry.dispose(), this._controls.removeFromParent(), this._controls.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  reset() {
    const s = new M.Vector3(1, 0, 0), t = new M.Vector3();
    this.normal.equals(s) || (this.normal.copy(s), this._helper.lookAt(s)), this.origin.copy(t), this._helper.position.copy(t), this._helper.updateMatrix();
  }
  toggleControls(s) {
    if (s) {
      if (this._controlsActive)
        return;
      this._controls.addEventListener("change", this.update), this._controls.addEventListener("dragging-changed", this.changeDrag);
    } else
      this._controls.removeEventListener("change", this.update), this._controls.removeEventListener("dragging-changed", this.changeDrag);
    this._controlsActive = s;
  }
  newTransformControls() {
    if (!this.world.renderer)
      throw new Error("No renderer found for clipping plane!");
    const s = this.world.camera.three, t = this.world.renderer.three.domElement, e = new Xa(s, t);
    return this.initializeControls(e), this.world.scene.three.add(e), e;
  }
  initializeControls(s) {
    s.attach(this._helper), s.showX = !1, s.showY = !1, s.setSpace("local"), this.createArrowBoundingBox(), s.children[0].children[0].add(this._arrowBoundBox);
  }
  createArrowBoundingBox() {
    this._arrowBoundBox.geometry = new M.CylinderGeometry(0.18, 0.18, 1.2), this._arrowBoundBox.material = this._hiddenMaterial, this._arrowBoundBox.rotateX(Math.PI / 2), this._arrowBoundBox.updateMatrix(), this._arrowBoundBox.geometry.applyMatrix4(this._arrowBoundBox.matrix);
  }
  notifyDraggingChanged(s) {
    s.value ? this.onDraggingStarted.trigger() : this.onDraggingEnded.trigger();
  }
  preventCameraMovement() {
    this.world.camera.enabled = this._visible;
  }
  newHelper() {
    const s = new M.Object3D();
    return s.lookAt(this.normal), s.position.copy(this.origin), this._planeMesh.position.z += 0.01, s.add(this._planeMesh), this.world.scene.three.add(s), s;
  }
  static newPlaneMesh(s, t) {
    const e = new M.PlaneGeometry(1), i = new M.Mesh(e, t);
    return i.scale.set(s, s, s), i;
  }
}
const Fs = class Fs extends St {
  constructor(t) {
    super(t);
    /** Event that fires when the user starts dragging a clipping plane. */
    T(this, "onBeforeDrag", new j());
    /** Event that fires when the user stops dragging a clipping plane. */
    T(this, "onAfterDrag", new j());
    /**
     * Event that fires when the user starts creating a clipping plane.
     */
    T(this, "onBeforeCreate", new j());
    /**
     * Event that fires when the user cancels the creation of a clipping plane.
     */
    T(this, "onBeforeCancel", new j());
    /**
     * Event that fires after the user cancels the creation of a clipping plane.
     */
    T(this, "onAfterCancel", new j());
    /**
     * Event that fires when the user starts deleting a clipping plane.
     */
    T(this, "onBeforeDelete", new j());
    /**
     * Event that fires after a clipping plane has been created.
     * @param plane - The newly created clipping plane.
     */
    T(this, "onAfterCreate", new j());
    /**
     * Event that fires after a clipping plane has been deleted.
     * @param plane - The deleted clipping plane.
     */
    T(this, "onAfterDelete", new j());
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    /**
     * Whether to force the clipping plane to be orthogonal in the Y direction
     * (up). This is desirable when clipping a building horizontally and a
     * clipping plane is created in its roof, which might have a slight
     * slope for draining purposes.
     */
    T(this, "orthogonalY", !1);
    /**
     * The tolerance that determines whether an almost-horizontal clipping plane
     * will be forced to be orthogonal to the Y direction. {@link orthogonalY}
     * has to be `true` for this to apply.
     */
    T(this, "toleranceOrthogonalY", 0.7);
    /**
     * The type of clipping plane to be created.
     * Default is {@link SimplePlane}.
     */
    T(this, "Type", yn);
    /**
     * A list of all the clipping planes created by this component.
     */
    T(this, "list", []);
    /** The material used in all the clipping planes. */
    T(this, "_material", new M.MeshBasicMaterial({
      color: 12255487,
      side: M.DoubleSide,
      transparent: !0,
      opacity: 0.2
    }));
    T(this, "_size", 5);
    T(this, "_enabled", !1);
    T(this, "_visible", !0);
    T(this, "_onStartDragging", () => {
      this.onBeforeDrag.trigger();
    });
    T(this, "_onEndDragging", () => {
      this.onAfterDrag.trigger();
    });
    this.components.add(Fs.uuid, this);
  }
  /** {@link Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link Component.enabled} */
  set enabled(t) {
    this._enabled = t;
    for (const e of this.list)
      e.enabled = t;
    this.updateMaterialsAndPlanes();
  }
  /** {@link Hideable.visible } */
  get visible() {
    return this._visible;
  }
  /** {@link Hideable.visible } */
  set visible(t) {
    this._visible = t;
    for (const e of this.list)
      e.visible = t;
  }
  /** The material of the clipping plane representation. */
  get material() {
    return this._material;
  }
  /** The material of the clipping plane representation. */
  set material(t) {
    this._material = t;
    for (const e of this.list)
      e.planeMaterial = t;
  }
  /** The size of the geometric representation of the clippings planes. */
  get size() {
    return this._size;
  }
  /** The size of the geometric representation of the clippings planes. */
  set size(t) {
    this._size = t;
    for (const e of this.list)
      e.size = t;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this._enabled = !1;
    for (const t of this.list)
      t.dispose();
    this.list.length = 0, this._material.dispose(), this.onBeforeCreate.reset(), this.onBeforeCancel.reset(), this.onBeforeDelete.reset(), this.onBeforeDrag.reset(), this.onAfterCreate.reset(), this.onAfterCancel.reset(), this.onAfterDelete.reset(), this.onAfterDrag.reset(), this.onDisposed.trigger(Fs.uuid), this.onDisposed.reset();
  }
  /** {@link Createable.create} */
  create(t) {
    const n = this.components.get(ts).get(t).castRay();
    return n ? this.createPlaneFromIntersection(t, n) : null;
  }
  /**
   * Creates a plane in a certain place and with a certain orientation,
   * without the need of the mouse.
   *
   * @param world - the world where this plane should be created.
   * @param normal - the orientation of the clipping plane.
   * @param point - the position of the clipping plane.
   * navigation.
   */
  createFromNormalAndCoplanarPoint(t, e, i) {
    const n = this.newPlane(t, i, e);
    return this.updateMaterialsAndPlanes(), n;
  }
  /**
   * {@link Createable.delete}
   *
   * @param world - the world where the plane to delete is.
   * @param plane - the plane to delete. If undefined, the first plane
   * found under the cursor will be deleted.
   */
  delete(t, e) {
    e || (e = this.pickPlane(t)), e && this.deletePlane(e);
  }
  /**
   * Deletes all the existing clipping planes.
   *
   * @param types - the types of planes to be deleted. If not provided, all planes will be deleted.
   */
  deleteAll(t) {
    const e = [...this.list];
    for (const i of e)
      if (!t || t.has(i.type)) {
        this.delete(i.world, i);
        const n = this.list.indexOf(i);
        n !== -1 && this.list.splice(n, 1);
      }
  }
  deletePlane(t) {
    const e = this.list.indexOf(t);
    if (e !== -1) {
      if (this.list.splice(e, 1), !t.world.renderer)
        throw new Error("Renderer not found for this plane's world!");
      t.world.renderer.setPlane(!1, t.three), t.dispose(), this.updateMaterialsAndPlanes(), this.onAfterDelete.trigger(t);
    }
  }
  pickPlane(t) {
    const i = this.components.get(ts).get(t), n = this.getAllPlaneMeshes(), r = i.castRay(n);
    if (r) {
      const o = r.object;
      return this.list.find((a) => a.meshes.includes(o));
    }
  }
  getAllPlaneMeshes() {
    const t = [];
    for (const e of this.list)
      t.push(...e.meshes);
    return t;
  }
  createPlaneFromIntersection(t, e) {
    var a;
    if (!t.renderer)
      throw new Error("The given world must have a renderer!");
    const i = e.point.distanceTo(new M.Vector3(0, 0, 0)), n = (a = e.face) == null ? void 0 : a.normal;
    if (!i || !n)
      return null;
    const r = this.getWorldNormal(e, n), o = this.newPlane(t, e.point, r.negate());
    return o.visible = this._visible, o.size = this._size, t.renderer.setPlane(!0, o.three), this.updateMaterialsAndPlanes(), o;
  }
  getWorldNormal(t, e) {
    const i = t.object;
    let n = t.object.matrixWorld.clone();
    if (i instanceof M.InstancedMesh && t.instanceId !== void 0) {
      const l = new M.Matrix4();
      i.getMatrixAt(t.instanceId, l), n = l.multiply(n);
    }
    const o = new M.Matrix3().getNormalMatrix(n), a = e.clone().applyMatrix3(o).normalize();
    return this.normalizePlaneDirectionY(a), a;
  }
  normalizePlaneDirectionY(t) {
    this.orthogonalY && (t.y > this.toleranceOrthogonalY && (t.x = 0, t.y = 1, t.z = 0), t.y < -this.toleranceOrthogonalY && (t.x = 0, t.y = -1, t.z = 0));
  }
  newPlane(t, e, i) {
    const n = new this.Type(
      this.components,
      t,
      e,
      i,
      this._material
    );
    return n.onDraggingStarted.add(this._onStartDragging), n.onDraggingEnded.add(this._onEndDragging), this.list.push(n), this.onAfterCreate.trigger(n), n;
  }
  updateMaterialsAndPlanes() {
    const t = this.components.get(hi);
    for (const [e, i] of t.list) {
      if (!i.renderer)
        continue;
      i.renderer.updateClippingPlanes();
      const { clippingPlanes: n } = i.renderer;
      for (const r of i.meshes)
        if (r.material)
          if (Array.isArray(r.material))
            for (const o of r.material)
              o.clippingPlanes = n;
          else
            r.material.clippingPlanes = n;
    }
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
T(Fs, "uuid", "66290bc5-18c4-4cd1-9379-2e17a0617611");
let ln = Fs;
class tc {
  constructor(s) {
    /** {@link NavigationMode.enabled} */
    T(this, "enabled", !1);
    /** {@link NavigationMode.id} */
    T(this, "id", "FirstPerson");
    this.camera = s;
  }
  /** {@link NavigationMode.set} */
  set(s) {
    if (this.enabled = s, s) {
      if (this.camera.projection.current !== "Perspective") {
        this.camera.set("Orbit");
        return;
      }
      this.setupFirstPersonCamera();
    }
  }
  setupFirstPersonCamera() {
    const s = this.camera.controls, t = new M.Vector3();
    s.distance--, s.getPosition(t), s.minDistance = 1, s.maxDistance = 1, s.distance = 1, s.moveTo(
      t.x,
      t.y,
      t.z
    ), s.truckSpeed = 50, s.mouseButtons.wheel = vt.ACTION.DOLLY, s.touches.two = vt.ACTION.TOUCH_ZOOM_TRUCK;
  }
}
class ec {
  constructor(s) {
    /** {@link NavigationMode.enabled} */
    T(this, "enabled", !0);
    /** {@link NavigationMode.id} */
    T(this, "id", "Orbit");
    this.camera = s, this.activateOrbitControls();
  }
  /** {@link NavigationMode.set} */
  set(s) {
    this.enabled = s, s && this.activateOrbitControls();
  }
  activateOrbitControls() {
    const s = this.camera.controls;
    s.minDistance = 1, s.maxDistance = 300;
    const t = new M.Vector3();
    s.getPosition(t);
    const e = t.length();
    s.distance = e, s.truckSpeed = 2;
    const { rotation: i } = this.camera.three, n = new M.Vector3(0, 0, -1).applyEuler(i), r = t.addScaledVector(n, e);
    s.moveTo(r.x, r.y, r.z);
  }
}
class sc {
  constructor(s) {
    /** {@link NavigationMode.enabled} */
    T(this, "enabled", !1);
    /** {@link NavigationMode.id} */
    T(this, "id", "Plan");
    T(this, "mouseAction1");
    T(this, "mouseAction2");
    T(this, "mouseInitialized", !1);
    T(this, "defaultAzimuthSpeed");
    T(this, "defaultPolarSpeed");
    this.camera = s, this.defaultAzimuthSpeed = s.controls.azimuthRotateSpeed, this.defaultPolarSpeed = s.controls.polarRotateSpeed;
  }
  /** {@link NavigationMode.set} */
  set(s) {
    this.enabled = s;
    const t = this.camera.controls;
    t.azimuthRotateSpeed = s ? 0 : this.defaultAzimuthSpeed, t.polarRotateSpeed = s ? 0 : this.defaultPolarSpeed, this.mouseInitialized || (this.mouseAction1 = t.touches.one, this.mouseAction2 = t.touches.two, this.mouseInitialized = !0), s ? (t.mouseButtons.left = vt.ACTION.TRUCK, t.touches.one = vt.ACTION.TOUCH_TRUCK, t.touches.two = vt.ACTION.TOUCH_ZOOM) : (t.mouseButtons.left = vt.ACTION.ROTATE, t.touches.one = this.mouseAction1, t.touches.two = this.mouseAction2);
  }
}
class ic {
  constructor(s) {
    /**
     * Event that fires when the {@link CameraProjection} changes.
     */
    T(this, "onChanged", new j());
    /**
     * Current projection mode of the camera.
     * Default is "Perspective".
     */
    T(this, "current", "Perspective");
    /**
     * The camera controlled by this ProjectionManager.
     * It can be either a PerspectiveCamera or an OrthographicCamera.
     */
    T(this, "camera");
    /** Match Ortho zoom with Perspective distance when changing projection mode */
    T(this, "matchOrthoDistanceEnabled", !1);
    T(this, "_component");
    T(this, "_previousDistance", -1);
    this._component = s, this.camera = s.three;
  }
  /**
   * Sets the {@link CameraProjection} of the {@link OrthoPerspectiveCamera}.
   *
   * @param projection - the new projection to set. If it is the current projection,
   * it will have no effect.
   */
  async set(s) {
    this.current !== s && (s === "Orthographic" ? this.setOrthoCamera() : await this.setPerspectiveCamera(), this.onChanged.trigger(this.camera));
  }
  /**
   * Changes the current {@link CameraProjection} from Ortographic to Perspective
   * and vice versa.
   */
  async toggle() {
    const t = this.current === "Perspective" ? "Orthographic" : "Perspective";
    await this.set(t);
  }
  setOrthoCamera() {
    if (this._component.mode === null || this._component.mode.id === "FirstPerson")
      return;
    this._previousDistance = this._component.controls.distance, this._component.controls.distance = 200;
    const s = this.getPerspectiveDims();
    if (!s)
      return;
    const { width: t, height: e } = s;
    this.setupOrthoCamera(e, t), this.camera = this._component.threeOrtho, this.current = "Orthographic";
  }
  getPerspectiveDims() {
    const s = this._component.currentWorld;
    if (!s || !s.renderer)
      return null;
    const t = new M.Vector3();
    this._component.threePersp.getWorldDirection(t);
    const e = new M.Vector3();
    this._component.controls.getTarget(e);
    const n = e.clone().sub(this._component.threePersp.position).dot(t), r = s.renderer.getSize(), o = r.x / r.y, a = this._component.threePersp, l = n * 2 * Math.atan(a.fov * (Math.PI / 180) / 2);
    return { width: l * o, height: l };
  }
  setupOrthoCamera(s, t) {
    this._component.controls.mouseButtons.wheel = vt.ACTION.ZOOM, this._component.controls.mouseButtons.middle = vt.ACTION.ZOOM;
    const e = this._component.threePersp, i = this._component.threeOrtho;
    i.zoom = 1, i.left = t / -2, i.right = t / 2, i.top = s / 2, i.bottom = s / -2, i.updateProjectionMatrix(), i.position.copy(e.position), i.quaternion.copy(e.quaternion), this._component.controls.camera = i;
  }
  getDistance() {
    const s = this._component.threePersp, t = this._component.threeOrtho;
    return (t.top - t.bottom) / t.zoom / (2 * Math.atan(s.fov * (Math.PI / 180) / 2));
  }
  async setPerspectiveCamera() {
    this._component.controls.mouseButtons.wheel = vt.ACTION.DOLLY, this._component.controls.mouseButtons.middle = vt.ACTION.DOLLY;
    const s = this._component.threePersp, t = this._component.threeOrtho;
    s.position.copy(t.position), s.quaternion.copy(t.quaternion), this._component.controls.mouseButtons.wheel = vt.ACTION.DOLLY, this.matchOrthoDistanceEnabled ? this._component.controls.distance = this.getDistance() : this._component.controls.distance = this._previousDistance, await this._component.controls.zoomTo(1), s.updateProjectionMatrix(), this._component.controls.camera = s, this.camera = s, this.current = "Perspective";
  }
}
class nc extends Ns {
  constructor(t) {
    super(t);
    /**
     * A ProjectionManager instance that manages the projection modes of the camera.
     */
    T(this, "projection");
    /**
     * A THREE.OrthographicCamera instance that represents the orthographic camera.
     * This camera is used when the projection mode is set to orthographic.
     */
    T(this, "threeOrtho");
    /**
     * A THREE.PerspectiveCamera instance that represents the perspective camera.
     * This camera is used when the projection mode is set to perspective.
     */
    T(this, "threePersp");
    T(this, "_userInputButtons", {});
    T(this, "_frustumSize", 50);
    T(this, "_navigationModes", /* @__PURE__ */ new Map());
    T(this, "_mode", null);
    T(this, "previousSize", null);
    this.threePersp = this.three, this.threeOrtho = this.newOrthoCamera(), this.projection = new ic(this), this.onAspectUpdated.add(() => {
      this.setOrthoPerspCameraAspect();
    }), this.projection.onChanged.add(
      (e) => {
        this.three = e, this.updateAspect();
      }
    ), this.onWorldChanged.add(({ action: e }) => {
      e === "added" && (this._navigationModes.clear(), this._navigationModes.set("Orbit", new ec(this)), this._navigationModes.set("FirstPerson", new tc(this)), this._navigationModes.set("Plan", new sc(this)), this._mode = this._navigationModes.get("Orbit"), this.mode.set(!0, { preventTargetAdjustment: !0 }), this.currentWorld && this.currentWorld.renderer && (this.previousSize = this.currentWorld.renderer.getSize().clone()));
    });
  }
  /**
   * Getter for the current navigation mode.
   * Throws an error if the mode is not found or the camera is not initialized.
   *
   * @returns {NavigationMode} The current navigation mode.
   *
   * @throws {Error} Throws an error if the mode is not found or the camera is not initialized.
   */
  get mode() {
    if (!this._mode)
      throw new Error("Mode not found, camera not initialized");
    return this._mode;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    super.dispose(), this.threeOrtho.removeFromParent();
  }
  /**
   * Sets a new {@link NavigationMode} and disables the previous one.
   *
   * @param mode - The {@link NavigationMode} to set.
   */
  set(t) {
    if (this.mode !== null && this.mode.id !== t) {
      if (this.mode.set(!1), !this._navigationModes.has(t))
        throw new Error("The specified mode does not exist!");
      this._mode = this._navigationModes.get(t), this.mode.set(!0);
    }
  }
  /**
   * Make the camera view fit all the specified meshes.
   *
   * @param meshes the meshes to fit. If it is not defined, it will
   * evaluate {@link Components.meshes}.
   * @param offset the distance to the fit object
   */
  async fit(t, e = 1.5) {
    if (!this.enabled)
      return;
    const i = Number.MAX_VALUE, n = Number.MIN_VALUE, r = new M.Vector3(i, i, i), o = new M.Vector3(n, n, n);
    for (const f of t) {
      const E = new M.Box3().setFromObject(f);
      E.min.x < r.x && (r.x = E.min.x), E.min.y < r.y && (r.y = E.min.y), E.min.z < r.z && (r.z = E.min.z), E.max.x > o.x && (o.x = E.max.x), E.max.y > o.y && (o.y = E.max.y), E.max.z > o.z && (o.z = E.max.z);
    }
    const a = new M.Box3(r, o), l = new M.Vector3();
    a.getSize(l);
    const h = new M.Vector3();
    a.getCenter(h);
    const d = Math.max(l.x, l.y, l.z) * e, u = new M.Sphere(h, d);
    await this.controls.fitToSphere(u, !0);
  }
  /**
   * Allows or prevents all user input.
   *
   * @param active - whether to enable or disable user inputs.
   */
  setUserInput(t) {
    t ? this.enableUserInput() : this.disableUserInput();
  }
  disableUserInput() {
    this._userInputButtons.left = this.controls.mouseButtons.left, this._userInputButtons.right = this.controls.mouseButtons.right, this._userInputButtons.middle = this.controls.mouseButtons.middle, this._userInputButtons.wheel = this.controls.mouseButtons.wheel, this.controls.mouseButtons.left = 0, this.controls.mouseButtons.right = 0, this.controls.mouseButtons.middle = 0, this.controls.mouseButtons.wheel = 0;
  }
  enableUserInput() {
    Object.keys(this._userInputButtons).length !== 0 && (this.controls.mouseButtons.left = this._userInputButtons.left, this.controls.mouseButtons.right = this._userInputButtons.right, this.controls.mouseButtons.middle = this._userInputButtons.middle, this.controls.mouseButtons.wheel = this._userInputButtons.wheel);
  }
  newOrthoCamera() {
    const t = window.innerWidth / window.innerHeight;
    return new M.OrthographicCamera(
      this._frustumSize * t / -2,
      this._frustumSize * t / 2,
      this._frustumSize / 2,
      this._frustumSize / -2,
      0.1,
      1e3
    );
  }
  setOrthoPerspCameraAspect() {
    if (!this.currentWorld || !this.currentWorld.renderer || !this.previousSize)
      return;
    const t = this.currentWorld.renderer.getSize(), e = this.threeOrtho.top, i = this.threeOrtho.right, n = t.y / this.previousSize.y, r = t.x / this.previousSize.x, o = e * n, a = i * r;
    this.threeOrtho.left = -a, this.threeOrtho.right = a, this.threeOrtho.top = o, this.threeOrtho.bottom = -o, this.threeOrtho.updateProjectionMatrix(), this.previousSize.copy(t);
  }
}
const gr = /* @__PURE__ */ new Map([
  [
    X.IFCRELAGGREGATES,
    {
      forRelated: "Decomposes",
      forRelating: "IsDecomposedBy"
    }
  ],
  [
    X.IFCRELASSOCIATESMATERIAL,
    {
      forRelated: "HasAssociations",
      forRelating: "AssociatedTo"
    }
  ],
  [
    X.IFCRELASSOCIATESCLASSIFICATION,
    {
      forRelated: "HasAssociations",
      forRelating: "ClassificationForObjects"
    }
  ],
  [
    X.IFCRELASSIGNSTOGROUP,
    {
      forRelated: "HasAssignments",
      forRelating: "IsGroupedBy"
    }
  ],
  [
    X.IFCRELDEFINESBYPROPERTIES,
    {
      forRelated: "IsDefinedBy",
      forRelating: "DefinesOcurrence"
    }
  ],
  [
    X.IFCRELDEFINESBYTYPE,
    {
      forRelated: "IsTypedBy",
      forRelating: "Types"
    }
  ],
  [
    X.IFCRELDEFINESBYTEMPLATE,
    {
      forRelated: "IsDefinedBy",
      forRelating: "Defines"
    }
  ],
  [
    X.IFCRELCONTAINEDINSPATIALSTRUCTURE,
    {
      forRelated: "ContainedInStructure",
      forRelating: "ContainsElements"
    }
  ],
  [
    X.IFCRELFLOWCONTROLELEMENTS,
    {
      forRelated: "AssignedToFlowElement",
      forRelating: "HasControlElements"
    }
  ],
  [
    X.IFCRELCONNECTSELEMENTS,
    {
      forRelated: "ConnectedFrom",
      forRelating: "ConnectedTo"
    }
  ],
  [
    X.IFCRELASSIGNSTOPRODUCT,
    {
      forRelated: "HasAssignments",
      forRelating: "ReferencedBy"
    }
  ],
  [
    X.IFCRELDECLARES,
    {
      forRelated: "HasContext",
      forRelating: "Declares"
    }
  ],
  [
    X.IFCRELASSIGNSTOCONTROL,
    {
      forRelated: "HasAssignments",
      forRelating: "Controls"
    }
  ],
  [
    X.IFCRELNESTS,
    {
      forRelated: "Nests",
      forRelating: "IsNestedBy"
    }
  ],
  [
    X.IFCRELASSOCIATESDOCUMENT,
    {
      forRelated: "HasAssociations",
      forRelating: "DocumentRefForObjects"
    }
  ]
]), rc = {
  103090709: "IFCPROJECT",
  4097777520: "IFCSITE",
  4031249490: "IFCBUILDING",
  3124254112: "IFCBUILDINGSTOREY",
  3856911033: "IFCSPACE",
  1674181508: "IFCANNOTATION",
  25142252: "IFCCONTROLLER",
  32344328: "IFCBOILER",
  76236018: "IFCLAMP",
  90941305: "IFCPUMP",
  177149247: "IFCAIRTERMINALBOX",
  182646315: "IFCFLOWINSTRUMENT",
  263784265: "IFCFURNISHINGELEMENT",
  264262732: "IFCELECTRICGENERATOR",
  277319702: "IFCAUDIOVISUALAPPLIANCE",
  310824031: "IFCPIPEFITTING",
  331165859: "IFCSTAIR",
  342316401: "IFCDUCTFITTING",
  377706215: "IFCMECHANICALFASTENER",
  395920057: "IFCDOOR",
  402227799: "IFCELECTRICMOTOR",
  413509423: "IFCSYSTEMFURNITUREELEMENT",
  484807127: "IFCEVAPORATOR",
  486154966: "IFCWINDOWSTANDARDCASE",
  629592764: "IFCLIGHTFIXTURE",
  630975310: "IFCUNITARYCONTROLELEMENT",
  635142910: "IFCCABLECARRIERFITTING",
  639361253: "IFCCOIL",
  647756555: "IFCFASTENER",
  707683696: "IFCFLOWSTORAGEDEVICE",
  738039164: "IFCPROTECTIVEDEVICE",
  753842376: "IFCBEAM",
  812556717: "IFCTANK",
  819412036: "IFCFILTER",
  843113511: "IFCCOLUMN",
  862014818: "IFCELECTRICDISTRIBUTIONBOARD",
  900683007: "IFCFOOTING",
  905975707: "IFCCOLUMNSTANDARDCASE",
  926996030: "IFCVOIDINGFEATURE",
  979691226: "IFCREINFORCINGBAR",
  987401354: "IFCFLOWSEGMENT",
  1003880860: "IFCELECTRICTIMECONTROL",
  1051757585: "IFCCABLEFITTING",
  1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
  1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
  1073191201: "IFCMEMBER",
  1095909175: "IFCBUILDINGELEMENTPROXY",
  1156407060: "IFCPLATESTANDARDCASE",
  1162798199: "IFCSWITCHINGDEVICE",
  1329646415: "IFCSHADINGDEVICE",
  1335981549: "IFCDISCRETEACCESSORY",
  1360408905: "IFCDUCTSILENCER",
  1404847402: "IFCSTACKTERMINAL",
  1426591983: "IFCFIRESUPPRESSIONTERMINAL",
  1437502449: "IFCMEDICALDEVICE",
  1509553395: "IFCFURNITURE",
  1529196076: "IFCSLAB",
  1620046519: "IFCTRANSPORTELEMENT",
  1634111441: "IFCAIRTERMINAL",
  1658829314: "IFCENERGYCONVERSIONDEVICE",
  1677625105: "IFCCIVILELEMENT",
  1687234759: "IFCPILE",
  1904799276: "IFCELECTRICAPPLIANCE",
  1911478936: "IFCMEMBERSTANDARDCASE",
  1945004755: "IFCDISTRIBUTIONELEMENT",
  1973544240: "IFCCOVERING",
  1999602285: "IFCSPACEHEATER",
  2016517767: "IFCROOF",
  2056796094: "IFCAIRTOAIRHEATRECOVERY",
  2058353004: "IFCFLOWCONTROLLER",
  2068733104: "IFCHUMIDIFIER",
  2176052936: "IFCJUNCTIONBOX",
  2188021234: "IFCFLOWMETER",
  2223149337: "IFCFLOWTERMINAL",
  2262370178: "IFCRAILING",
  2272882330: "IFCCONDENSER",
  2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
  2320036040: "IFCREINFORCINGMESH",
  2347447852: "IFCTENDONANCHOR",
  2391383451: "IFCVIBRATIONISOLATOR",
  2391406946: "IFCWALL",
  2474470126: "IFCMOTORCONNECTION",
  2769231204: "IFCVIRTUALELEMENT",
  2814081492: "IFCENGINE",
  2906023776: "IFCBEAMSTANDARDCASE",
  2938176219: "IFCBURNER",
  2979338954: "IFCBUILDINGELEMENTPART",
  3024970846: "IFCRAMP",
  3026737570: "IFCTUBEBUNDLE",
  3027962421: "IFCSLABSTANDARDCASE",
  3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
  3053780830: "IFCSANITARYTERMINAL",
  3079942009: "IFCOPENINGSTANDARDCASE",
  3087945054: "IFCALARM",
  3101698114: "IFCSURFACEFEATURE",
  3127900445: "IFCSLABELEMENTEDCASE",
  3132237377: "IFCFLOWMOVINGDEVICE",
  3171933400: "IFCPLATE",
  3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
  3242481149: "IFCDOORSTANDARDCASE",
  3283111854: "IFCRAMPFLIGHT",
  3296154744: "IFCCHIMNEY",
  3304561284: "IFCWINDOW",
  3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
  3319311131: "IFCHEATEXCHANGER",
  3415622556: "IFCFAN",
  3420628829: "IFCSOLARDEVICE",
  3493046030: "IFCGEOGRAPHICELEMENT",
  3495092785: "IFCCURTAINWALL",
  3508470533: "IFCFLOWTREATMENTDEVICE",
  3512223829: "IFCWALLSTANDARDCASE",
  3518393246: "IFCDUCTSEGMENT",
  3571504051: "IFCCOMPRESSOR",
  3588315303: "IFCOPENINGELEMENT",
  3612865200: "IFCPIPESEGMENT",
  3640358203: "IFCCOOLINGTOWER",
  3651124850: "IFCPROJECTIONELEMENT",
  3694346114: "IFCOUTLET",
  3747195512: "IFCEVAPORATIVECOOLER",
  3758799889: "IFCCABLECARRIERSEGMENT",
  3824725483: "IFCTENDON",
  3825984169: "IFCTRANSFORMER",
  3902619387: "IFCCHILLER",
  4074379575: "IFCDAMPER",
  4086658281: "IFCSENSOR",
  4123344466: "IFCELEMENTASSEMBLY",
  4136498852: "IFCCOOLEDBEAM",
  4156078855: "IFCWALLELEMENTEDCASE",
  4175244083: "IFCINTERCEPTOR",
  4207607924: "IFCVALVE",
  4217484030: "IFCCABLESEGMENT",
  4237592921: "IFCWASTETERMINAL",
  4252922144: "IFCSTAIRFLIGHT",
  4278956645: "IFCFLOWFITTING",
  4288193352: "IFCACTUATOR",
  4292641817: "IFCUNITARYEQUIPMENT",
  3009204131: "IFCGRID"
};
class Ul {
  getAll(s, t) {
    const e = {}, i = Object.keys(rc).map((n) => parseInt(n, 10));
    for (let n = 0; n < i.length; n++) {
      const r = i[n], o = s.GetLineIDsWithType(t, r), a = o.size();
      for (let l = 0; l < a; l++)
        e[o.get(l)] = r;
    }
    return e;
  }
}
const zr = {
  950732822: "IFCURIREFERENCE",
  4075327185: "IFCTIME",
  1209108979: "IFCTEMPERATURERATEOFCHANGEMEASURE",
  3457685358: "IFCSOUNDPRESSURELEVELMEASURE",
  4157543285: "IFCSOUNDPOWERLEVELMEASURE",
  2798247006: "IFCPROPERTYSETDEFINITIONSET",
  1790229001: "IFCPOSITIVEINTEGER",
  525895558: "IFCNONNEGATIVELENGTHMEASURE",
  1774176899: "IFCLINEINDEX",
  1275358634: "IFCLANGUAGEID",
  2541165894: "IFCDURATION",
  3701338814: "IFCDAYINWEEKNUMBER",
  2195413836: "IFCDATETIME",
  937566702: "IFCDATE",
  1683019596: "IFCCARDINALPOINTREFERENCE",
  2314439260: "IFCBINARY",
  1500781891: "IFCAREADENSITYMEASURE",
  3683503648: "IFCARCINDEX",
  4065007721: "IFCYEARNUMBER",
  1718600412: "IFCWARPINGMOMENTMEASURE",
  51269191: "IFCWARPINGCONSTANTMEASURE",
  2593997549: "IFCVOLUMETRICFLOWRATEMEASURE",
  3458127941: "IFCVOLUMEMEASURE",
  3345633955: "IFCVAPORPERMEABILITYMEASURE",
  1278329552: "IFCTORQUEMEASURE",
  2591213694: "IFCTIMESTAMP",
  2726807636: "IFCTIMEMEASURE",
  743184107: "IFCTHERMODYNAMICTEMPERATUREMEASURE",
  2016195849: "IFCTHERMALTRANSMITTANCEMEASURE",
  857959152: "IFCTHERMALRESISTANCEMEASURE",
  2281867870: "IFCTHERMALEXPANSIONCOEFFICIENTMEASURE",
  2645777649: "IFCTHERMALCONDUCTIVITYMEASURE",
  232962298: "IFCTHERMALADMITTANCEMEASURE",
  296282323: "IFCTEXTTRANSFORMATION",
  603696268: "IFCTEXTFONTNAME",
  3490877962: "IFCTEXTDECORATION",
  1460886941: "IFCTEXTALIGNMENT",
  2801250643: "IFCTEXT",
  58845555: "IFCTEMPERATUREGRADIENTMEASURE",
  361837227: "IFCSPECULARROUGHNESS",
  2757832317: "IFCSPECULAREXPONENT",
  3477203348: "IFCSPECIFICHEATCAPACITYMEASURE",
  993287707: "IFCSOUNDPRESSUREMEASURE",
  846465480: "IFCSOUNDPOWERMEASURE",
  3471399674: "IFCSOLIDANGLEMEASURE",
  408310005: "IFCSHEARMODULUSMEASURE",
  2190458107: "IFCSECTIONALAREAINTEGRALMEASURE",
  3467162246: "IFCSECTIONMODULUSMEASURE",
  2766185779: "IFCSECONDINMINUTE",
  3211557302: "IFCROTATIONALSTIFFNESSMEASURE",
  1755127002: "IFCROTATIONALMASSMEASURE",
  2133746277: "IFCROTATIONALFREQUENCYMEASURE",
  200335297: "IFCREAL",
  96294661: "IFCRATIOMEASURE",
  3972513137: "IFCRADIOACTIVITYMEASURE",
  3665567075: "IFCPRESSUREMEASURE",
  2169031380: "IFCPRESENTABLETEXT",
  1364037233: "IFCPOWERMEASURE",
  1245737093: "IFCPOSITIVERATIOMEASURE",
  3054510233: "IFCPOSITIVEPLANEANGLEMEASURE",
  2815919920: "IFCPOSITIVELENGTHMEASURE",
  4042175685: "IFCPLANEANGLEMEASURE",
  2642773653: "IFCPLANARFORCEMEASURE",
  2260317790: "IFCPARAMETERVALUE",
  929793134: "IFCPHMEASURE",
  2395907400: "IFCNUMERICMEASURE",
  2095195183: "IFCNORMALISEDRATIOMEASURE",
  765770214: "IFCMONTHINYEARNUMBER",
  2615040989: "IFCMONETARYMEASURE",
  3114022597: "IFCMOMENTOFINERTIAMEASURE",
  1648970520: "IFCMOLECULARWEIGHTMEASURE",
  3177669450: "IFCMOISTUREDIFFUSIVITYMEASURE",
  1753493141: "IFCMODULUSOFSUBGRADEREACTIONMEASURE",
  1052454078: "IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE",
  2173214787: "IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE",
  3341486342: "IFCMODULUSOFELASTICITYMEASURE",
  102610177: "IFCMINUTEINHOUR",
  3531705166: "IFCMASSPERLENGTHMEASURE",
  3124614049: "IFCMASSMEASURE",
  4017473158: "IFCMASSFLOWRATEMEASURE",
  1477762836: "IFCMASSDENSITYMEASURE",
  2486716878: "IFCMAGNETICFLUXMEASURE",
  286949696: "IFCMAGNETICFLUXDENSITYMEASURE",
  151039812: "IFCLUMINOUSINTENSITYMEASURE",
  2755797622: "IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE",
  2095003142: "IFCLUMINOUSFLUXMEASURE",
  503418787: "IFCLOGICAL",
  3086160713: "IFCLINEARVELOCITYMEASURE",
  1307019551: "IFCLINEARSTIFFNESSMEASURE",
  2128979029: "IFCLINEARMOMENTMEASURE",
  191860431: "IFCLINEARFORCEMEASURE",
  1243674935: "IFCLENGTHMEASURE",
  3258342251: "IFCLABEL",
  2054016361: "IFCKINEMATICVISCOSITYMEASURE",
  3192672207: "IFCISOTHERMALMOISTURECAPACITYMEASURE",
  3686016028: "IFCIONCONCENTRATIONMEASURE",
  3809634241: "IFCINTEGERCOUNTRATEMEASURE",
  1939436016: "IFCINTEGER",
  2679005408: "IFCINDUCTANCEMEASURE",
  3358199106: "IFCILLUMINANCEMEASURE",
  983778844: "IFCIDENTIFIER",
  2589826445: "IFCHOURINDAY",
  1158859006: "IFCHEATINGVALUEMEASURE",
  3113092358: "IFCHEATFLUXDENSITYMEASURE",
  3064340077: "IFCGLOBALLYUNIQUEID",
  3044325142: "IFCFREQUENCYMEASURE",
  1361398929: "IFCFORCEMEASURE",
  2590844177: "IFCFONTWEIGHT",
  2715512545: "IFCFONTVARIANT",
  1102727119: "IFCFONTSTYLE",
  2078135608: "IFCENERGYMEASURE",
  2506197118: "IFCELECTRICVOLTAGEMEASURE",
  2951915441: "IFCELECTRICRESISTANCEMEASURE",
  3790457270: "IFCELECTRICCURRENTMEASURE",
  2093906313: "IFCELECTRICCONDUCTANCEMEASURE",
  3818826038: "IFCELECTRICCHARGEMEASURE",
  1827137117: "IFCELECTRICCAPACITANCEMEASURE",
  69416015: "IFCDYNAMICVISCOSITYMEASURE",
  524656162: "IFCDOSEEQUIVALENTMEASURE",
  4134073009: "IFCDIMENSIONCOUNT",
  1514641115: "IFCDESCRIPTIVEMEASURE",
  300323983: "IFCDAYLIGHTSAVINGHOUR",
  86635668: "IFCDAYINMONTHNUMBER",
  94842927: "IFCCURVATUREMEASURE",
  1778710042: "IFCCOUNTMEASURE",
  3238673880: "IFCCONTEXTDEPENDENTMEASURE",
  3812528620: "IFCCOMPOUNDPLANEANGLEMEASURE",
  2991860651: "IFCCOMPLEXNUMBER",
  1867003952: "IFCBOXALIGNMENT",
  2735952531: "IFCBOOLEAN",
  2650437152: "IFCAREAMEASURE",
  632304761: "IFCANGULARVELOCITYMEASURE",
  360377573: "IFCAMOUNTOFSUBSTANCEMEASURE",
  4182062534: "IFCACCELERATIONMEASURE",
  3699917729: "IFCABSORBEDDOSEMEASURE",
  1971632696: "IFCGEOSLICE",
  2680139844: "IFCGEOMODEL",
  24726584: "IFCELECTRICFLOWTREATMENTDEVICE",
  3693000487: "IFCDISTRIBUTIONBOARD",
  3460952963: "IFCCONVEYORSEGMENT",
  3999819293: "IFCCAISSONFOUNDATION",
  3314249567: "IFCBOREHOLE",
  4196446775: "IFCBEARING",
  325726236: "IFCALIGNMENT",
  3425753595: "IFCTRACKELEMENT",
  991950508: "IFCSIGNAL",
  3798194928: "IFCREINFORCEDSOIL",
  3290496277: "IFCRAIL",
  1383356374: "IFCPAVEMENT",
  2182337498: "IFCNAVIGATIONELEMENT",
  234836483: "IFCMOORINGDEVICE",
  2078563270: "IFCMOBILETELECOMMUNICATIONSAPPLIANCE",
  1638804497: "IFCLIQUIDTERMINAL",
  1154579445: "IFCLINEARPOSITIONINGELEMENT",
  2696325953: "IFCKERB",
  2713699986: "IFCGEOTECHNICALASSEMBLY",
  2142170206: "IFCELECTRICFLOWTREATMENTDEVICETYPE",
  3376911765: "IFCEARTHWORKSFILL",
  1077100507: "IFCEARTHWORKSELEMENT",
  3071239417: "IFCEARTHWORKSCUT",
  479945903: "IFCDISTRIBUTIONBOARDTYPE",
  3426335179: "IFCDEEPFOUNDATION",
  1502416096: "IFCCOURSE",
  2940368186: "IFCCONVEYORSEGMENTTYPE",
  3203706013: "IFCCAISSONFOUNDATIONTYPE",
  3862327254: "IFCBUILTSYSTEM",
  1876633798: "IFCBUILTELEMENT",
  963979645: "IFCBRIDGEPART",
  644574406: "IFCBRIDGE",
  3649138523: "IFCBEARINGTYPE",
  1662888072: "IFCALIGNMENTVERTICAL",
  317615605: "IFCALIGNMENTSEGMENT",
  1545765605: "IFCALIGNMENTHORIZONTAL",
  4266260250: "IFCALIGNMENTCANT",
  3956297820: "IFCVIBRATIONDAMPERTYPE",
  1530820697: "IFCVIBRATIONDAMPER",
  840318589: "IFCVEHICLE",
  1953115116: "IFCTRANSPORTATIONDEVICE",
  618700268: "IFCTRACKELEMENTTYPE",
  2281632017: "IFCTENDONCONDUITTYPE",
  3663046924: "IFCTENDONCONDUIT",
  42703149: "IFCSINESPIRAL",
  1894708472: "IFCSIGNALTYPE",
  3599934289: "IFCSIGNTYPE",
  33720170: "IFCSIGN",
  1027922057: "IFCSEVENTHORDERPOLYNOMIALSPIRAL",
  544395925: "IFCSEGMENTEDREFERENCECURVE",
  3649235739: "IFCSECONDORDERPOLYNOMIALSPIRAL",
  550521510: "IFCROADPART",
  146592293: "IFCROAD",
  3818125796: "IFCRELADHERESTOELEMENT",
  4021432810: "IFCREFERENT",
  1891881377: "IFCRAILWAYPART",
  3992365140: "IFCRAILWAY",
  1763565496: "IFCRAILTYPE",
  1946335990: "IFCPOSITIONINGELEMENT",
  514975943: "IFCPAVEMENTTYPE",
  506776471: "IFCNAVIGATIONELEMENTTYPE",
  710110818: "IFCMOORINGDEVICETYPE",
  1950438474: "IFCMOBILETELECOMMUNICATIONSAPPLIANCETYPE",
  976884017: "IFCMARINEPART",
  525669439: "IFCMARINEFACILITY",
  1770583370: "IFCLIQUIDTERMINALTYPE",
  2176059722: "IFCLINEARELEMENT",
  679976338: "IFCKERBTYPE",
  3948183225: "IFCIMPACTPROTECTIONDEVICETYPE",
  2568555532: "IFCIMPACTPROTECTIONDEVICE",
  2898700619: "IFCGRADIENTCURVE",
  1594536857: "IFCGEOTECHNICALSTRATUM",
  4230923436: "IFCGEOTECHNICALELEMENT",
  4228831410: "IFCFACILITYPARTCOMMON",
  1310830890: "IFCFACILITYPART",
  24185140: "IFCFACILITY",
  4234616927: "IFCDIRECTRIXDERIVEDREFERENCESWEPTAREASOLID",
  1306400036: "IFCDEEPFOUNDATIONTYPE",
  4189326743: "IFCCOURSETYPE",
  2000195564: "IFCCOSINESPIRAL",
  3497074424: "IFCCLOTHOID",
  1626504194: "IFCBUILTELEMENTTYPE",
  3651464721: "IFCVEHICLETYPE",
  1229763772: "IFCTRIANGULATEDIRREGULARNETWORK",
  3665877780: "IFCTRANSPORTATIONDEVICETYPE",
  782932809: "IFCTHIRDORDERPOLYNOMIALSPIRAL",
  2735484536: "IFCSPIRAL",
  1356537516: "IFCSECTIONEDSURFACE",
  1290935644: "IFCSECTIONEDSOLIDHORIZONTAL",
  1862484736: "IFCSECTIONEDSOLID",
  1441486842: "IFCRELPOSITIONS",
  1033248425: "IFCRELASSOCIATESPROFILEDEF",
  3381221214: "IFCPOLYNOMIALCURVE",
  2485787929: "IFCOFFSETCURVEBYDISTANCES",
  590820931: "IFCOFFSETCURVE",
  3465909080: "IFCINDEXEDPOLYGONALTEXTUREMAP",
  593015953: "IFCDIRECTRIXCURVESWEPTAREASOLID",
  4212018352: "IFCCURVESEGMENT",
  3425423356: "IFCAXIS2PLACEMENTLINEAR",
  823603102: "IFCSEGMENT",
  2165702409: "IFCPOINTBYDISTANCEEXPRESSION",
  182550632: "IFCOPENCROSSPROFILEDEF",
  388784114: "IFCLINEARPLACEMENT",
  536804194: "IFCALIGNMENTHORIZONTALSEGMENT",
  3752311538: "IFCALIGNMENTCANTSEGMENT",
  1010789467: "IFCTEXTURECOORDINATEINDICESWITHVOIDS",
  222769930: "IFCTEXTURECOORDINATEINDICES",
  2691318326: "IFCQUANTITYNUMBER",
  3633395639: "IFCALIGNMENTVERTICALSEGMENT",
  2879124712: "IFCALIGNMENTPARAMETERSEGMENT",
  25142252: "IFCCONTROLLER",
  3087945054: "IFCALARM",
  4288193352: "IFCACTUATOR",
  630975310: "IFCUNITARYCONTROLELEMENT",
  4086658281: "IFCSENSOR",
  2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
  182646315: "IFCFLOWINSTRUMENT",
  1426591983: "IFCFIRESUPPRESSIONTERMINAL",
  819412036: "IFCFILTER",
  3415622556: "IFCFAN",
  1003880860: "IFCELECTRICTIMECONTROL",
  402227799: "IFCELECTRICMOTOR",
  264262732: "IFCELECTRICGENERATOR",
  3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
  862014818: "IFCELECTRICDISTRIBUTIONBOARD",
  1904799276: "IFCELECTRICAPPLIANCE",
  1360408905: "IFCDUCTSILENCER",
  3518393246: "IFCDUCTSEGMENT",
  342316401: "IFCDUCTFITTING",
  562808652: "IFCDISTRIBUTIONCIRCUIT",
  4074379575: "IFCDAMPER",
  3640358203: "IFCCOOLINGTOWER",
  4136498852: "IFCCOOLEDBEAM",
  2272882330: "IFCCONDENSER",
  3571504051: "IFCCOMPRESSOR",
  3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
  639361253: "IFCCOIL",
  3902619387: "IFCCHILLER",
  4217484030: "IFCCABLESEGMENT",
  1051757585: "IFCCABLEFITTING",
  3758799889: "IFCCABLECARRIERSEGMENT",
  635142910: "IFCCABLECARRIERFITTING",
  2938176219: "IFCBURNER",
  32344328: "IFCBOILER",
  2906023776: "IFCBEAMSTANDARDCASE",
  277319702: "IFCAUDIOVISUALAPPLIANCE",
  2056796094: "IFCAIRTOAIRHEATRECOVERY",
  177149247: "IFCAIRTERMINALBOX",
  1634111441: "IFCAIRTERMINAL",
  486154966: "IFCWINDOWSTANDARDCASE",
  4237592921: "IFCWASTETERMINAL",
  4156078855: "IFCWALLELEMENTEDCASE",
  4207607924: "IFCVALVE",
  4292641817: "IFCUNITARYEQUIPMENT",
  3179687236: "IFCUNITARYCONTROLELEMENTTYPE",
  3026737570: "IFCTUBEBUNDLE",
  3825984169: "IFCTRANSFORMER",
  812556717: "IFCTANK",
  1162798199: "IFCSWITCHINGDEVICE",
  385403989: "IFCSTRUCTURALLOADCASE",
  1404847402: "IFCSTACKTERMINAL",
  1999602285: "IFCSPACEHEATER",
  3420628829: "IFCSOLARDEVICE",
  3027962421: "IFCSLABSTANDARDCASE",
  3127900445: "IFCSLABELEMENTEDCASE",
  1329646415: "IFCSHADINGDEVICE",
  3053780830: "IFCSANITARYTERMINAL",
  2572171363: "IFCREINFORCINGBARTYPE",
  1232101972: "IFCRATIONALBSPLINECURVEWITHKNOTS",
  90941305: "IFCPUMP",
  655969474: "IFCPROTECTIVEDEVICETRIPPINGUNITTYPE",
  738039164: "IFCPROTECTIVEDEVICE",
  1156407060: "IFCPLATESTANDARDCASE",
  3612865200: "IFCPIPESEGMENT",
  310824031: "IFCPIPEFITTING",
  3694346114: "IFCOUTLET",
  144952367: "IFCOUTERBOUNDARYCURVE",
  2474470126: "IFCMOTORCONNECTION",
  1911478936: "IFCMEMBERSTANDARDCASE",
  1437502449: "IFCMEDICALDEVICE",
  629592764: "IFCLIGHTFIXTURE",
  76236018: "IFCLAMP",
  2176052936: "IFCJUNCTIONBOX",
  4175244083: "IFCINTERCEPTOR",
  2068733104: "IFCHUMIDIFIER",
  3319311131: "IFCHEATEXCHANGER",
  2188021234: "IFCFLOWMETER",
  1209101575: "IFCEXTERNALSPATIALELEMENT",
  484807127: "IFCEVAPORATOR",
  3747195512: "IFCEVAPORATIVECOOLER",
  2814081492: "IFCENGINE",
  2417008758: "IFCELECTRICDISTRIBUTIONBOARDTYPE",
  3242481149: "IFCDOORSTANDARDCASE",
  3205830791: "IFCDISTRIBUTIONSYSTEM",
  400855858: "IFCCOMMUNICATIONSAPPLIANCETYPE",
  905975707: "IFCCOLUMNSTANDARDCASE",
  1677625105: "IFCCIVILELEMENT",
  3296154744: "IFCCHIMNEY",
  2674252688: "IFCCABLEFITTINGTYPE",
  2188180465: "IFCBURNERTYPE",
  1177604601: "IFCBUILDINGSYSTEM",
  39481116: "IFCBUILDINGELEMENTPARTTYPE",
  1136057603: "IFCBOUNDARYCURVE",
  2461110595: "IFCBSPLINECURVEWITHKNOTS",
  1532957894: "IFCAUDIOVISUALAPPLIANCETYPE",
  4088093105: "IFCWORKCALENDAR",
  4009809668: "IFCWINDOWTYPE",
  926996030: "IFCVOIDINGFEATURE",
  2391383451: "IFCVIBRATIONISOLATOR",
  2415094496: "IFCTENDONTYPE",
  3081323446: "IFCTENDONANCHORTYPE",
  413509423: "IFCSYSTEMFURNITUREELEMENT",
  3101698114: "IFCSURFACEFEATURE",
  3657597509: "IFCSTRUCTURALSURFACEACTION",
  2757150158: "IFCSTRUCTURALCURVEREACTION",
  1004757350: "IFCSTRUCTURALCURVEACTION",
  338393293: "IFCSTAIRTYPE",
  1072016465: "IFCSOLARDEVICETYPE",
  4074543187: "IFCSHADINGDEVICETYPE",
  2157484638: "IFCSEAMCURVE",
  2781568857: "IFCROOFTYPE",
  2310774935: "IFCREINFORCINGMESHTYPE",
  964333572: "IFCREINFORCINGELEMENTTYPE",
  683857671: "IFCRATIONALBSPLINESURFACEWITHKNOTS",
  1469900589: "IFCRAMPTYPE",
  2839578677: "IFCPOLYGONALFACESET",
  1158309216: "IFCPILETYPE",
  3079942009: "IFCOPENINGSTANDARDCASE",
  1114901282: "IFCMEDICALDEVICETYPE",
  3113134337: "IFCINTERSECTIONCURVE",
  3946677679: "IFCINTERCEPTORTYPE",
  2571569899: "IFCINDEXEDPOLYCURVE",
  3493046030: "IFCGEOGRAPHICELEMENT",
  1509553395: "IFCFURNITURE",
  1893162501: "IFCFOOTINGTYPE",
  2853485674: "IFCEXTERNALSPATIALSTRUCTUREELEMENT",
  4148101412: "IFCEVENT",
  132023988: "IFCENGINETYPE",
  2397081782: "IFCELEMENTASSEMBLYTYPE",
  2323601079: "IFCDOORTYPE",
  1213902940: "IFCCYLINDRICALSURFACE",
  1525564444: "IFCCONSTRUCTIONPRODUCTRESOURCETYPE",
  4105962743: "IFCCONSTRUCTIONMATERIALRESOURCETYPE",
  2185764099: "IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE",
  15328376: "IFCCOMPOSITECURVEONSURFACE",
  3875453745: "IFCCOMPLEXPROPERTYTEMPLATE",
  3893394355: "IFCCIVILELEMENTTYPE",
  2197970202: "IFCCHIMNEYTYPE",
  167062518: "IFCBSPLINESURFACEWITHKNOTS",
  2887950389: "IFCBSPLINESURFACE",
  2603310189: "IFCADVANCEDBREPWITHVOIDS",
  1635779807: "IFCADVANCEDBREP",
  2916149573: "IFCTRIANGULATEDFACESET",
  1935646853: "IFCTOROIDALSURFACE",
  2387106220: "IFCTESSELLATEDFACESET",
  3206491090: "IFCTASKTYPE",
  699246055: "IFCSURFACECURVE",
  4095615324: "IFCSUBCONTRACTRESOURCETYPE",
  603775116: "IFCSTRUCTURALSURFACEREACTION",
  4015995234: "IFCSPHERICALSURFACE",
  2481509218: "IFCSPATIALZONETYPE",
  463610769: "IFCSPATIALZONE",
  710998568: "IFCSPATIALELEMENTTYPE",
  1412071761: "IFCSPATIALELEMENT",
  3663146110: "IFCSIMPLEPROPERTYTEMPLATE",
  3243963512: "IFCREVOLVEDAREASOLIDTAPERED",
  816062949: "IFCREPARAMETRISEDCOMPOSITECURVESEGMENT",
  1521410863: "IFCRELSPACEBOUNDARY2NDLEVEL",
  3523091289: "IFCRELSPACEBOUNDARY1STLEVEL",
  427948657: "IFCRELINTERFERESELEMENTS",
  307848117: "IFCRELDEFINESBYTEMPLATE",
  1462361463: "IFCRELDEFINESBYOBJECT",
  2565941209: "IFCRELDECLARES",
  1027710054: "IFCRELASSIGNSTOGROUPBYFACTOR",
  3521284610: "IFCPROPERTYTEMPLATE",
  492091185: "IFCPROPERTYSETTEMPLATE",
  653396225: "IFCPROJECTLIBRARY",
  569719735: "IFCPROCEDURETYPE",
  3967405729: "IFCPREDEFINEDPROPERTYSET",
  1682466193: "IFCPCURVE",
  428585644: "IFCLABORRESOURCETYPE",
  2294589976: "IFCINDEXEDPOLYGONALFACEWITHVOIDS",
  178912537: "IFCINDEXEDPOLYGONALFACE",
  4095422895: "IFCGEOGRAPHICELEMENTTYPE",
  2652556860: "IFCFIXEDREFERENCESWEPTAREASOLID",
  2804161546: "IFCEXTRUDEDAREASOLIDTAPERED",
  4024345920: "IFCEVENTTYPE",
  2629017746: "IFCCURVEBOUNDEDSURFACE",
  1815067380: "IFCCREWRESOURCETYPE",
  3419103109: "IFCCONTEXT",
  2574617495: "IFCCONSTRUCTIONRESOURCETYPE",
  2059837836: "IFCCARTESIANPOINTLIST3D",
  1675464909: "IFCCARTESIANPOINTLIST2D",
  574549367: "IFCCARTESIANPOINTLIST",
  3406155212: "IFCADVANCEDFACE",
  3698973494: "IFCTYPERESOURCE",
  3736923433: "IFCTYPEPROCESS",
  901063453: "IFCTESSELLATEDITEM",
  1096409881: "IFCSWEPTDISKSOLIDPOLYGONAL",
  1042787934: "IFCRESOURCETIME",
  1608871552: "IFCRESOURCECONSTRAINTRELATIONSHIP",
  2943643501: "IFCRESOURCEAPPROVALRELATIONSHIP",
  2090586900: "IFCQUANTITYSET",
  1482703590: "IFCPROPERTYTEMPLATEDEFINITION",
  3778827333: "IFCPREDEFINEDPROPERTIES",
  2998442950: "IFCMIRROREDPROFILEDEF",
  853536259: "IFCMATERIALRELATIONSHIP",
  3404854881: "IFCMATERIALPROFILESETUSAGETAPERING",
  3079605661: "IFCMATERIALPROFILESETUSAGE",
  2852063980: "IFCMATERIALCONSTITUENTSET",
  3708119e3: "IFCMATERIALCONSTITUENT",
  1585845231: "IFCLAGTIME",
  2133299955: "IFCINDEXEDTRIANGLETEXTUREMAP",
  1437953363: "IFCINDEXEDTEXTUREMAP",
  3570813810: "IFCINDEXEDCOLOURMAP",
  1437805879: "IFCEXTERNALREFERENCERELATIONSHIP",
  297599258: "IFCEXTENDEDPROPERTIES",
  211053100: "IFCEVENTTIME",
  2713554722: "IFCCONVERSIONBASEDUNITWITHOFFSET",
  3285139300: "IFCCOLOURRGBLIST",
  1236880293: "IFCWORKTIME",
  1199560280: "IFCTIMEPERIOD",
  3611470254: "IFCTEXTUREVERTEXLIST",
  2771591690: "IFCTASKTIMERECURRING",
  1549132990: "IFCTASKTIME",
  2043862942: "IFCTABLECOLUMN",
  2934153892: "IFCSURFACEREINFORCEMENTAREA",
  609421318: "IFCSTRUCTURALLOADORRESULT",
  3478079324: "IFCSTRUCTURALLOADCONFIGURATION",
  1054537805: "IFCSCHEDULINGTIME",
  2439245199: "IFCRESOURCELEVELRELATIONSHIP",
  2433181523: "IFCREFERENCE",
  3915482550: "IFCRECURRENCEPATTERN",
  986844984: "IFCPROPERTYABSTRACTION",
  3843373140: "IFCPROJECTEDCRS",
  677532197: "IFCPRESENTATIONITEM",
  1507914824: "IFCMATERIALUSAGEDEFINITION",
  552965576: "IFCMATERIALPROFILEWITHOFFSETS",
  164193824: "IFCMATERIALPROFILESET",
  2235152071: "IFCMATERIALPROFILE",
  1847252529: "IFCMATERIALLAYERWITHOFFSETS",
  760658860: "IFCMATERIALDEFINITION",
  3057273783: "IFCMAPCONVERSION",
  4294318154: "IFCEXTERNALINFORMATION",
  1466758467: "IFCCOORDINATEREFERENCESYSTEM",
  1785450214: "IFCCOORDINATEOPERATION",
  775493141: "IFCCONNECTIONVOLUMEGEOMETRY",
  979691226: "IFCREINFORCINGBAR",
  3700593921: "IFCELECTRICDISTRIBUTIONPOINT",
  1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
  1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
  578613899: "IFCCONTROLLERTYPE",
  2454782716: "IFCCHAMFEREDGEFEATURE",
  753842376: "IFCBEAM",
  3001207471: "IFCALARMTYPE",
  2874132201: "IFCACTUATORTYPE",
  3304561284: "IFCWINDOW",
  3512223829: "IFCWALLSTANDARDCASE",
  2391406946: "IFCWALL",
  3313531582: "IFCVIBRATIONISOLATORTYPE",
  2347447852: "IFCTENDONANCHOR",
  3824725483: "IFCTENDON",
  2515109513: "IFCSTRUCTURALANALYSISMODEL",
  4252922144: "IFCSTAIRFLIGHT",
  331165859: "IFCSTAIR",
  1529196076: "IFCSLAB",
  1783015770: "IFCSENSORTYPE",
  1376911519: "IFCROUNDEDEDGEFEATURE",
  2016517767: "IFCROOF",
  2320036040: "IFCREINFORCINGMESH",
  3027567501: "IFCREINFORCINGELEMENT",
  3055160366: "IFCRATIONALBEZIERCURVE",
  3283111854: "IFCRAMPFLIGHT",
  3024970846: "IFCRAMP",
  2262370178: "IFCRAILING",
  3171933400: "IFCPLATE",
  1687234759: "IFCPILE",
  1073191201: "IFCMEMBER",
  900683007: "IFCFOOTING",
  3508470533: "IFCFLOWTREATMENTDEVICE",
  2223149337: "IFCFLOWTERMINAL",
  707683696: "IFCFLOWSTORAGEDEVICE",
  987401354: "IFCFLOWSEGMENT",
  3132237377: "IFCFLOWMOVINGDEVICE",
  4037862832: "IFCFLOWINSTRUMENTTYPE",
  4278956645: "IFCFLOWFITTING",
  2058353004: "IFCFLOWCONTROLLER",
  4222183408: "IFCFIRESUPPRESSIONTERMINALTYPE",
  1810631287: "IFCFILTERTYPE",
  346874300: "IFCFANTYPE",
  1658829314: "IFCENERGYCONVERSIONDEVICE",
  857184966: "IFCELECTRICALELEMENT",
  1634875225: "IFCELECTRICALCIRCUIT",
  712377611: "IFCELECTRICTIMECONTROLTYPE",
  1217240411: "IFCELECTRICMOTORTYPE",
  1365060375: "IFCELECTRICHEATERTYPE",
  1534661035: "IFCELECTRICGENERATORTYPE",
  3277789161: "IFCELECTRICFLOWSTORAGEDEVICETYPE",
  663422040: "IFCELECTRICAPPLIANCETYPE",
  855621170: "IFCEDGEFEATURE",
  2030761528: "IFCDUCTSILENCERTYPE",
  3760055223: "IFCDUCTSEGMENTTYPE",
  869906466: "IFCDUCTFITTINGTYPE",
  395920057: "IFCDOOR",
  3041715199: "IFCDISTRIBUTIONPORT",
  3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
  1945004755: "IFCDISTRIBUTIONELEMENT",
  2063403501: "IFCDISTRIBUTIONCONTROLELEMENTTYPE",
  1599208980: "IFCDISTRIBUTIONCHAMBERELEMENTTYPE",
  2635815018: "IFCDISCRETEACCESSORYTYPE",
  1335981549: "IFCDISCRETEACCESSORY",
  4147604152: "IFCDIAMETERDIMENSION",
  3961806047: "IFCDAMPERTYPE",
  3495092785: "IFCCURTAINWALL",
  1973544240: "IFCCOVERING",
  2954562838: "IFCCOOLINGTOWERTYPE",
  335055490: "IFCCOOLEDBEAMTYPE",
  488727124: "IFCCONSTRUCTIONPRODUCTRESOURCE",
  1060000209: "IFCCONSTRUCTIONMATERIALRESOURCE",
  3898045240: "IFCCONSTRUCTIONEQUIPMENTRESOURCE",
  1163958913: "IFCCONDITIONCRITERION",
  2188551683: "IFCCONDITION",
  2816379211: "IFCCONDENSERTYPE",
  3850581409: "IFCCOMPRESSORTYPE",
  843113511: "IFCCOLUMN",
  2301859152: "IFCCOILTYPE",
  2611217952: "IFCCIRCLE",
  2951183804: "IFCCHILLERTYPE",
  1285652485: "IFCCABLESEGMENTTYPE",
  3293546465: "IFCCABLECARRIERSEGMENTTYPE",
  395041908: "IFCCABLECARRIERFITTINGTYPE",
  1909888760: "IFCBUILDINGELEMENTPROXYTYPE",
  1095909175: "IFCBUILDINGELEMENTPROXY",
  2979338954: "IFCBUILDINGELEMENTPART",
  52481810: "IFCBUILDINGELEMENTCOMPONENT",
  3299480353: "IFCBUILDINGELEMENT",
  231477066: "IFCBOILERTYPE",
  1916977116: "IFCBEZIERCURVE",
  819618141: "IFCBEAMTYPE",
  1967976161: "IFCBSPLINECURVE",
  3460190687: "IFCASSET",
  2470393545: "IFCANGULARDIMENSION",
  1871374353: "IFCAIRTOAIRHEATRECOVERYTYPE",
  3352864051: "IFCAIRTERMINALTYPE",
  1411407467: "IFCAIRTERMINALBOXTYPE",
  3821786052: "IFCACTIONREQUEST",
  1213861670: "IFC2DCOMPOSITECURVE",
  1033361043: "IFCZONE",
  3342526732: "IFCWORKSCHEDULE",
  4218914973: "IFCWORKPLAN",
  1028945134: "IFCWORKCONTROL",
  1133259667: "IFCWASTETERMINALTYPE",
  1898987631: "IFCWALLTYPE",
  2769231204: "IFCVIRTUALELEMENT",
  728799441: "IFCVALVETYPE",
  1911125066: "IFCUNITARYEQUIPMENTTYPE",
  1600972822: "IFCTUBEBUNDLETYPE",
  3593883385: "IFCTRIMMEDCURVE",
  1620046519: "IFCTRANSPORTELEMENT",
  1692211062: "IFCTRANSFORMERTYPE",
  1637806684: "IFCTIMESERIESSCHEDULE",
  5716631: "IFCTANKTYPE",
  2254336722: "IFCSYSTEM",
  2315554128: "IFCSWITCHINGDEVICETYPE",
  148013059: "IFCSUBCONTRACTRESOURCE",
  1975003073: "IFCSTRUCTURALSURFACECONNECTION",
  2986769608: "IFCSTRUCTURALRESULTGROUP",
  1235345126: "IFCSTRUCTURALPOINTREACTION",
  734778138: "IFCSTRUCTURALPOINTCONNECTION",
  2082059205: "IFCSTRUCTURALPOINTACTION",
  3987759626: "IFCSTRUCTURALPLANARACTIONVARYING",
  1621171031: "IFCSTRUCTURALPLANARACTION",
  1252848954: "IFCSTRUCTURALLOADGROUP",
  1721250024: "IFCSTRUCTURALLINEARACTIONVARYING",
  1807405624: "IFCSTRUCTURALLINEARACTION",
  2445595289: "IFCSTRUCTURALCURVEMEMBERVARYING",
  214636428: "IFCSTRUCTURALCURVEMEMBER",
  4243806635: "IFCSTRUCTURALCURVECONNECTION",
  1179482911: "IFCSTRUCTURALCONNECTION",
  682877961: "IFCSTRUCTURALACTION",
  1039846685: "IFCSTAIRFLIGHTTYPE",
  3112655638: "IFCSTACKTERMINALTYPE",
  3812236995: "IFCSPACETYPE",
  652456506: "IFCSPACEPROGRAM",
  1305183839: "IFCSPACEHEATERTYPE",
  3856911033: "IFCSPACE",
  2533589738: "IFCSLABTYPE",
  4097777520: "IFCSITE",
  4105383287: "IFCSERVICELIFE",
  3517283431: "IFCSCHEDULETIMECONTROL",
  1768891740: "IFCSANITARYTERMINALTYPE",
  2863920197: "IFCRELASSIGNSTASKS",
  160246688: "IFCRELAGGREGATES",
  2324767716: "IFCRAMPFLIGHTTYPE",
  2893384427: "IFCRAILINGTYPE",
  3248260540: "IFCRADIUSDIMENSION",
  2250791053: "IFCPUMPTYPE",
  1842657554: "IFCPROTECTIVEDEVICETYPE",
  3651124850: "IFCPROJECTIONELEMENT",
  3642467123: "IFCPROJECTORDERRECORD",
  2904328755: "IFCPROJECTORDER",
  2744685151: "IFCPROCEDURE",
  3740093272: "IFCPORT",
  3724593414: "IFCPOLYLINE",
  4017108033: "IFCPLATETYPE",
  4231323485: "IFCPIPESEGMENTTYPE",
  804291784: "IFCPIPEFITTINGTYPE",
  3327091369: "IFCPERMIT",
  2382730787: "IFCPERFORMANCEHISTORY",
  2837617999: "IFCOUTLETTYPE",
  3425660407: "IFCORDERACTION",
  3588315303: "IFCOPENINGELEMENT",
  4143007308: "IFCOCCUPANT",
  1916936684: "IFCMOVE",
  977012517: "IFCMOTORCONNECTIONTYPE",
  3181161470: "IFCMEMBERTYPE",
  2108223431: "IFCMECHANICALFASTENERTYPE",
  377706215: "IFCMECHANICALFASTENER",
  2506943328: "IFCLINEARDIMENSION",
  1161773419: "IFCLIGHTFIXTURETYPE",
  1051575348: "IFCLAMPTYPE",
  3827777499: "IFCLABORRESOURCE",
  4288270099: "IFCJUNCTIONBOXTYPE",
  2391368822: "IFCINVENTORY",
  1806887404: "IFCHUMIDIFIERTYPE",
  1251058090: "IFCHEATEXCHANGERTYPE",
  2706460486: "IFCGROUP",
  3009204131: "IFCGRID",
  200128114: "IFCGASTERMINALTYPE",
  814719939: "IFCFURNITURESTANDARD",
  263784265: "IFCFURNISHINGELEMENT",
  3009222698: "IFCFLOWTREATMENTDEVICETYPE",
  2297155007: "IFCFLOWTERMINALTYPE",
  1339347760: "IFCFLOWSTORAGEDEVICETYPE",
  1834744321: "IFCFLOWSEGMENTTYPE",
  1482959167: "IFCFLOWMOVINGDEVICETYPE",
  3815607619: "IFCFLOWMETERTYPE",
  3198132628: "IFCFLOWFITTINGTYPE",
  3907093117: "IFCFLOWCONTROLLERTYPE",
  1287392070: "IFCFEATUREELEMENTSUBTRACTION",
  2143335405: "IFCFEATUREELEMENTADDITION",
  2827207264: "IFCFEATUREELEMENT",
  2489546625: "IFCFASTENERTYPE",
  647756555: "IFCFASTENER",
  3737207727: "IFCFACETEDBREPWITHVOIDS",
  807026263: "IFCFACETEDBREP",
  3390157468: "IFCEVAPORATORTYPE",
  3174744832: "IFCEVAPORATIVECOOLERTYPE",
  3272907226: "IFCEQUIPMENTSTANDARD",
  1962604670: "IFCEQUIPMENTELEMENT",
  2107101300: "IFCENERGYCONVERSIONDEVICETYPE",
  1704287377: "IFCELLIPSE",
  2590856083: "IFCELEMENTCOMPONENTTYPE",
  1623761950: "IFCELEMENTCOMPONENT",
  4123344466: "IFCELEMENTASSEMBLY",
  1758889154: "IFCELEMENT",
  360485395: "IFCELECTRICALBASEPROPERTIES",
  3849074793: "IFCDISTRIBUTIONFLOWELEMENTTYPE",
  3256556792: "IFCDISTRIBUTIONELEMENTTYPE",
  681481545: "IFCDIMENSIONCURVEDIRECTEDCALLOUT",
  1457835157: "IFCCURTAINWALLTYPE",
  3295246426: "IFCCREWRESOURCE",
  1916426348: "IFCCOVERINGTYPE",
  1419761937: "IFCCOSTSCHEDULE",
  3895139033: "IFCCOSTITEM",
  3293443760: "IFCCONTROL",
  2559216714: "IFCCONSTRUCTIONRESOURCE",
  2510884976: "IFCCONIC",
  3732776249: "IFCCOMPOSITECURVE",
  300633059: "IFCCOLUMNTYPE",
  2937912522: "IFCCIRCLEHOLLOWPROFILEDEF",
  3124254112: "IFCBUILDINGSTOREY",
  1950629157: "IFCBUILDINGELEMENTTYPE",
  4031249490: "IFCBUILDING",
  1260505505: "IFCBOUNDEDCURVE",
  3649129432: "IFCBOOLEANCLIPPINGRESULT",
  1334484129: "IFCBLOCK",
  3207858831: "IFCASYMMETRICISHAPEPROFILEDEF",
  1674181508: "IFCANNOTATION",
  2296667514: "IFCACTOR",
  2097647324: "IFCTRANSPORTELEMENTTYPE",
  3473067441: "IFCTASK",
  1580310250: "IFCSYSTEMFURNITUREELEMENTTYPE",
  4124788165: "IFCSURFACEOFREVOLUTION",
  2809605785: "IFCSURFACEOFLINEAREXTRUSION",
  2028607225: "IFCSURFACECURVESWEPTAREASOLID",
  4070609034: "IFCSTRUCTUREDDIMENSIONCALLOUT",
  2218152070: "IFCSTRUCTURALSURFACEMEMBERVARYING",
  3979015343: "IFCSTRUCTURALSURFACEMEMBER",
  3689010777: "IFCSTRUCTURALREACTION",
  530289379: "IFCSTRUCTURALMEMBER",
  3136571912: "IFCSTRUCTURALITEM",
  3544373492: "IFCSTRUCTURALACTIVITY",
  451544542: "IFCSPHERE",
  3893378262: "IFCSPATIALSTRUCTUREELEMENTTYPE",
  2706606064: "IFCSPATIALSTRUCTUREELEMENT",
  3626867408: "IFCRIGHTCIRCULARCYLINDER",
  4158566097: "IFCRIGHTCIRCULARCONE",
  1856042241: "IFCREVOLVEDAREASOLID",
  2914609552: "IFCRESOURCE",
  1401173127: "IFCRELVOIDSELEMENT",
  3451746338: "IFCRELSPACEBOUNDARY",
  366585022: "IFCRELSERVICESBUILDINGS",
  4122056220: "IFCRELSEQUENCE",
  1058617721: "IFCRELSCHEDULESCOSTITEMS",
  1245217292: "IFCRELREFERENCEDINSPATIALSTRUCTURE",
  750771296: "IFCRELPROJECTSELEMENT",
  202636808: "IFCRELOVERRIDESPROPERTIES",
  2051452291: "IFCRELOCCUPIESSPACES",
  3268803585: "IFCRELNESTS",
  4189434867: "IFCRELINTERACTIONREQUIREMENTS",
  279856033: "IFCRELFLOWCONTROLELEMENTS",
  3940055652: "IFCRELFILLSELEMENT",
  781010003: "IFCRELDEFINESBYTYPE",
  4186316022: "IFCRELDEFINESBYPROPERTIES",
  693640335: "IFCRELDEFINES",
  2551354335: "IFCRELDECOMPOSES",
  2802773753: "IFCRELCOVERSSPACES",
  886880790: "IFCRELCOVERSBLDGELEMENTS",
  3242617779: "IFCRELCONTAINEDINSPATIALSTRUCTURE",
  3678494232: "IFCRELCONNECTSWITHREALIZINGELEMENTS",
  504942748: "IFCRELCONNECTSWITHECCENTRICITY",
  1638771189: "IFCRELCONNECTSSTRUCTURALMEMBER",
  3912681535: "IFCRELCONNECTSSTRUCTURALELEMENT",
  2127690289: "IFCRELCONNECTSSTRUCTURALACTIVITY",
  3190031847: "IFCRELCONNECTSPORTS",
  4201705270: "IFCRELCONNECTSPORTTOELEMENT",
  3945020480: "IFCRELCONNECTSPATHELEMENTS",
  1204542856: "IFCRELCONNECTSELEMENTS",
  826625072: "IFCRELCONNECTS",
  2851387026: "IFCRELASSOCIATESPROFILEPROPERTIES",
  2655215786: "IFCRELASSOCIATESMATERIAL",
  3840914261: "IFCRELASSOCIATESLIBRARY",
  982818633: "IFCRELASSOCIATESDOCUMENT",
  2728634034: "IFCRELASSOCIATESCONSTRAINT",
  919958153: "IFCRELASSOCIATESCLASSIFICATION",
  4095574036: "IFCRELASSOCIATESAPPROVAL",
  1327628568: "IFCRELASSOCIATESAPPLIEDVALUE",
  1865459582: "IFCRELASSOCIATES",
  205026976: "IFCRELASSIGNSTORESOURCE",
  3372526763: "IFCRELASSIGNSTOPROJECTORDER",
  2857406711: "IFCRELASSIGNSTOPRODUCT",
  4278684876: "IFCRELASSIGNSTOPROCESS",
  1307041759: "IFCRELASSIGNSTOGROUP",
  2495723537: "IFCRELASSIGNSTOCONTROL",
  1683148259: "IFCRELASSIGNSTOACTOR",
  3939117080: "IFCRELASSIGNS",
  3454111270: "IFCRECTANGULARTRIMMEDSURFACE",
  2798486643: "IFCRECTANGULARPYRAMID",
  2770003689: "IFCRECTANGLEHOLLOWPROFILEDEF",
  3219374653: "IFCPROXY",
  1451395588: "IFCPROPERTYSET",
  4194566429: "IFCPROJECTIONCURVE",
  103090709: "IFCPROJECT",
  4208778838: "IFCPRODUCT",
  2945172077: "IFCPROCESS",
  220341763: "IFCPLANE",
  603570806: "IFCPLANARBOX",
  3566463478: "IFCPERMEABLECOVERINGPROPERTIES",
  3505215534: "IFCOFFSETCURVE3D",
  3388369263: "IFCOFFSETCURVE2D",
  3888040117: "IFCOBJECT",
  1425443689: "IFCMANIFOLDSOLIDBREP",
  1281925730: "IFCLINE",
  572779678: "IFCLSHAPEPROFILEDEF",
  1484403080: "IFCISHAPEPROFILEDEF",
  987898635: "IFCGEOMETRICCURVESET",
  1268542332: "IFCFURNITURETYPE",
  4238390223: "IFCFURNISHINGELEMENTTYPE",
  3455213021: "IFCFLUIDFLOWPROPERTIES",
  315944413: "IFCFILLAREASTYLETILES",
  4203026998: "IFCFILLAREASTYLETILESYMBOLWITHSTYLE",
  374418227: "IFCFILLAREASTYLEHATCHING",
  2047409740: "IFCFACEBASEDSURFACEMODEL",
  477187591: "IFCEXTRUDEDAREASOLID",
  80994333: "IFCENERGYPROPERTIES",
  2835456948: "IFCELLIPSEPROFILEDEF",
  2777663545: "IFCELEMENTARYSURFACE",
  339256511: "IFCELEMENTTYPE",
  1883228015: "IFCELEMENTQUANTITY",
  1472233963: "IFCEDGELOOP",
  4006246654: "IFCDRAUGHTINGPREDEFINEDCURVEFONT",
  445594917: "IFCDRAUGHTINGPREDEFINEDCOLOUR",
  3073041342: "IFCDRAUGHTINGCALLOUT",
  526551008: "IFCDOORSTYLE",
  1714330368: "IFCDOORPANELPROPERTIES",
  2963535650: "IFCDOORLININGPROPERTIES",
  32440307: "IFCDIRECTION",
  4054601972: "IFCDIMENSIONCURVETERMINATOR",
  606661476: "IFCDIMENSIONCURVE",
  693772133: "IFCDEFINEDSYMBOL",
  2827736869: "IFCCURVEBOUNDEDPLANE",
  2601014836: "IFCCURVE",
  2147822146: "IFCCSGSOLID",
  2506170314: "IFCCSGPRIMITIVE3D",
  194851669: "IFCCRANERAILFSHAPEPROFILEDEF",
  4133800736: "IFCCRANERAILASHAPEPROFILEDEF",
  2485617015: "IFCCOMPOSITECURVESEGMENT",
  2205249479: "IFCCLOSEDSHELL",
  1383045692: "IFCCIRCLEPROFILEDEF",
  1416205885: "IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM",
  3331915920: "IFCCARTESIANTRANSFORMATIONOPERATOR3D",
  3486308946: "IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM",
  3749851601: "IFCCARTESIANTRANSFORMATIONOPERATOR2D",
  59481748: "IFCCARTESIANTRANSFORMATIONOPERATOR",
  1123145078: "IFCCARTESIANPOINT",
  2898889636: "IFCCSHAPEPROFILEDEF",
  2713105998: "IFCBOXEDHALFSPACE",
  2581212453: "IFCBOUNDINGBOX",
  4182860854: "IFCBOUNDEDSURFACE",
  2736907675: "IFCBOOLEANRESULT",
  2740243338: "IFCAXIS2PLACEMENT3D",
  3125803723: "IFCAXIS2PLACEMENT2D",
  4261334040: "IFCAXIS1PLACEMENT",
  1302238472: "IFCANNOTATIONSURFACE",
  2265737646: "IFCANNOTATIONFILLAREAOCCURRENCE",
  669184980: "IFCANNOTATIONFILLAREA",
  3288037868: "IFCANNOTATIONCURVEOCCURRENCE",
  2543172580: "IFCZSHAPEPROFILEDEF",
  1299126871: "IFCWINDOWSTYLE",
  512836454: "IFCWINDOWPANELPROPERTIES",
  336235671: "IFCWINDOWLININGPROPERTIES",
  2759199220: "IFCVERTEXLOOP",
  1417489154: "IFCVECTOR",
  427810014: "IFCUSHAPEPROFILEDEF",
  2347495698: "IFCTYPEPRODUCT",
  1628702193: "IFCTYPEOBJECT",
  1345879162: "IFCTWODIRECTIONREPEATFACTOR",
  2715220739: "IFCTRAPEZIUMPROFILEDEF",
  3124975700: "IFCTEXTLITERALWITHEXTENT",
  4282788508: "IFCTEXTLITERAL",
  3028897424: "IFCTERMINATORSYMBOL",
  3071757647: "IFCTSHAPEPROFILEDEF",
  230924584: "IFCSWEPTSURFACE",
  1260650574: "IFCSWEPTDISKSOLID",
  2247615214: "IFCSWEPTAREASOLID",
  1878645084: "IFCSURFACESTYLERENDERING",
  2513912981: "IFCSURFACE",
  2233826070: "IFCSUBEDGE",
  3653947884: "IFCSTRUCTURALSTEELPROFILEPROPERTIES",
  3843319758: "IFCSTRUCTURALPROFILEPROPERTIES",
  1190533807: "IFCSTRUCTURALLOADSINGLEFORCEWARPING",
  1597423693: "IFCSTRUCTURALLOADSINGLEFORCE",
  1973038258: "IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION",
  2473145415: "IFCSTRUCTURALLOADSINGLEDISPLACEMENT",
  2668620305: "IFCSTRUCTURALLOADPLANARFORCE",
  1595516126: "IFCSTRUCTURALLOADLINEARFORCE",
  390701378: "IFCSPACETHERMALLOADPROPERTIES",
  1202362311: "IFCSOUNDVALUE",
  2485662743: "IFCSOUNDPROPERTIES",
  723233188: "IFCSOLIDMODEL",
  2609359061: "IFCSLIPPAGECONNECTIONCONDITION",
  4124623270: "IFCSHELLBASEDSURFACEMODEL",
  2411513650: "IFCSERVICELIFEFACTOR",
  1509187699: "IFCSECTIONEDSPINE",
  2778083089: "IFCROUNDEDRECTANGLEPROFILEDEF",
  478536968: "IFCRELATIONSHIP",
  3765753017: "IFCREINFORCEMENTDEFINITIONPROPERTIES",
  3413951693: "IFCREGULARTIMESERIES",
  3615266464: "IFCRECTANGLEPROFILEDEF",
  110355661: "IFCPROPERTYTABLEVALUE",
  3650150729: "IFCPROPERTYSINGLEVALUE",
  3357820518: "IFCPROPERTYSETDEFINITION",
  941946838: "IFCPROPERTYREFERENCEVALUE",
  2752243245: "IFCPROPERTYLISTVALUE",
  4166981789: "IFCPROPERTYENUMERATEDVALUE",
  1680319473: "IFCPROPERTYDEFINITION",
  871118103: "IFCPROPERTYBOUNDEDVALUE",
  673634403: "IFCPRODUCTDEFINITIONSHAPE",
  179317114: "IFCPREDEFINEDPOINTMARKERSYMBOL",
  433424934: "IFCPREDEFINEDDIMENSIONSYMBOL",
  2559016684: "IFCPREDEFINEDCURVEFONT",
  759155922: "IFCPREDEFINEDCOLOUR",
  2775532180: "IFCPOLYGONALBOUNDEDHALFSPACE",
  2924175390: "IFCPOLYLOOP",
  1423911732: "IFCPOINTONSURFACE",
  4022376103: "IFCPOINTONCURVE",
  2067069095: "IFCPOINT",
  1663979128: "IFCPLANAREXTENT",
  2004835150: "IFCPLACEMENT",
  597895409: "IFCPIXELTEXTURE",
  3021840470: "IFCPHYSICALCOMPLEXQUANTITY",
  2519244187: "IFCPATH",
  2529465313: "IFCPARAMETERIZEDPROFILEDEF",
  1029017970: "IFCORIENTEDEDGE",
  2665983363: "IFCOPENSHELL",
  2833995503: "IFCONEDIRECTIONREPEATFACTOR",
  219451334: "IFCOBJECTDEFINITION",
  1430189142: "IFCMECHANICALCONCRETEMATERIALPROPERTIES",
  2022407955: "IFCMATERIALDEFINITIONREPRESENTATION",
  2347385850: "IFCMAPPEDITEM",
  1008929658: "IFCLOOP",
  2624227202: "IFCLOCALPLACEMENT",
  3422422726: "IFCLIGHTSOURCESPOT",
  1520743889: "IFCLIGHTSOURCEPOSITIONAL",
  4266656042: "IFCLIGHTSOURCEGONIOMETRIC",
  2604431987: "IFCLIGHTSOURCEDIRECTIONAL",
  125510826: "IFCLIGHTSOURCEAMBIENT",
  1402838566: "IFCLIGHTSOURCE",
  3741457305: "IFCIRREGULARTIMESERIES",
  3905492369: "IFCIMAGETEXTURE",
  2445078500: "IFCHYGROSCOPICMATERIALPROPERTIES",
  812098782: "IFCHALFSPACESOLID",
  178086475: "IFCGRIDPLACEMENT",
  3590301190: "IFCGEOMETRICSET",
  4142052618: "IFCGEOMETRICREPRESENTATIONSUBCONTEXT",
  2453401579: "IFCGEOMETRICREPRESENTATIONITEM",
  3448662350: "IFCGEOMETRICREPRESENTATIONCONTEXT",
  1446786286: "IFCGENERALPROFILEPROPERTIES",
  803998398: "IFCGENERALMATERIALPROPERTIES",
  3857492461: "IFCFUELPROPERTIES",
  738692330: "IFCFILLAREASTYLE",
  4219587988: "IFCFAILURECONNECTIONCONDITION",
  3008276851: "IFCFACESURFACE",
  803316827: "IFCFACEOUTERBOUND",
  1809719519: "IFCFACEBOUND",
  2556980723: "IFCFACE",
  1860660968: "IFCEXTENDEDMATERIALPROPERTIES",
  476780140: "IFCEDGECURVE",
  3900360178: "IFCEDGE",
  4170525392: "IFCDRAUGHTINGPREDEFINEDTEXTFONT",
  3732053477: "IFCDOCUMENTREFERENCE",
  1694125774: "IFCDIMENSIONPAIR",
  2273265877: "IFCDIMENSIONCALLOUTRELATIONSHIP",
  3632507154: "IFCDERIVEDPROFILEDEF",
  3800577675: "IFCCURVESTYLE",
  2889183280: "IFCCONVERSIONBASEDUNIT",
  3050246964: "IFCCONTEXTDEPENDENTUNIT",
  45288368: "IFCCONNECTIONPOINTECCENTRICITY",
  1981873012: "IFCCONNECTIONCURVEGEOMETRY",
  370225590: "IFCCONNECTEDFACESET",
  1485152156: "IFCCOMPOSITEPROFILEDEF",
  2542286263: "IFCCOMPLEXPROPERTY",
  776857604: "IFCCOLOURRGB",
  647927063: "IFCCLASSIFICATIONREFERENCE",
  3150382593: "IFCCENTERLINEPROFILEDEF",
  616511568: "IFCBLOBTEXTURE",
  2705031697: "IFCARBITRARYPROFILEDEFWITHVOIDS",
  1310608509: "IFCARBITRARYOPENPROFILEDEF",
  3798115385: "IFCARBITRARYCLOSEDPROFILEDEF",
  2297822566: "IFCANNOTATIONTEXTOCCURRENCE",
  3612888222: "IFCANNOTATIONSYMBOLOCCURRENCE",
  962685235: "IFCANNOTATIONSURFACEOCCURRENCE",
  2442683028: "IFCANNOTATIONOCCURRENCE",
  1065908215: "IFCWATERPROPERTIES",
  891718957: "IFCVIRTUALGRIDINTERSECTION",
  1907098498: "IFCVERTEXPOINT",
  3304826586: "IFCVERTEXBASEDTEXTUREMAP",
  2799835756: "IFCVERTEX",
  180925521: "IFCUNITASSIGNMENT",
  1735638870: "IFCTOPOLOGYREPRESENTATION",
  1377556343: "IFCTOPOLOGICALREPRESENTATIONITEM",
  581633288: "IFCTIMESERIESVALUE",
  1718945513: "IFCTIMESERIESREFERENCERELATIONSHIP",
  3101149627: "IFCTIMESERIES",
  3317419933: "IFCTHERMALMATERIALPROPERTIES",
  1210645708: "IFCTEXTUREVERTEX",
  2552916305: "IFCTEXTUREMAP",
  1742049831: "IFCTEXTURECOORDINATEGENERATOR",
  280115917: "IFCTEXTURECOORDINATE",
  1484833681: "IFCTEXTSTYLEWITHBOXCHARACTERISTICS",
  1640371178: "IFCTEXTSTYLETEXTMODEL",
  2636378356: "IFCTEXTSTYLEFORDEFINEDFONT",
  1983826977: "IFCTEXTSTYLEFONTMODEL",
  1447204868: "IFCTEXTSTYLE",
  912023232: "IFCTELECOMADDRESS",
  531007025: "IFCTABLEROW",
  985171141: "IFCTABLE",
  1290481447: "IFCSYMBOLSTYLE",
  626085974: "IFCSURFACETEXTURE",
  1351298697: "IFCSURFACESTYLEWITHTEXTURES",
  846575682: "IFCSURFACESTYLESHADING",
  1607154358: "IFCSURFACESTYLEREFRACTION",
  3303107099: "IFCSURFACESTYLELIGHTING",
  1300840506: "IFCSURFACESTYLE",
  3049322572: "IFCSTYLEDREPRESENTATION",
  3958052878: "IFCSTYLEDITEM",
  2830218821: "IFCSTYLEMODEL",
  3408363356: "IFCSTRUCTURALLOADTEMPERATURE",
  2525727697: "IFCSTRUCTURALLOADSTATIC",
  2162789131: "IFCSTRUCTURALLOAD",
  2273995522: "IFCSTRUCTURALCONNECTIONCONDITION",
  3692461612: "IFCSIMPLEPROPERTY",
  4240577450: "IFCSHAPEREPRESENTATION",
  3982875396: "IFCSHAPEMODEL",
  867548509: "IFCSHAPEASPECT",
  4165799628: "IFCSECTIONREINFORCEMENTPROPERTIES",
  2042790032: "IFCSECTIONPROPERTIES",
  448429030: "IFCSIUNIT",
  2341007311: "IFCROOT",
  3679540991: "IFCRIBPLATEPROFILEPROPERTIES",
  1660063152: "IFCREPRESENTATIONMAP",
  3008791417: "IFCREPRESENTATIONITEM",
  3377609919: "IFCREPRESENTATIONCONTEXT",
  1076942058: "IFCREPRESENTATION",
  1222501353: "IFCRELAXATION",
  1580146022: "IFCREINFORCEMENTBARPROPERTIES",
  2692823254: "IFCREFERENCESVALUEDOCUMENT",
  825690147: "IFCQUANTITYWEIGHT",
  2405470396: "IFCQUANTITYVOLUME",
  3252649465: "IFCQUANTITYTIME",
  931644368: "IFCQUANTITYLENGTH",
  2093928680: "IFCQUANTITYCOUNT",
  2044713172: "IFCQUANTITYAREA",
  3710013099: "IFCPROPERTYENUMERATION",
  148025276: "IFCPROPERTYDEPENDENCYRELATIONSHIP",
  3896028662: "IFCPROPERTYCONSTRAINTRELATIONSHIP",
  2598011224: "IFCPROPERTY",
  2802850158: "IFCPROFILEPROPERTIES",
  3958567839: "IFCPROFILEDEF",
  2267347899: "IFCPRODUCTSOFCOMBUSTIONPROPERTIES",
  2095639259: "IFCPRODUCTREPRESENTATION",
  2417041796: "IFCPRESENTATIONSTYLEASSIGNMENT",
  3119450353: "IFCPRESENTATIONSTYLE",
  1304840413: "IFCPRESENTATIONLAYERWITHSTYLE",
  2022622350: "IFCPRESENTATIONLAYERASSIGNMENT",
  1775413392: "IFCPREDEFINEDTEXTFONT",
  3213052703: "IFCPREDEFINEDTERMINATORSYMBOL",
  990879717: "IFCPREDEFINEDSYMBOL",
  3727388367: "IFCPREDEFINEDITEM",
  3355820592: "IFCPOSTALADDRESS",
  2226359599: "IFCPHYSICALSIMPLEQUANTITY",
  2483315170: "IFCPHYSICALQUANTITY",
  101040310: "IFCPERSONANDORGANIZATION",
  2077209135: "IFCPERSON",
  1207048766: "IFCOWNERHISTORY",
  1411181986: "IFCORGANIZATIONRELATIONSHIP",
  4251960020: "IFCORGANIZATION",
  1227763645: "IFCOPTICALMATERIALPROPERTIES",
  2251480897: "IFCOBJECTIVE",
  3701648758: "IFCOBJECTPLACEMENT",
  1918398963: "IFCNAMEDUNIT",
  2706619895: "IFCMONETARYUNIT",
  3368373690: "IFCMETRIC",
  677618848: "IFCMECHANICALSTEELMATERIALPROPERTIES",
  4256014907: "IFCMECHANICALMATERIALPROPERTIES",
  2597039031: "IFCMEASUREWITHUNIT",
  3265635763: "IFCMATERIALPROPERTIES",
  2199411900: "IFCMATERIALLIST",
  1303795690: "IFCMATERIALLAYERSETUSAGE",
  3303938423: "IFCMATERIALLAYERSET",
  248100487: "IFCMATERIALLAYER",
  1847130766: "IFCMATERIALCLASSIFICATIONRELATIONSHIP",
  1838606355: "IFCMATERIAL",
  30780891: "IFCLOCALTIME",
  1566485204: "IFCLIGHTINTENSITYDISTRIBUTION",
  4162380809: "IFCLIGHTDISTRIBUTIONDATA",
  3452421091: "IFCLIBRARYREFERENCE",
  2655187982: "IFCLIBRARYINFORMATION",
  3020489413: "IFCIRREGULARTIMESERIESVALUE",
  852622518: "IFCGRIDAXIS",
  3548104201: "IFCEXTERNALLYDEFINEDTEXTFONT",
  3207319532: "IFCEXTERNALLYDEFINEDSYMBOL",
  1040185647: "IFCEXTERNALLYDEFINEDSURFACESTYLE",
  2242383968: "IFCEXTERNALLYDEFINEDHATCHSTYLE",
  3200245327: "IFCEXTERNALREFERENCE",
  1648886627: "IFCENVIRONMENTALIMPACTVALUE",
  3796139169: "IFCDRAUGHTINGCALLOUTRELATIONSHIP",
  770865208: "IFCDOCUMENTINFORMATIONRELATIONSHIP",
  1154170062: "IFCDOCUMENTINFORMATION",
  1376555844: "IFCDOCUMENTELECTRONICFORMAT",
  2949456006: "IFCDIMENSIONALEXPONENTS",
  1045800335: "IFCDERIVEDUNITELEMENT",
  1765591967: "IFCDERIVEDUNIT",
  1072939445: "IFCDATEANDTIME",
  3510044353: "IFCCURVESTYLEFONTPATTERN",
  2367409068: "IFCCURVESTYLEFONTANDSCALING",
  1105321065: "IFCCURVESTYLEFONT",
  539742890: "IFCCURRENCYRELATIONSHIP",
  602808272: "IFCCOSTVALUE",
  1065062679: "IFCCOORDINATEDUNIVERSALTIMEOFFSET",
  347226245: "IFCCONSTRAINTRELATIONSHIP",
  613356794: "IFCCONSTRAINTCLASSIFICATIONRELATIONSHIP",
  1658513725: "IFCCONSTRAINTAGGREGATIONRELATIONSHIP",
  1959218052: "IFCCONSTRAINT",
  2732653382: "IFCCONNECTIONSURFACEGEOMETRY",
  4257277454: "IFCCONNECTIONPORTGEOMETRY",
  2614616156: "IFCCONNECTIONPOINTGEOMETRY",
  2859738748: "IFCCONNECTIONGEOMETRY",
  3264961684: "IFCCOLOURSPECIFICATION",
  3639012971: "IFCCLASSIFICATIONNOTATIONFACET",
  938368621: "IFCCLASSIFICATIONNOTATION",
  1098599126: "IFCCLASSIFICATIONITEMRELATIONSHIP",
  1767535486: "IFCCLASSIFICATIONITEM",
  747523909: "IFCCLASSIFICATION",
  622194075: "IFCCALENDARDATE",
  2069777674: "IFCBOUNDARYNODECONDITIONWARPING",
  1387855156: "IFCBOUNDARYNODECONDITION",
  3367102660: "IFCBOUNDARYFACECONDITION",
  1560379544: "IFCBOUNDARYEDGECONDITION",
  4037036970: "IFCBOUNDARYCONDITION",
  3869604511: "IFCAPPROVALRELATIONSHIP",
  390851274: "IFCAPPROVALPROPERTYRELATIONSHIP",
  2080292479: "IFCAPPROVALACTORRELATIONSHIP",
  130549933: "IFCAPPROVAL",
  1110488051: "IFCAPPLIEDVALUERELATIONSHIP",
  411424972: "IFCAPPLIEDVALUE",
  639542469: "IFCAPPLICATION",
  618182010: "IFCADDRESS",
  3630933823: "IFCACTORROLE",
  599546466: "FILE_DESCRIPTION",
  1390159747: "FILE_NAME",
  1109904537: "FILE_SCHEMA"
};
class Ke {
  static async getUnits(s) {
    var r, o, a;
    const { IFCUNITASSIGNMENT: t } = X, e = await s.getAllPropertiesOfType(t);
    if (!e)
      return 1;
    const i = Object.keys(e), n = e[parseInt(i[0], 10)];
    for (const l of n.Units) {
      if (l.value === void 0 || l.value === null)
        continue;
      const h = await s.getProperties(l.value);
      if (!h || !h.UnitType || !h.UnitType.value || h.UnitType.value !== "LENGTHUNIT")
        continue;
      let u = 1, f = 1;
      return h.Name.value === "METRE" && (f = 1), h.Name.value === "FOOT" && (f = 0.3048), ((r = h.Prefix) == null ? void 0 : r.value) === "MILLI" ? u = 1e-3 : ((o = h.Prefix) == null ? void 0 : o.value) === "CENTI" ? u = 0.01 : ((a = h.Prefix) == null ? void 0 : a.value) === "DECI" && (u = 0.1), f * u;
    }
    return 1;
  }
  static async findItemByGuid(s, t) {
    var i;
    const e = s.getAllPropertiesIDs();
    for (const n of e) {
      const r = await s.getProperties(n);
      if (r && ((i = r.GlobalId) == null ? void 0 : i.value) === t)
        return r;
    }
    return null;
  }
  static async getRelationMap(s, t, e) {
    var a;
    const n = e ?? (async () => {
    }), r = {}, o = s.getAllPropertiesIDs();
    for (const l of o) {
      const h = await s.getProperties(l);
      if (!h)
        continue;
      const d = h.type === t, u = Object.keys(h).find(
        (m) => m.startsWith("Relating")
      ), f = Object.keys(h).find(
        (m) => m.startsWith("Related")
      );
      if (!(d && u && f))
        continue;
      const E = await s.getProperties((a = h[u]) == null ? void 0 : a.value), p = h[f];
      if (!E || !p || !(p && Array.isArray(p)))
        continue;
      const I = p.map((m) => m.value);
      await n(E.expressID, I), r[E.expressID] = I;
    }
    return r;
  }
  static async getQsetQuantities(s, t, e) {
    const n = e ?? (() => {
    }), r = await s.getProperties(t);
    return !r || r.type !== X.IFCELEMENTQUANTITY ? null : (r.Quantities ?? [{}]).map((l) => (l.value && n(l.value), l.value)).filter((l) => l !== null);
  }
  static async getPsetProps(s, t, e) {
    const n = e ?? (() => {
    }), r = await s.getProperties(t);
    return !r || r.type !== X.IFCPROPERTYSET ? null : (r.HasProperties ?? [{}]).map((l) => (l.value && n(l.value), l.value)).filter((l) => l !== null);
  }
  static async getPsetRel(s, t) {
    var o;
    if (!await s.getProperties(t))
      return null;
    const i = await s.getAllPropertiesOfType(
      X.IFCRELDEFINESBYPROPERTIES
    );
    if (!i)
      return null;
    const n = Object.values(i);
    let r = null;
    for (const a of n)
      ((o = a.RelatingPropertyDefinition) == null ? void 0 : o.value) === t && (r = a.expressID);
    return r;
  }
  static async getQsetRel(s, t) {
    return Ke.getPsetRel(s, t);
  }
  static async getEntityName(s, t) {
    var r;
    const e = await s.getProperties(t);
    if (!e)
      return { key: null, name: null };
    const i = Object.keys(e).find((o) => o.endsWith("Name")) ?? null, n = i ? (r = e[i]) == null ? void 0 : r.value : null;
    return { key: i, name: n };
  }
  static async getQuantityValue(s, t) {
    const e = await s.getProperties(t);
    if (!e)
      return { key: null, value: null };
    const i = Object.keys(e).find((r) => r.endsWith("Value")) ?? null;
    let n;
    return i === null || e[i] === void 0 || e[i] === null ? n = null : n = e[i].value, { key: i, value: n };
  }
  static isRel(s) {
    return zr[s].startsWith("IFCREL");
  }
  static async attributeExists(s, t, e) {
    const i = await s.getProperties(t);
    return i ? Object.keys(i).includes(e) : !1;
  }
  static async groupEntitiesByType(s, t) {
    var i;
    const e = /* @__PURE__ */ new Map();
    for (const n of t) {
      const r = await s.getProperties(n);
      if (!r)
        continue;
      const o = r.type;
      e.get(o) || e.set(o, /* @__PURE__ */ new Set()), (i = e.get(o)) == null || i.add(n);
    }
    return e;
  }
  // static getPropertyUnits(properties: IfcProperties, expressID: number) {
  //   const entity = properties[expressID];
  //   if (!entity) return null;
  //   const propertyInstance =
  //     entity instanceof WEBIFC.IFC2X3.IfcProperty ||
  //     entity instanceof WEBIFC.IFC4.IfcProperty ||
  //     entity instanceof WEBIFC.IFC4X3.IfcProperty;
  //   if (!propertyInstance) return null;
  //   const { key: valueKey } = IfcPropertiesUtils.getQuantityValue(
  //     properties,
  //     expressID
  //   );
  //   if (!valueKey) return null;
  //   // @ts-ignore
  //   const measureName = entity[valueKey].constructor.name as string;
  //   const isMeasureAttribute = measureName.endsWith("Measure");
  //   if (!isMeasureAttribute) return null;
  //   const measureType = measureName.slice(3, measureName.length - 7);
  //   return propertyInstance;
  // }
}
class oc {
  constructor() {
    T(this, "factor", 1);
    T(this, "complement", 1);
  }
  apply(s) {
    const e = this.getScaleMatrix().multiply(s);
    s.copy(e);
  }
  setUp(s) {
    var n, r, o;
    this.factor = 1;
    const t = this.getLengthUnits(s);
    if (!t)
      return;
    const e = t == null, i = t.Name === void 0 || t.Name === null;
    e || i || (t.Name.value === "FOOT" && (this.factor = 0.3048), ((n = t.Prefix) == null ? void 0 : n.value) === "MILLI" ? this.complement = 1e-3 : ((r = t.Prefix) == null ? void 0 : r.value) === "CENTI" ? this.complement = 0.01 : ((o = t.Prefix) == null ? void 0 : o.value) === "DECI" && (this.complement = 0.01));
  }
  getLengthUnits(s) {
    try {
      const e = s.GetLineIDsWithType(
        0,
        X.IFCUNITASSIGNMENT
      ).get(0), i = s.GetLine(0, e);
      for (const n of i.Units) {
        if (!n || n.value === null || n.value === void 0)
          continue;
        const r = s.GetLine(0, n.value);
        if (r.UnitType && r.UnitType.value === "LENGTHUNIT")
          return r;
      }
      return null;
    } catch {
      return console.log("Could not get units"), null;
    }
  }
  getScaleMatrix() {
    const s = this.factor;
    return new M.Matrix4().fromArray([
      s,
      0,
      0,
      0,
      0,
      s,
      0,
      0,
      0,
      0,
      s,
      0,
      0,
      0,
      0,
      1
    ]);
  }
}
class kr {
  constructor() {
    T(this, "itemsByFloor", {});
    T(this, "_units", new oc());
  }
  // TODO: Maybe make this more flexible so that it also support more exotic spatial structures?
  setUp(s) {
    this._units.setUp(s), this.cleanUp();
    try {
      const t = s.GetLineIDsWithType(
        0,
        X.IFCRELCONTAINEDINSPATIALSTRUCTURE
      ), e = /* @__PURE__ */ new Set(), i = s.GetLineIDsWithType(0, X.IFCSPACE);
      for (let l = 0; l < i.size(); l++)
        e.add(i.get(l));
      const n = s.GetLineIDsWithType(0, X.IFCRELAGGREGATES), r = n.size();
      for (let l = 0; l < r; l++) {
        const h = n.get(l), d = s.GetLine(0, h);
        if (!d || !d.RelatingObject || !d.RelatedObjects)
          continue;
        const u = d.RelatingObject.value, f = d.RelatedObjects;
        for (const E of f) {
          const p = E.value;
          e.has(p) && (this.itemsByFloor[p] = u);
        }
      }
      const o = {}, a = t.size();
      for (let l = 0; l < a; l++) {
        const h = t.get(l), d = s.GetLine(0, h);
        if (!d || !d.RelatingStructure || !d.RelatedElements)
          continue;
        const u = d.RelatingStructure.value, f = d.RelatedElements;
        if (e.has(u))
          for (const E of f) {
            o[u] || (o[u] = []);
            const p = E.value;
            o[u].push(p);
          }
        else
          for (const E of f) {
            const p = E.value;
            this.itemsByFloor[p] = u;
          }
      }
      for (const l in o) {
        const h = this.itemsByFloor[l];
        if (h !== void 0) {
          const d = o[l];
          for (const u of d)
            this.itemsByFloor[u] = h;
        }
      }
      for (let l = 0; l < r; l++) {
        const h = n.get(l), d = s.GetLine(0, h);
        if (!d || !d.RelatingObject || !d.RelatedObjects)
          continue;
        const u = d.RelatingObject.value, f = d.RelatedObjects;
        for (const E of f) {
          const p = E.value, I = this.itemsByFloor[u];
          I !== void 0 && (this.itemsByFloor[p] = I);
        }
      }
    } catch {
      console.log("Could not get floors.");
    }
  }
  cleanUp() {
    this.itemsByFloor = {};
  }
}
class wn {
  constructor() {
    /** Whether to extract the IFC properties into a JSON. */
    T(this, "includeProperties", !0);
    /**
     * Generate the geometry for categories that are not included by default,
     * like IFCSPACE.
     */
    T(this, "optionalCategories", [X.IFCSPACE]);
    /** Whether to use the coordination data coming from the IFC files. */
    T(this, "coordinate", !0);
    /** Path of the WASM for [web-ifc](https://github.com/ThatOpen/engine_web-ifc). */
    T(this, "wasm", {
      path: "",
      absolute: !1,
      logLevel: X.LogLevel.LOG_LEVEL_OFF
    });
    /** List of categories that won't be converted to fragments. */
    T(this, "excludedCategories", /* @__PURE__ */ new Set());
    /** Exclusive list of categories that will be converted to fragments. If this contains any category, any other categories will be ignored. */
    T(this, "includedCategories", /* @__PURE__ */ new Set());
    /** Whether to save the absolute location of all IFC items. */
    T(this, "saveLocations", !1);
    /** Loader settings for [web-ifc](https://github.com/ThatOpen/engine_web-ifc). */
    T(this, "webIfc", {
      COORDINATE_TO_ORIGIN: !0
      // OPTIMIZE_PROFILES: true,
    });
    /**
     * Whether to automatically set the path to the WASM file for [web-ifc](https://github.com/ThatOpen/engine_web-ifc).
     * If set to true, the path will be set to the default path of the WASM file.
     * If set to false, the path must be provided manually in the `wasm.path` property.
     * Default value is true.
     */
    T(this, "autoSetWasm", !0);
    /**
     * Custom function to handle the file location for [web-ifc](https://github.com/ThatOpen/engine_web-ifc).
     * This function will be called when [web-ifc](https://github.com/ThatOpen/engine_web-ifc) needs to locate a file.
     * If set to null, the default file location handler will be used.
     *
     * @param url - The URL of the file to locate.
     * @returns The absolute path of the file.
     */
    T(this, "customLocateFileHandler", null);
  }
}
class Vr {
  constructor() {
    T(this, "defLineMat", new M.LineBasicMaterial({ color: 16777215 }));
  }
  read(s) {
    const t = s.GetAllAlignments(0), e = s.GetAllCrossSections2D(0), i = s.GetAllCrossSections3D(0), n = {
      IfcAlignment: t,
      IfcCrossSection2D: e,
      IfcCrossSection3D: i
    };
    return this.get(n);
  }
  get(s) {
    if (s.IfcAlignment) {
      const t = /* @__PURE__ */ new Map();
      for (const e of s.IfcAlignment) {
        const i = new ye.Alignment();
        i.absolute = this.getCurves(e.curve3D, i), i.horizontal = this.getCurves(e.horizontal, i), i.vertical = this.getCurves(e.vertical, i), t.set(t.size, i);
      }
      return { alignments: t, coordinationMatrix: new M.Matrix4() };
    }
  }
  getCurves(s, t) {
    const e = [];
    let i = 0;
    for (const n of s) {
      const r = {};
      if (n.data)
        for (const u of n.data) {
          const [f, E] = u.split(": "), p = parseFloat(E);
          r[f] = p || E;
        }
      const { points: o } = n, a = new Float32Array(o.length * 3);
      for (let u = 0; u < o.length; u++) {
        const { x: f, y: E, z: p } = o[u];
        a[u * 3] = f, a[u * 3 + 1] = E, a[u * 3 + 2] = p || 0;
      }
      const l = new M.BufferAttribute(a, 3), h = new M.EdgesGeometry();
      h.setAttribute("position", l);
      const d = new ye.CurveMesh(
        i,
        r,
        t,
        h,
        this.defLineMat
      );
      e.push(d.curve), i++;
    }
    return e;
  }
}
class Yr {
  getNameInfo(s) {
    var d;
    const t = {}, { arguments: e } = s.GetHeaderLine(0, X.FILE_NAME) || {};
    if (!e)
      return t;
    const [
      i,
      n,
      r,
      o,
      a,
      l,
      h
    ] = e;
    if (i != null && i.value && (t.name = i.value), n != null && n.value && (t.creationDate = new Date(n.value)), r) {
      t.author = {};
      const [u, f] = r;
      u != null && u.value && (t.author.name = u.value), f != null && f.value && (t.author.email = f.value);
    }
    return (d = o[0]) != null && d.value && (t.organization = o[0].value), a != null && a.value && (t.preprocessorVersion = a == null ? void 0 : a.value), l != null && l.value && (t.originatingSystem = l == null ? void 0 : l.value), h != null && h.value && (t.authorization = h == null ? void 0 : h.value), t;
  }
  getDescriptionInfo(s) {
    var r;
    const t = {}, { arguments: e } = s.GetHeaderLine(0, X.FILE_DESCRIPTION) || {};
    if (!e)
      return t;
    const [i, n] = e;
    if ((r = i[0]) != null && r.value) {
      const o = i[0].value.match(/\[([^\]]+)\]/);
      o && o[1] && (t.viewDefinition = o[1]);
    }
    return n != null && n.value && (t.implementationLevel = n.value), t;
  }
}
class Gr {
  static get(s, t) {
    const e = [
      X.IFCPROJECT,
      X.IFCSITE,
      X.IFCBUILDING,
      X.IFCBUILDINGSTOREY,
      X.IFCSPACE,
      X.IFCROAD,
      X.IFCFACILITY,
      X.IFCFACILITYPART,
      X.IFCBRIDGE
    ], i = s.data;
    for (const n of e) {
      const r = t.GetLineIDsWithType(0, n), o = r.size();
      for (let a = 0; a < o; a++) {
        const l = r.get(a);
        i.has(l) || i.set(l, [[], [0, n]]);
      }
    }
  }
}
const Hr = /* @__PURE__ */ new Set([
  1123145078,
  574549367,
  1675464909,
  2059837836,
  3798115385,
  32440307,
  3125803723,
  3207858831,
  2740243338,
  2624227202,
  4240577450,
  3615266464,
  3724593414,
  220341763,
  477187591,
  1878645084,
  1300840506,
  3303107099,
  1607154358,
  1878645084,
  846575682,
  1351298697,
  2417041796,
  3049322572,
  3331915920,
  1416205885,
  776857604,
  3285139300,
  3958052878,
  2827736869,
  2732653382,
  673634403,
  3448662350,
  4142052618,
  2924175390,
  803316827,
  2556980723,
  1809719519,
  2205249479,
  807026263,
  3737207727,
  1660063152,
  2347385850,
  2705031697,
  3732776249,
  2485617015,
  2611217952,
  1704287377,
  2937912522,
  2770003689,
  1281925730,
  1484403080,
  3448662350,
  4142052618,
  3800577675,
  4006246654,
  3590301190,
  1383045692,
  2775532180,
  2047409740,
  370225590,
  3593883385,
  2665983363,
  4124623270,
  812098782,
  3649129432,
  987898635,
  1105321065,
  3510044353,
  1635779807,
  2603310189,
  3406155212,
  1310608509,
  4261334040,
  2736907675,
  3649129432,
  1136057603,
  1260505505,
  4182860854,
  2713105998,
  2898889636,
  59481748,
  3749851601,
  3486308946,
  3150382593,
  1062206242,
  3264961684,
  15328376,
  1485152156,
  370225590,
  1981873012,
  2859738748,
  45288368,
  2614616156,
  2732653382,
  775493141,
  2147822146,
  2601014836,
  2629017746,
  1186437898,
  2367409068,
  1213902940,
  3632507154,
  3900360178,
  476780140,
  1472233963,
  2804161546,
  3008276851,
  738692330,
  374418227,
  315944413,
  3905492369,
  3570813810,
  2571569899,
  178912537,
  2294589976,
  1437953363,
  2133299955,
  572779678,
  3092502836,
  388784114,
  2624227202,
  1425443689,
  3057273783,
  2347385850,
  1682466193,
  2519244187,
  2839578677,
  3958567839,
  2513912981,
  2830218821,
  427810014
]), mi = class mi extends St {
  constructor(t) {
    super(t);
    /** {@link Component.enabled} */
    T(this, "enabled", !0);
    t.add(mi.uuid, this);
  }
  /**
   * Exports all the properties of an IFC into an array of JS objects.
   * @param webIfc The instance of [web-ifc](https://github.com/ThatOpen/engine_web-ifc) to use.
   * @param modelID ID of the IFC model whose properties to extract.
   * @param indirect whether to get the indirect relationships as well.
   * @param recursiveSpatial whether to get the properties of spatial items recursively
   * to make the location data available (e.g. absolute position of building).
   */
  async export(t, e, i = !1, n = !0) {
    const r = {}, o = new Set(t.GetIfcEntityList(e)), a = /* @__PURE__ */ new Set([
      X.IFCPROJECT,
      X.IFCSITE,
      X.IFCBUILDING,
      X.IFCBUILDINGSTOREY,
      X.IFCSPACE
    ]);
    for (const l of a)
      o.add(l);
    for (const l of o) {
      if (Hr.has(l))
        continue;
      const h = a.has(l) && n, d = t.GetLineIDsWithType(e, l);
      for (const u of d) {
        const f = t.GetLine(0, u, h, i);
        r[f.expressID] = f;
      }
    }
    return r;
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
T(mi, "uuid", "b32c4332-cd67-436e-ba7f-196646c7a635");
let hn = mi;
const Ss = class Ss extends St {
  constructor(t) {
    super(t);
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    /**
     * An event triggered when the IFC file starts loading.
     */
    T(this, "onIfcStartedLoading", new j());
    /**
     * An event triggered when the setup process is completed.
     */
    T(this, "onSetup", new j());
    /**
     * The settings for the IfcLoader.
     * It includes options for excluding categories, setting WASM paths, and more.
     */
    T(this, "settings", new wn());
    /**
     * The instance of the Web-IFC library used for handling IFC data.
     */
    T(this, "webIfc", new X.IfcAPI());
    /** {@link Component.enabled} */
    T(this, "enabled", !0);
    T(this, "_material", new M.MeshLambertMaterial());
    T(this, "_spatialTree", new kr());
    T(this, "_metaData", new Yr());
    T(this, "_fragmentInstances", /* @__PURE__ */ new Map());
    T(this, "_civil", new Vr());
    T(this, "_visitedFragments", /* @__PURE__ */ new Map());
    T(this, "_materialT", new M.MeshLambertMaterial({
      transparent: !0,
      opacity: 0.5
    }));
    this.components.add(Ss.uuid, this), this.settings.excludedCategories.add(X.IFCOPENINGELEMENT);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.webIfc = null, this.onDisposed.trigger(Ss.uuid), this.onDisposed.reset();
  }
  /**
   * Sets up the IfcLoader component with the provided configuration.
   *
   * @param config - Optional configuration settings for the IfcLoader.
   * If not provided, the existing settings will be used.
   *
   * @returns A Promise that resolves when the setup process is completed.
   *
   * @remarks
   * If the `autoSetWasm` option is enabled in the configuration,
   * the method will automatically set the WASM paths for the Web-IFC library.
   *
   * @example
   * ```typescript
   * const ifcLoader = new IfcLoader(components);
   * await ifcLoader.setup({ autoSetWasm: true });
   * ```
   */
  async setup(t) {
    this.settings = { ...this.settings, ...t }, this.settings.autoSetWasm && await this.autoSetWasm(), this.onSetup.trigger();
  }
  /**
   * Loads an IFC file and processes it for 3D visualization.
   *
   * @param data - The Uint8Array containing the IFC file data.
   * @param coordinate - Optional boolean indicating whether to coordinate the loaded IFC data. Default is true.
   *
   * @returns A Promise that resolves to the FragmentsGroup containing the loaded and processed IFC data.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * const group = await ifcLoader.load(ifcData);
   * ```
   */
  async load(t, e = !0, i = "") {
    const n = performance.now();
    this.onIfcStartedLoading.trigger(), await this.readIfcFile(t);
    const r = await this.getAllGeometries();
    r.name = i;
    const a = await this.components.get(hn).export(this.webIfc, 0);
    r.setLocalProperties(a);
    const l = this.components.get(_t);
    l.groups.set(r.uuid, r);
    for (const h of r.items)
      l.list.set(h.id, h), h.mesh.uuid = h.id, h.group = r;
    l.onFragmentsLoaded.trigger(r), e && l.coordinate([r]);
    for (const [h] of r.data) {
      const d = a[h];
      if (!d || !d.GlobalId)
        continue;
      const u = d.GlobalId.value || d.GlobalId;
      r.globalToExpressIDs.set(u, h);
    }
    return Gr.get(r, this.webIfc), this.cleanUp(), console.log(`Streaming the IFC took ${performance.now() - n} ms!`), r;
  }
  /**
   * Reads an IFC file and initializes the Web-IFC library.
   *
   * @param data - The Uint8Array containing the IFC file data.
   *
   * @returns A Promise that resolves when the IFC file is opened and initialized.
   *
   * @remarks
   * This method sets the WASM path and initializes the Web-IFC library based on the provided settings.
   * It also opens the IFC model using the provided data and settings.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * await ifcLoader.readIfcFile(ifcData);
   * ```
   */
  async readIfcFile(t) {
    const { path: e, absolute: i, logLevel: n } = this.settings.wasm;
    return this.webIfc.SetWasmPath(e, i), await this.webIfc.Init(this.settings.customLocateFileHandler || void 0), n && this.webIfc.SetLogLevel(n), this.webIfc.OpenModel(t, this.settings.webIfc);
  }
  /**
   * Cleans up the IfcLoader component by resetting the Web-IFC library,
   * clearing the visited fragments and fragment instances maps, and creating a new instance of the Web-IFC library.
   *
   * @remarks
   * This method is called automatically after using the .load() method, so usually you don't need to use it manually.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * ifcLoader.cleanUp();
   * ```
   */
  cleanUp() {
    try {
      this.webIfc.Dispose();
    } catch {
      console.log("Web-ifc wasn't disposed.");
    }
    this.webIfc = null, this.webIfc = new X.IfcAPI(), this._visitedFragments.clear(), this._fragmentInstances.clear();
  }
  async getAllGeometries() {
    this._spatialTree.setUp(this.webIfc);
    const t = this.webIfc.GetIfcEntityList(0), e = new ye.FragmentsGroup();
    e.ifcMetadata = {
      name: "",
      description: "",
      ...this._metaData.getNameInfo(this.webIfc),
      ...this._metaData.getDescriptionInfo(this.webIfc),
      schema: this.webIfc.GetModelSchema(0) || "IFC2X3",
      maxExpressID: this.webIfc.GetMaxExpressID(0)
    };
    const i = [];
    for (const r of t) {
      if (!this.webIfc.IsIfcElement(r) && r !== X.IFCSPACE)
        continue;
      const o = this.settings.includedCategories;
      if (o.size > 0 && !o.has(r))
        continue;
      if (this.settings.excludedCategories.has(r))
        continue;
      const a = this.webIfc.GetLineIDsWithType(0, r), l = a.size();
      for (let h = 0; h < l; h++) {
        const d = a.get(h);
        i.push(d);
        const u = this._spatialTree.itemsByFloor[d] || 0;
        e.data.set(d, [[], [u, r]]);
      }
    }
    this._spatialTree.cleanUp(), this.webIfc.StreamMeshes(0, i, (r) => {
      this.getMesh(r, e);
    });
    for (const r of this._visitedFragments) {
      const { index: o, fragment: a } = r[1];
      e.keyFragments.set(o, a.id);
    }
    for (const r of e.items) {
      const o = this._fragmentInstances.get(r.id);
      if (!o)
        throw new Error("Fragment not found!");
      const a = [];
      for (const [l, h] of o)
        a.push(h);
      r.add(a);
    }
    const n = this.webIfc.GetCoordinationMatrix(0);
    return e.coordinationMatrix.fromArray(n), e.civilData = this._civil.read(this.webIfc), e;
  }
  getMesh(t, e) {
    const i = t.geometries.size(), n = t.expressID;
    for (let r = 0; r < i; r++) {
      const o = t.geometries.get(r), { x: a, y: l, z: h, w: d } = o.color, u = d !== 1, { geometryExpressID: f } = o, E = `${f}-${u}`;
      if (!this._visitedFragments.has(E)) {
        const y = this.getGeometry(this.webIfc, f), F = u ? this._materialT : this._material, S = new ye.Fragment(y, F, 1);
        e.add(S.mesh), e.items.push(S);
        const L = this._visitedFragments.size;
        this._visitedFragments.set(E, { index: L, fragment: S });
      }
      const p = new M.Color().setRGB(a, l, h, "srgb"), I = new M.Matrix4();
      I.fromArray(o.flatTransformation);
      const m = this._visitedFragments.get(E);
      if (m === void 0)
        throw new Error("Error getting geometry data for streaming!");
      const C = e.data.get(n);
      if (!C)
        throw new Error("Data not found!");
      C[0].push(m.index);
      const { fragment: R } = m;
      this._fragmentInstances.has(R.id) || this._fragmentInstances.set(R.id, /* @__PURE__ */ new Map());
      const g = this._fragmentInstances.get(R.id);
      if (!g)
        throw new Error("Instances not found!");
      if (g.has(n)) {
        const y = g.get(n);
        if (!y)
          throw new Error("Instance not found!");
        y.transforms.push(I), y.colors && y.colors.push(p);
      } else
        g.set(n, { id: n, transforms: [I], colors: [p] });
    }
  }
  getGeometry(t, e) {
    const i = t.GetGeometry(0, e), n = t.GetIndexArray(
      i.GetIndexData(),
      i.GetIndexDataSize()
    ), r = t.GetVertexArray(
      i.GetVertexData(),
      i.GetVertexDataSize()
    ), o = new Float32Array(r.length / 2), a = new Float32Array(r.length / 2);
    for (let u = 0; u < r.length; u += 6)
      o[u / 2] = r[u], o[u / 2 + 1] = r[u + 1], o[u / 2 + 2] = r[u + 2], a[u / 2] = r[u + 3], a[u / 2 + 1] = r[u + 4], a[u / 2 + 2] = r[u + 5];
    const l = new M.BufferGeometry(), h = new M.BufferAttribute(o, 3), d = new M.BufferAttribute(a, 3);
    return l.setAttribute("position", h), l.setAttribute("normal", d), l.setIndex(Array.from(n)), i.delete(), l;
  }
  async autoSetWasm() {
    const t = await fetch(
      `https://unpkg.com/@thatopen/components@${an.release}/package.json`
    );
    if (!t.ok) {
      console.warn(
        "Couldn't get openbim-components package.json. Set wasm settings manually."
      );
      return;
    }
    const e = await t.json();
    if (!("web-ifc" in e.peerDependencies))
      console.warn(
        "Couldn't get web-ifc from peer dependencies in openbim-components. Set wasm settings manually."
      );
    else {
      const i = e.peerDependencies["web-ifc"];
      this.settings.wasm.path = `https://unpkg.com/web-ifc@${i}/`, this.settings.wasm.absolute = !0;
    }
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
T(Ss, "uuid", "a659add7-1418-4771-a0d6-7d4d438e4624");
let dn = Ss;
const ac = {
  // IfcRelAssigns
  IfcRelAssignsToControl: { related: 5, relating: 7 },
  IfcRelAssignsToGroup: { related: 5, relating: 7 },
  IfcRelAssignsToProduct: { related: 5, relating: 7 },
  // IfcRelAssociates
  IfcRelAssociatesClassification: { related: 5, relating: 6 },
  IfcRelAssociatesMaterial: { related: 5, relating: 6 },
  IfcRelAssociatesDocument: { related: 5, relating: 6 },
  // IfcRelConnects
  IfcRelContainedInSpatialStructure: { related: 5, relating: 6 },
  IfcRelFlowControlElements: { related: 5, relating: 6 },
  IfcRelConnectsElements: { related: 7, relating: 6 },
  // IfcRelDeclares
  IfcRelDeclares: { related: 6, relating: 5 },
  // IfcRelDecomposes
  IfcRelAggregates: { related: 6, relating: 5 },
  IfcRelNests: { related: 6, relating: 5 },
  // IfcRelDefines
  IfcRelDefinesByProperties: { related: 5, relating: 6 },
  IfcRelDefinesByType: { related: 5, relating: 6 },
  IfcRelDefinesByTemplate: { related: 5, relating: 6 }
}, cc = {
  // IfcRelAssigns
  [X.IFCRELASSIGNSTOCONTROL]: "IfcRelAssignsToControl",
  [X.IFCRELASSIGNSTOGROUP]: "IfcRelAssignsToGroup",
  [X.IFCRELASSIGNSTOPRODUCT]: "IfcRelAssignsToProduct",
  // IfcRelAssociates
  [X.IFCRELASSOCIATESCLASSIFICATION]: "IfcRelAssociatesClassification",
  [X.IFCRELASSOCIATESMATERIAL]: "IfcRelAssociatesMaterial",
  [X.IFCRELASSOCIATESDOCUMENT]: "IfcRelAssociatesDocument",
  // IfcRelConnects
  [X.IFCRELCONTAINEDINSPATIALSTRUCTURE]: "IfcRelContainedInSpatialStructure",
  [X.IFCRELCONNECTSELEMENTS]: "IfcRelConnectsElements",
  [X.IFCRELFLOWCONTROLELEMENTS]: "IfcRelFlowControlElements",
  // IfcRelDeclares
  [X.IFCRELDECLARES]: "IfcRelDeclares",
  // IfcRelDecomposes
  [X.IFCRELAGGREGATES]: "IfcRelAggregates",
  [X.IFCRELNESTS]: "IfcRelNests",
  // IfcRelDefines
  [X.IFCRELDEFINESBYPROPERTIES]: "IfcRelDefinesByProperties",
  [X.IFCRELDEFINESBYTYPE]: "IfcRelDefinesByType",
  [X.IFCRELDEFINESBYTEMPLATE]: "IfcRelDefinesByTemplate"
}, Ae = class Ae extends St {
  constructor(t) {
    super(t);
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    /**
     * Event triggered when a file is requested for export.
     */
    T(this, "onRequestFile", new j());
    /**
     * ArrayBuffer containing the IFC data to be exported.
     */
    T(this, "ifcToExport", null);
    /**
     * Event triggered when an element is added to a Pset.
     */
    T(this, "onElementToPset", new j());
    /**
     * Event triggered when a property is added to a Pset.
     */
    T(this, "onPropToPset", new j());
    /**
     * Event triggered when a Pset is removed.
     */
    T(this, "onPsetRemoved", new j());
    /**
     * Event triggered when data in the model changes.
     */
    T(this, "onDataChanged", new j());
    /**
     * Configuration for the WebAssembly module.
     */
    T(this, "wasm", {
      path: "/",
      absolute: !1
    });
    /** {@link Component.enabled} */
    T(this, "enabled", !0);
    /**
     * Map of attribute listeners.
     */
    T(this, "attributeListeners", {});
    /**
     * The currently selected model.
     */
    T(this, "selectedModel");
    /**
     * Map of changed entities in the model.
     */
    T(this, "changeMap", {});
    this.components.add(Ae.uuid, this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.selectedModel = void 0, this.attributeListeners = {}, this.changeMap = {}, this.onElementToPset.reset(), this.onPropToPset.reset(), this.onPsetRemoved.reset(), this.onDataChanged.reset(), this.onDisposed.trigger(Ae.uuid), this.onDisposed.reset();
  }
  /**
   * Static method to retrieve the IFC schema from a given model.
   *
   * @param model - The FragmentsGroup model from which to retrieve the IFC schema.
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @returns The IFC schema associated with the given model.
   */
  static getIFCSchema(t) {
    const e = t.ifcMetadata.schema;
    if (!e)
      throw new Error("IFC Schema not found");
    return e.startsWith("IFC2X3") ? "IFC2X3" : e.startsWith("IFC4") && e.replace("IFC4", "") === "" ? "IFC4" : e.startsWith("IFC4X3") ? "IFC4X3" : e;
  }
  /**
   * Method to add or update entity attributes in the model.
   *
   * @param model - The FragmentsGroup model in which to set the properties.
   * @param dataToSave - An array of objects representing the properties to be saved.
   * Each object must have an `expressID` property, which is the express ID of the entity in the model.
   * The rest of the properties will be set as the properties of the entity.
   *
   * @returns A promise that resolves when all the properties have been set.
   *
   * @throws Will throw an error if any of the `expressID` properties are missing in the `dataToSave` array.
   */
  async setData(t, ...e) {
    for (const i of e) {
      const { expressID: n } = i;
      (!n || n === -1) && (i.expressID = this.getNewExpressID(t)), await t.setProperties(i.expressID, i), this.registerChange(t, i.expressID);
    }
  }
  /**
   * Creates a new Property Set (Pset) in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the Pset.
   * @param name - The name of the Pset.
   * @param description - (Optional) The description of the Pset.
   *
   * @returns A promise that resolves with an object containing the newly created Pset and its relation.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  async newPset(t, e, i) {
    const n = Ae.getIFCSchema(t), { ownerHistoryHandle: r } = await this.getOwnerHistory(t), o = this.newGUID(t), a = new X[n].IfcLabel(e), l = i ? new X[n].IfcText(i) : null, h = new X[n].IfcPropertySet(
      o,
      r,
      a,
      l,
      []
    );
    h.expressID = this.getNewExpressID(t);
    const d = this.newGUID(t), u = new X[n].IfcRelDefinesByProperties(
      d,
      r,
      null,
      null,
      [],
      new X.Handle(h.expressID)
    );
    return u.expressID = this.getNewExpressID(t), await this.setData(t, h, u), { pset: h, rel: u };
  }
  /**
   * Removes a Property Set (Pset) from the given model.
   *
   * @param model - The FragmentsGroup model from which to remove the Pset.
   * @param psetID - The express IDs of the Psets to be removed.
   *
   * @returns A promise that resolves when all the Psets have been removed.
   *
   * @throws Will throw an error if any of the `expressID` properties are missing in the `psetID` array.
   * @throws Will throw an error if the Pset to be removed is not of type `IFCPROPERTYSET`.
   * @throws Will throw an error if no relation is found between the Pset and the model.
   */
  async removePset(t, ...e) {
    for (const i of e) {
      const n = await t.getProperties(i);
      if ((n == null ? void 0 : n.type) !== X.IFCPROPERTYSET)
        continue;
      const r = await Ke.getPsetRel(t, i);
      if (r && (await t.setProperties(r, null), this.registerChange(t, r)), n) {
        for (const o of n.HasProperties)
          await t.setProperties(o.value, null);
        await t.setProperties(i, null), this.onPsetRemoved.trigger({ model: t, psetID: i }), this.registerChange(t, i);
      }
    }
  }
  /**
   * Creates a new single-value property of type string in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the property.
   * @param type - The type of the property value. Must be a string property type.
   * @param name - The name of the property.
   * @param value - The value of the property. Must be a string.
   *
   * @returns The newly created single-value property.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  newSingleStringProperty(t, e, i, n) {
    return this.newSingleProperty(t, e, i, n);
  }
  /**
   * Creates a new single-value property of type numeric in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the property.
   * @param type - The type of the property value. Must be a numeric property type.
   * @param name - The name of the property.
   * @param value - The value of the property. Must be a number.
   *
   * @returns The newly created single-value property.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  newSingleNumericProperty(t, e, i, n) {
    return this.newSingleProperty(t, e, i, n);
  }
  /**
   * Creates a new single-value property of type boolean in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the property.
   * @param type - The type of the property value. Must be a boolean property type.
   * @param name - The name of the property.
   * @param value - The value of the property. Must be a boolean.
   *
   * @returns The newly created single-value property.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  newSingleBooleanProperty(t, e, i, n) {
    return this.newSingleProperty(t, e, i, n);
  }
  /**
   * Removes a property from a Property Set (Pset) in the given model.
   *
   * @param model - The FragmentsGroup model from which to remove the property.
   * @param psetID - The express ID of the Pset from which to remove the property.
   * @param propID - The express ID of the property to be removed.
   *
   * @returns A promise that resolves when the property has been removed.
   *
   * @throws Will throw an error if the Pset or the property to be removed are not found in the model.
   * @throws Will throw an error if the Pset to be removed is not of type `IFCPROPERTYSET`.
   */
  async removePsetProp(t, e, i) {
    const n = await t.getProperties(e), r = await t.getProperties(i);
    !n || !r || n.type === X.IFCPROPERTYSET && r && (n.HasProperties = n.HasProperties.filter((o) => o.value !== i), await t.setProperties(i, null), this.registerChange(t, e, i));
  }
  /**
   * @deprecated Use indexer.addEntitiesRelation instead. This will be removed in future releases.
   */
  addElementToPset(t, e, ...i) {
    this.components.get(xe).addEntitiesRelation(
      t,
      e,
      { type: X.IFCRELDEFINESBYPROPERTIES, inv: "IsDefinedBy" },
      ...i
    );
  }
  /**
   * Adds elements to a Property Set (Pset) in the given model.
   *
   * @param model - The FragmentsGroup model in which to add the elements.
   * @param psetID - The express ID of the Pset to which to add the elements.
   * @param elementID - The express IDs of the elements to be added.
   *
   * @returns A promise that resolves when all the elements have been added.
   *
   * @throws Will throw an error if the Pset or the elements to be added are not found in the model.
   * @throws Will throw an error if the Pset to be added to is not of type `IFCPROPERTYSET`.
   * @throws Will throw an error if no relation is found between the Pset and the model.
   */
  async addPropToPset(t, e, ...i) {
    const n = await t.getProperties(e);
    if (n) {
      for (const r of i) {
        if (n.HasProperties.includes(r))
          continue;
        const o = new X.Handle(r);
        n.HasProperties.push(o), this.onPropToPset.trigger({ model: t, psetID: e, propID: r });
      }
      this.registerChange(t, e);
    }
  }
  /**
   * Creates a new instance of a relationship between entities in the IFC model.
   *
   * @param model - The FragmentsGroup model in which to create the relationship.
   * @param type - The type of the relationship to create.
   * @param relatingID - The express ID of the entity that is related to the other entities.
   * @param relatedIDs - The express IDs of the entities that are related to the relating entity.
   *
   * @returns A promise that resolves with the newly created relationship.
   *
   * @throws Will throw an error if the relationship type is unsupported.
   */
  async createIfcRel(t, e, i, n) {
    const r = cc[e];
    if (!r)
      throw new Error(`IfcPropertiesManager: ${r} is unsoported.`);
    const o = t.ifcMetadata.schema, a = ac[r], l = X[o][r];
    if (!(a && l))
      throw new Error(`IfcPropertiesManager: ${r} is unsoported.`);
    const h = [new X[o].IfcGloballyUniqueId(me.create())], { related: d, relating: u } = a, E = [...new Set(n)].map(
      (m) => new X.Handle(m)
    ), p = (m, C) => {
      for (let R = m; R < C - 1; R++)
        h.push(null);
    };
    d < u ? (p(1, d), h.push(E), p(d, u), h.push(new X.Handle(i))) : (p(1, u), p(u, d), h.push(new X.Handle(i)), h.push(E));
    const I = new l(...h);
    return await this.setData(t, I), I;
  }
  /**
   * Saves the changes made to the model to a new IFC file.
   *
   * @param model - The FragmentsGroup model from which to save the changes.
   * @param ifcToSaveOn - The Uint8Array representing the original IFC file.
   *
   * @returns A promise that resolves with the modified IFC data as a Uint8Array.
   *
   * @throws Will throw an error if any issues occur during the saving process.
   */
  async saveToIfc(t, e) {
    const i = this.components.get(dn), n = i.webIfc, r = await i.readIfcFile(e);
    await this.components.get(xe).applyRelationChanges();
    const a = this.changeMap[t.uuid] ?? [];
    for (const h of a) {
      const d = await t.getProperties(h);
      d ? n.WriteLine(r, d) : n.DeleteLine(r, h);
    }
    const l = n.SaveModel(r);
    return i.webIfc.CloseModel(r), i.cleanUp(), l;
  }
  /**
   * Retrieves all the entities of a specific type from the model and returns their express IDs wrapped in Handles.
   * This is used to make references of an entity inside another entity attributes.
   *
   * @param model - The FragmentsGroup model from which to retrieve the entities.
   * @param type - The type of the entities to retrieve. This should be the express ID of the IFC type.
   *
   * @returns A promise that resolves with an array of Handles, each containing the express ID of an entity of the specified type.
   * @returns null if the model doesn't have any entity of that type
   */
  async getEntityRef(t, e) {
    const i = await t.getAllPropertiesOfType(e);
    if (!i)
      return null;
    const n = [];
    for (const r in i) {
      const o = new X.Handle(Number(r));
      n.push(o);
    }
    return n;
  }
  /**
   * Sets an attribute listener for a specific attribute of an entity in the model.
   * The listener will trigger an event whenever the attribute's value changes.
   *
   * @param model - The FragmentsGroup model in which to set the attribute listener.
   * @param expressID - The express ID of the entity for which to set the listener.
   * @param attributeName - The name of the attribute for which to set the listener.
   *
   * @returns The event that will be triggered when the attribute's value changes.
   *
   * @throws Will throw an error if the entity with the given expressID doesn't exist.
   * @throws Will throw an error if the attribute is an array or null, and it can't have a listener.
   * @throws Will throw an error if the attribute has a badly defined handle.
   */
  async setAttributeListener(t, e, i) {
    this.attributeListeners[t.uuid] || (this.attributeListeners[t.uuid] = {});
    const n = this.attributeListeners[t.uuid][e] ? this.attributeListeners[t.uuid][e][i] : null;
    if (n)
      return n;
    const r = await t.getProperties(e);
    if (!r)
      throw new Error(`Entity with expressID ${e} doesn't exists.`);
    const o = r[i];
    if (Array.isArray(o) || !o)
      throw new Error(
        `Attribute ${i} is array or null, and it can't have a listener.`
      );
    const a = o.value;
    if (a === void 0 || a == null)
      throw new Error(`Attribute ${i} has a badly defined handle.`);
    const l = new j();
    return Object.defineProperty(r[i], "value", {
      get() {
        return this._value;
      },
      async set(h) {
        this._value = h, l.trigger(h);
      }
    }), r[i].value = a, this.attributeListeners[t.uuid][e] || (this.attributeListeners[t.uuid][e] = {}), this.attributeListeners[t.uuid][e][i] = l, l;
  }
  getNewExpressID(t) {
    return t.ifcMetadata.maxExpressID++, t.ifcMetadata.maxExpressID;
  }
  newGUID(t) {
    const e = Ae.getIFCSchema(t);
    return new X[e].IfcGloballyUniqueId(me.create());
  }
  async getOwnerHistory(t) {
    const e = await t.getAllPropertiesOfType(
      X.IFCOWNERHISTORY
    );
    if (!e)
      throw new Error("No OwnerHistory was found.");
    const i = Object.keys(e).map((o) => parseInt(o, 10)), n = e[i[0]], r = new X.Handle(n.expressID);
    return { ownerHistory: n, ownerHistoryHandle: r };
  }
  registerChange(t, ...e) {
    this.changeMap[t.uuid] || (this.changeMap[t.uuid] = /* @__PURE__ */ new Set());
    for (const i of e)
      this.changeMap[t.uuid].add(i), this.onDataChanged.trigger({ model: t, expressID: i });
  }
  async newSingleProperty(t, e, i, n) {
    const r = Ae.getIFCSchema(t), o = new X[r].IfcIdentifier(i), a = new X[r][e](n), l = new X[r].IfcPropertySingleValue(
      o,
      null,
      a,
      null
    );
    return l.expressID = this.getNewExpressID(t), await this.setData(t, l), l;
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
T(Ae, "uuid", "58c2d9f0-183c-48d6-a402-dfcf5b9a34df");
let un = Ae;
const Os = class Os extends St {
  constructor(t) {
    super(t);
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    /**
     * Event triggered when relations for a model have been indexed.
     * This event provides the model's UUID and the relations map generated for that model.
     *
     * @property {string} modelID - The UUID of the model for which relations have been indexed.
     * @property {RelationsMap} relationsMap - The relations map generated for the specified model.
     * The map keys are expressIDs of entities, and the values are maps where each key is a relation type ID and its value is an array of expressIDs of entities related through that relation type.
     */
    T(this, "onRelationsIndexed", new j());
    /**
     * Holds the relationship mappings for each model processed by the indexer.
     * The structure is a map where each key is a model's UUID, and the value is another map.
     * This inner map's keys are entity expressIDs, and its values are maps where each key is an index
     * representing a specific relation type, and the value is an array of expressIDs of entities
     * that are related through that relation type. This structure allows for efficient querying
     * of entity relationships within a model.
     */
    T(this, "relationMaps", {});
    /** {@link Component.enabled} */
    T(this, "enabled", !0);
    T(this, "_relToAttributesMap", gr);
    T(this, "_inverseAttributes", [
      "IsDecomposedBy",
      "Decomposes",
      "AssociatedTo",
      "HasAssociations",
      "ClassificationForObjects",
      "IsGroupedBy",
      "HasAssignments",
      "IsDefinedBy",
      "DefinesOcurrence",
      "IsTypedBy",
      "Types",
      "Defines",
      "ContainedInStructure",
      "ContainsElements",
      "HasControlElements",
      "AssignedToFlowElement",
      "ConnectedTo",
      "ConnectedFrom",
      "ReferencedBy",
      "Declares",
      "HasContext",
      "Controls",
      "IsNestedBy",
      "Nests",
      "DocumentRefForObjects"
    ]);
    T(this, "_ifcRels", [
      X.IFCRELAGGREGATES,
      X.IFCRELASSOCIATESMATERIAL,
      X.IFCRELASSOCIATESCLASSIFICATION,
      X.IFCRELASSIGNSTOGROUP,
      X.IFCRELDEFINESBYPROPERTIES,
      X.IFCRELDEFINESBYTYPE,
      X.IFCRELDEFINESBYTEMPLATE,
      X.IFCRELCONTAINEDINSPATIALSTRUCTURE,
      X.IFCRELFLOWCONTROLELEMENTS,
      X.IFCRELCONNECTSELEMENTS,
      X.IFCRELASSIGNSTOPRODUCT,
      X.IFCRELDECLARES,
      X.IFCRELASSIGNSTOCONTROL,
      X.IFCRELNESTS,
      X.IFCRELASSOCIATESDOCUMENT
    ]);
    T(this, "onFragmentsDisposed", (t) => {
      delete this.relationMaps[t.groupID];
    });
    // Use to create the corresponding IfcRelationship
    T(this, "_changeMap", {});
    /**
     * An event that is triggered when entities are related in a BIM model.
     * The event provides information about the type of relation, the inverse attribute,
     * the IDs of the entities related, and the IDs of the entities that are being related.
     */
    T(this, "onEntitiesRelated", new j());
    this.components.add(Os.uuid, this), t.get(_t).onFragmentsDisposed.add(this.onFragmentsDisposed);
  }
  indexRelations(t, e, i, n) {
    const r = Object.keys(e).find(
      (d) => d.startsWith("Relating")
    ), o = Object.keys(e).find(
      (d) => d.startsWith("Related")
    );
    if (!(r && o))
      return;
    const a = e[r].value, l = e[o].map((d) => d.value), h = this.getAttributeIndex(n);
    if (h !== null) {
      let d = t.get(a);
      d || (d = /* @__PURE__ */ new Map(), t.set(a, d));
      let u = d.get(h);
      u || (u = [], d.set(h, u)), u.push(...l);
    }
    for (const d of l) {
      const u = this.getAttributeIndex(i);
      if (u === null)
        continue;
      let f = t.get(d);
      f || (f = /* @__PURE__ */ new Map(), t.set(d, f));
      let E = f.get(u);
      E || (E = [], f.set(u, E)), E.push(a);
    }
  }
  getAttributeIndex(t) {
    const e = this._inverseAttributes.indexOf(t);
    return e === -1 ? null : e;
  }
  /**
   * Adds a relation map to the model's relations map.
   *
   * @param model - The `FragmentsGroup` model to which the relation map will be added.
   * @param relationMap - The `RelationsMap` to be added to the model's relations map.
   *
   * @fires onRelationsIndexed - Triggers an event with the model's UUID and the added relation map.
   */
  setRelationMap(t, e) {
    this.relationMaps[t.uuid] = e, this.onRelationsIndexed.trigger({
      modelID: t.uuid,
      relationsMap: e
    });
  }
  /**
   * Processes a given model to index its IFC entities relations based on predefined inverse attributes.
   * This method iterates through each specified inverse attribute, retrieves the corresponding relations,
   * and maps them in a structured way to facilitate quick access to related entities.
   *
   * The process involves querying the model for each relation type associated with the inverse attributes
   * and updating the internal relationMaps with the relationships found. This map is keyed by the model's UUID
   * and contains a nested map where each key is an entity's expressID and its value is another map.
   * This inner map's keys are the indices of the inverse attributes, and its values are arrays of expressIDs
   * of entities that are related through that attribute.
   *
   * @param model The `FragmentsGroup` model to be processed. It must have properties loaded.
   * @returns A promise that resolves to the relations map for the processed model. This map is a detailed
   * representation of the relations indexed by entity expressIDs and relation types.
   * @throws An error if the model does not have properties loaded.
   */
  async process(t) {
    if (!t.hasProperties)
      throw new Error("FragmentsGroup properties not found");
    let e = this.relationMaps[t.uuid];
    if (e)
      return e;
    e = /* @__PURE__ */ new Map();
    for (const i of this._ifcRels) {
      const n = await t.getAllPropertiesOfType(i);
      if (!n)
        continue;
      const r = this._relToAttributesMap.get(i);
      if (!r)
        continue;
      const { forRelated: o, forRelating: a } = r;
      for (const l in n) {
        const h = n[l];
        this.indexRelations(e, h, o, a);
      }
    }
    return this.setRelationMap(t, e), e;
  }
  /**
   * Processes a given model from a WebIfc API to index its IFC entities relations.
   *
   * @param ifcApi - The WebIfc API instance from which to retrieve the model's properties.
   * @param modelID - The unique identifier of the model within the WebIfc API.
   * @returns A promise that resolves to the relations map for the processed model.
   *          This map is a detailed representation of the relations indexed by entity expressIDs and relation types.
   */
  async processFromWebIfc(t, e) {
    const i = /* @__PURE__ */ new Map();
    for (const n of this._ifcRels) {
      const r = this._relToAttributesMap.get(n);
      if (!r)
        continue;
      const { forRelated: o, forRelating: a } = r, l = t.GetLineIDsWithType(e, n);
      for (let h = 0; h < l.size(); h++) {
        const d = await t.properties.getItemProperties(
          e,
          l.get(h)
        );
        this.indexRelations(i, d, o, a);
      }
    }
    return this.onRelationsIndexed.trigger({
      modelID: e.toString(),
      relationsMap: i
    }), i;
  }
  /**
   * Retrieves the relations of a specific entity within a model based on the given relation name.
   * This method searches the indexed relation maps for the specified model and entity,
   * returning the IDs of related entities if a match is found.
   *
   * @param model The `FragmentsGroup` model containing the entity.
   * @param expressID The unique identifier of the entity within the model.
   * @param relationName The IFC schema inverse attribute of the relation to search for (e.g., "IsDefinedBy", "ContainsElements").
   * @returns An array of express IDs representing the related entities, or `null` if no relations are found
   * or the specified relation name is not indexed.
   */
  getEntityRelations(t, e, i) {
    const n = this.relationMaps[t.uuid];
    if (!n)
      throw new Error(
        `IfcRelationsIndexer: model ${t.uuid} has no relations indexed.`
      );
    const r = n.get(e), o = this.getAttributeIndex(i);
    if (r === void 0 || o === null)
      return null;
    const a = r.get(o);
    return a || null;
  }
  /**
   * Serializes the relations of a given relation map into a JSON string.
   * This method iterates through the relations in the given map, organizing them into a structured object where each key is an expressID of an entity,
   * and its value is another object mapping relation indices to arrays of related entity expressIDs.
   * The resulting object is then serialized into a JSON string.
   *
   * @param relationMap - The map of relations to be serialized. The map keys are expressIDs of entities, and the values are maps where each key is a relation type ID and its value is an array of expressIDs of entities related through that relation type.
   * @returns A JSON string representing the serialized relations of the given relation map.
   */
  serializeRelations(t) {
    const e = {};
    for (const [i, n] of t.entries()) {
      e[i] || (e[i] = {});
      for (const [r, o] of n.entries())
        e[i][r] = o;
    }
    return JSON.stringify(e);
  }
  /**
   * Serializes the relations of a specific model into a JSON string.
   * This method iterates through the relations indexed for the given model,
   * organizing them into a structured object where each key is an expressID of an entity,
   * and its value is another object mapping relation indices to arrays of related entity expressIDs.
   * The resulting object is then serialized into a JSON string.
   *
   * @param model The `FragmentsGroup` model whose relations are to be serialized.
   * @returns A JSON string representing the serialized relations of the specified model.
   * If the model has no indexed relations, `null` is returned.
   */
  serializeModelRelations(t) {
    const e = this.relationMaps[t.uuid];
    return e ? this.serializeRelations(e) : null;
  }
  /**
   * Serializes all relations of every model processed by the indexer into a JSON string.
   * This method iterates through each model's relations indexed in `relationMaps`, organizing them
   * into a structured JSON object. Each top-level key in this object corresponds to a model's UUID,
   * and its value is another object mapping entity expressIDs to their related entities, categorized
   * by relation types. The structure facilitates easy access to any entity's relations across all models.
   *
   * @returns A JSON string representing the serialized relations of all models processed by the indexer.
   *          If no relations have been indexed, an empty object is returned as a JSON string.
   */
  serializeAllRelations() {
    const t = {};
    for (const e in this.relationMaps) {
      const i = this.relationMaps[e], n = {};
      for (const [r, o] of i.entries()) {
        n[r] || (n[r] = {});
        for (const [a, l] of o.entries())
          n[r][a] = l;
      }
      t[e] = n;
    }
    return JSON.stringify(t);
  }
  /**
   * Converts a JSON string representing relations between entities into a structured map.
   * This method parses the JSON string to reconstruct the relations map that indexes
   * entity relations by their express IDs. The outer map keys are the express IDs of entities,
   * and the values are maps where each key is a relation type ID and its value is an array
   * of express IDs of entities related through that relation type.
   *
   * @param json The JSON string to be parsed into the relations map.
   * @returns A `Map` where the key is the express ID of an entity as a number, and the value
   * is another `Map`. This inner map's key is the relation type ID as a number, and its value
   * is an array of express IDs (as numbers) of entities related through that relation type.
   */
  getRelationsMapFromJSON(t) {
    const e = JSON.parse(t), i = /* @__PURE__ */ new Map();
    for (const n in e) {
      const r = e[n], o = /* @__PURE__ */ new Map();
      for (const a in r)
        o.set(Number(a), r[a]);
      i.set(Number(n), o);
    }
    return i;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.relationMaps = {}, this.components.get(_t).onFragmentsDisposed.remove(this.onFragmentsDisposed), this.onDisposed.trigger(Os.uuid), this.onDisposed.reset();
  }
  /**
   * Retrieves the entities within a model that have a specific relation with a given entity.
   *
   * @param model - The BIM model to search for related entities.
   * @param inv - The IFC schema inverse attribute of the relation to search for (e.g., "IsDefinedBy", "ContainsElements").
   * @param expressID - The expressID of the entity within the model.
   *
   * @returns A `Set` with the expressIDs of the entities that have the specified relation with the given entity.
   *
   * @throws An error if the model relations are not indexed or if the inverse attribute name is invalid.
   */
  getEntitiesWithRelation(t, e, i) {
    const n = this.relationMaps[t.uuid];
    if (!n)
      throw new Error(
        "IfcRelationsIndexer: the model relations are not indexed!"
      );
    const r = /* @__PURE__ */ new Set();
    for (const [o, a] of n) {
      const l = this.getAttributeIndex(e);
      if (l === null)
        throw new Error("IfcRelationsIndexer: invalid inverse attribute name");
      const h = a.get(l);
      h && h.includes(i) && r.add(o);
    }
    return r;
  }
  /**
   * Adds relations between an entity and other entities in a BIM model.
   *
   * @param model - The BIM model to which the relations will be added.
   * @param expressID - The expressID of the entity within the model.
   * @param relationName - The IFC schema inverse attribute of the relation to add (e.g., "IsDefinedBy", "ContainsElements").
   * @param relIDs - The expressIDs of the related entities within the model.
   * @deprecated Use addEntitiesRelation instead. This will be removed in future versions.
   *
   * @throws An error if the relation name is not a valid relation name.
   */
  addEntityRelations(t, e, i, ...n) {
    const r = this.getEntityRelations(
      t,
      e,
      i
    );
    if (r)
      r.push(...n);
    else {
      const o = this.getAttributeIndex(i);
      if (!o)
        throw new Error(
          `IfcRelationsIndexer: ${i} is not a valid relation name.`
        );
      const a = this.relationMaps[t.uuid].get(e);
      a == null || a.set(o, n);
    }
  }
  // removeEntitiesRelation(
  //   model: FragmentsGroup,
  //   relatingID: number,
  //   relationName: InverseAttribute,
  //   ...relatedIDs: number[]
  // ) {}
  /**
   * Converts the relations made into actual IFC data.
   *
   * @remarks This function iterates through the changes made to the relations and applies them to the corresponding BIM model.
   * It only make sense to use if the relations need to be write in the IFC file.
   *
   * @returns A promise that resolves when all the relation changes have been applied.
   */
  async applyRelationChanges() {
    const t = this.components.get(_t), e = this.components.get(un);
    for (const i in this._changeMap) {
      const n = t.groups.get(i);
      if (!n)
        continue;
      const r = this._changeMap[i];
      for (const [o, a] of r)
        for (const [l, h] of a) {
          const { related: d, relID: u } = h;
          if (u) {
            const f = await n.getProperties(u);
            if (!f)
              continue;
            const E = Object.keys(f), p = E.find((m) => m.startsWith("Related")), I = E.find((m) => m.startsWith("Relating"));
            if (!(p && I))
              continue;
            f[p] = [...d].map((m) => new X.Handle(m)), f[I] = new X.Handle(l), await e.setData(n, f);
          } else {
            const f = await e.createIfcRel(
              n,
              o,
              l,
              [...d]
            );
            if (!f)
              continue;
            h.relID = f.expressID;
          }
        }
    }
  }
  addEntitiesRelation(t, e, i, ...n) {
    const { type: r, inv: o } = i, a = this.relationMaps[t.uuid];
    if (!a || !this._ifcRels.includes(r))
      return;
    const l = gr.get(r);
    if (!l)
      return;
    const { forRelated: h, forRelating: d } = l;
    if (!(h === o || d === o))
      return;
    let u = this._changeMap[t.uuid];
    u || (u = new Ee(), this._changeMap[t.uuid] = u);
    const f = d === o ? [e] : n, E = h === o ? [e] : n;
    let p = u.get(r);
    p || (p = new Ee(), p.onItemSet.add(
      () => this.onEntitiesRelated.trigger({
        invAttribute: o,
        relType: r,
        relatingIDs: f,
        relatedIDs: E
      })
    ), p.onItemUpdated.add(
      () => this.onEntitiesRelated.trigger({
        invAttribute: o,
        relType: r,
        relatingIDs: f,
        relatedIDs: E
      })
    ), u.set(r, p));
    for (const I of f) {
      let m = p.get(I);
      m || (m = { related: new qe() }, p.set(I, m)), m.related.add(...E);
    }
    for (const I of f) {
      let m = a.get(I);
      m || (m = /* @__PURE__ */ new Map(), a.set(I, m));
      const C = this.getAttributeIndex(d);
      if (C !== null) {
        let R = m.get(C);
        R || (R = [], m.set(C, R)), R.push(...E);
      }
    }
    for (const I of E) {
      let m = a.get(I);
      m || (m = /* @__PURE__ */ new Map(), a.set(I, m));
      const C = this.getAttributeIndex(h);
      if (C === null)
        continue;
      let R = m.get(C);
      R || (R = [], m.set(C, R)), R.push(...f);
    }
  }
  /**
   * Gets the children of the given element recursively. E.g. in a model with project - site - building - storeys - rooms, passing a storey will include all its children and the children of the rooms contained in it.
   *
   * @param model The BIM model whose children to get.
   * @param expressID The expressID of the item whose children to get.
   * @param found An optional parameter that includes a set of expressIDs where the found element IDs will be added.
   *
   * @returns A `Set` with the expressIDs of the found items.
   */
  getEntityChildren(t, e, i = /* @__PURE__ */ new Set()) {
    if (i.add(e), this.relationMaps[t.uuid] === void 0)
      throw new Error(
        "The provided model has no indices. You have to generate them first."
      );
    const r = this.getEntityRelations(
      t,
      e,
      "IsDecomposedBy"
    );
    if (r)
      for (const a of r)
        this.getEntityChildren(t, a, i);
    const o = this.getEntityRelations(t, e, "ContainsElements");
    if (o)
      for (const a of o)
        this.getEntityChildren(t, a, i);
    return i;
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
T(Os, "uuid", "23a889ab-83b3-44a4-8bee-ead83438370b");
let xe = Os;
const Ii = class Ii extends St {
  constructor(t) {
    super(t);
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    /**
     * Event triggered when fragments are loaded.
     */
    T(this, "onFragmentsLoaded", new j());
    /**
     * Event triggered when fragments are disposed.
     */
    T(this, "onFragmentsDisposed", new j());
    /**
     * DataMap containing all loaded fragments.
     * The key is the fragment's unique identifier, and the value is the fragment itself.
     */
    T(this, "list", new Ee());
    /**
     * DataMap containing all loaded fragment groups.
     * The key is the group's unique identifier, and the value is the group itself.
     */
    T(this, "groups", new Ee());
    T(this, "baseCoordinationModel", "");
    T(this, "baseCoordinationMatrix", new M.Matrix4());
    /** {@link Component.enabled} */
    T(this, "enabled", !0);
    T(this, "_loader", new fo());
    this.components.add(Ii.uuid, this);
  }
  /**
   * Getter for the meshes of all fragments in the FragmentsManager.
   * It iterates over the fragments in the list and pushes their meshes into an array.
   * @returns {THREE.Mesh[]} An array of THREE.Mesh objects representing the fragments.
   */
  get meshes() {
    const t = [];
    for (const [e, i] of this.list)
      t.push(i.mesh);
    return t;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [t, e] of this.groups)
      e.dispose(!0);
    this.baseCoordinationModel = "", this.groups.clear(), this.list.clear(), this.onFragmentsLoaded.reset(), this.onFragmentsDisposed.reset(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Dispose of a specific fragment group.
   * This method removes the group from the groups map, deletes all fragments within the group from the list,
   * disposes of the group, and triggers the onFragmentsDisposed event.
   *
   * @param group - The fragment group to be disposed.
   */
  disposeGroup(t) {
    const { uuid: e } = t, i = [];
    for (const n of t.items)
      i.push(n.id), this.list.delete(n.id);
    t.dispose(!0), this.groups.delete(t.uuid), this.groups.size === 0 && (this.baseCoordinationModel = "", this.baseCoordinationMatrix = new M.Matrix4()), this.onFragmentsDisposed.trigger({
      groupID: e,
      fragmentIDs: i
    });
  }
  /**
   * Loads a binary file that contain fragment geometry.
   * @param data - The binary data to load.
   * @param config - Optional configuration for loading.
   * @param config.isStreamed - Optional setting to determine whether this model is streamed or not.
   * @param config.coordinate - Whether to apply coordinate transformation. Default is true.
   * @param config.properties - Ifc properties to set on the loaded fragments. Not to be used when streaming.
   * @returns The loaded FragmentsGroup.
   */
  load(t, e) {
    const n = { ...{ coordinate: !0 }, ...e }, { coordinate: r, name: o, properties: a, relationsMap: l } = n, h = this._loader.import(t);
    e && (h.isStreamed = e.isStreamed || !1), o && (h.name = o);
    for (const d of h.items)
      d.group = h, this.list.set(d.id, d);
    return r && this.coordinate([h]), this.groups.set(h.uuid, h), a && h.setLocalProperties(a), l && this.components.get(xe).setRelationMap(h, l), this.onFragmentsLoaded.trigger(h), h;
  }
  /**
   * Export the specified fragmentsgroup to binary data.
   * @param group - the fragments group to be exported.
   * @returns the exported data as binary buffer.
   */
  export(t) {
    return this._loader.export(t);
  }
  /**
   * Gets a map of model IDs to sets of express IDs for the given fragment ID map.
   * @param fragmentIdMap - A map of fragment IDs to their corresponding express IDs.
   * @returns A map of model IDs to sets of express IDs.
   */
  getModelIdMap(t) {
    const e = {};
    for (const i in t) {
      const n = this.list.get(i);
      if (!(n && n.group))
        continue;
      const r = n.group;
      r.uuid in e || (e[r.uuid] = /* @__PURE__ */ new Set());
      const o = t[i];
      for (const a of o)
        e[r.uuid].add(a);
    }
    return e;
  }
  /**
   * Converts a map of model IDs to sets of express IDs to a fragment ID map.
   * @param modelIdMap - A map of model IDs to their corresponding express IDs.
   * @returns A fragment ID map.
   * @remarks
   * This method iterates through the provided model ID map, retrieves the corresponding model from the `groups` map,
   * and then calls the `getFragmentMap` method of the model to obtain a fragment ID map for the given express IDs.
   * The fragment ID maps are then merged into a single map and returned.
   * If a model with a given ID is not found in the `groups` map, the method skips that model and continues with the next one.
   */
  modelIdToFragmentIdMap(t) {
    let e = {};
    for (const i in t) {
      const n = this.groups.get(i);
      if (!n)
        continue;
      const r = t[i], o = n.getFragmentMap(r);
      e = { ...e, ...o };
    }
    return e;
  }
  /**
   * Converts a collection of IFC GUIDs to a fragmentIdMap.
   *
   * @param guids - An iterable collection of global IDs to be converted to a fragment ID map.
   *
   * @returns A fragment ID map, where the keys are fragment IDs and the values are the corresponding express IDs.
   */
  guidToFragmentIdMap(t) {
    const e = {};
    for (const [n, r] of this.groups) {
      n in e || (e[n] = /* @__PURE__ */ new Set());
      for (const o of t) {
        const a = r.globalToExpressIDs.get(o);
        a && e[n].add(a);
      }
    }
    return this.modelIdToFragmentIdMap(e);
  }
  /**
   * Converts a fragment ID map to a collection of IFC GUIDs.
   *
   * @param fragmentIdMap - A fragment ID map to be converted to a collection of IFC GUIDs.
   *
   * @returns An array of IFC GUIDs.
   */
  fragmentIdMapToGuids(t) {
    const e = [], i = this.getModelIdMap(t);
    for (const n in i) {
      const r = this.groups.get(n);
      if (!r)
        continue;
      const o = i[n];
      for (const a of o)
        for (const [l, h] of r.globalToExpressIDs.entries())
          if (h === a) {
            e.push(l);
            break;
          }
    }
    return e;
  }
  /**
   * Applies coordinate transformation to the provided models.
   * If no models are provided, all groups are used.
   * The first model in the list becomes the base model for coordinate transformation.
   * All other models are then transformed to match the base model's coordinate system.
   *
   * @param models - The models to apply coordinate transformation to.
   * If not provided, all models are used.
   */
  coordinate(t = Array.from(this.groups.values())) {
    if (this.baseCoordinationModel.length === 0) {
      const i = t.pop();
      if (!i)
        return;
      this.baseCoordinationModel = i.uuid, this.baseCoordinationMatrix = i.coordinationMatrix.clone();
    }
    if (t.length)
      for (const i of t)
        i.coordinationMatrix.equals(this.baseCoordinationMatrix) || (i.position.set(0, 0, 0), i.rotation.set(0, 0, 0), i.scale.set(1, 1, 1), i.updateMatrix(), this.applyBaseCoordinateSystem(i, i.coordinationMatrix));
  }
  /**
   * Applies the base coordinate system to the provided object.
   *
   * This function takes an object and its original coordinate system as input.
   * It then inverts the original coordinate system and applies the base coordinate system
   * to the object. This ensures that the object's position, rotation, and scale are
   * transformed to match the base coordinate system (which is taken from the first model loaded).
   *
   * @param object - The object to which the base coordinate system will be applied.
   * This should be an instance of THREE.Object3D.
   *
   * @param originalCoordinateSystem - The original coordinate system of the object.
   * This should be a THREE.Matrix4 representing the object's transformation matrix.
   */
  applyBaseCoordinateSystem(t, e) {
    e && t.applyMatrix4(e.clone().invert()), t.applyMatrix4(this.baseCoordinationMatrix);
  }
  /**
   * Creates a copy of the whole model or a part of it.
   *
   * @param model - The model to clone.
   * @param items - Optional - The part of the model to be cloned. If not given, the whole group is cloned.
   *
   */
  clone(t, e) {
    const i = t.cloneGroup(e);
    this.groups.set(i.uuid, i);
    for (const n of i.items)
      this.list.set(n.id, n);
    return i;
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
T(Ii, "uuid", "fef46874-46a3-461b-8c44-2922ab77c806");
let _t = Ii;
var ii = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function lc(c) {
  return c && c.__esModule && Object.prototype.hasOwnProperty.call(c, "default") ? c.default : c;
}
function ni(c) {
  throw new Error('Could not dynamically require "' + c + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Wr = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(c, s) {
  (function(t) {
    c.exports = t();
  })(function() {
    return function t(e, i, n) {
      function r(l, h) {
        if (!i[l]) {
          if (!e[l]) {
            var d = typeof ni == "function" && ni;
            if (!h && d)
              return d(l, !0);
            if (o)
              return o(l, !0);
            var u = new Error("Cannot find module '" + l + "'");
            throw u.code = "MODULE_NOT_FOUND", u;
          }
          var f = i[l] = { exports: {} };
          e[l][0].call(f.exports, function(E) {
            var p = e[l][1][E];
            return r(p || E);
          }, f, f.exports, t, e, i, n);
        }
        return i[l].exports;
      }
      for (var o = typeof ni == "function" && ni, a = 0; a < n.length; a++)
        r(n[a]);
      return r;
    }({ 1: [function(t, e, i) {
      var n = t("./utils"), r = t("./support"), o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      i.encode = function(a) {
        for (var l, h, d, u, f, E, p, I = [], m = 0, C = a.length, R = C, g = n.getTypeOf(a) !== "string"; m < a.length; )
          R = C - m, d = g ? (l = a[m++], h = m < C ? a[m++] : 0, m < C ? a[m++] : 0) : (l = a.charCodeAt(m++), h = m < C ? a.charCodeAt(m++) : 0, m < C ? a.charCodeAt(m++) : 0), u = l >> 2, f = (3 & l) << 4 | h >> 4, E = 1 < R ? (15 & h) << 2 | d >> 6 : 64, p = 2 < R ? 63 & d : 64, I.push(o.charAt(u) + o.charAt(f) + o.charAt(E) + o.charAt(p));
        return I.join("");
      }, i.decode = function(a) {
        var l, h, d, u, f, E, p = 0, I = 0, m = "data:";
        if (a.substr(0, m.length) === m)
          throw new Error("Invalid base64 input, it looks like a data url.");
        var C, R = 3 * (a = a.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (a.charAt(a.length - 1) === o.charAt(64) && R--, a.charAt(a.length - 2) === o.charAt(64) && R--, R % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (C = r.uint8array ? new Uint8Array(0 | R) : new Array(0 | R); p < a.length; )
          l = o.indexOf(a.charAt(p++)) << 2 | (u = o.indexOf(a.charAt(p++))) >> 4, h = (15 & u) << 4 | (f = o.indexOf(a.charAt(p++))) >> 2, d = (3 & f) << 6 | (E = o.indexOf(a.charAt(p++))), C[I++] = l, f !== 64 && (C[I++] = h), E !== 64 && (C[I++] = d);
        return C;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(t, e, i) {
      var n = t("./external"), r = t("./stream/DataWorker"), o = t("./stream/Crc32Probe"), a = t("./stream/DataLengthProbe");
      function l(h, d, u, f, E) {
        this.compressedSize = h, this.uncompressedSize = d, this.crc32 = u, this.compression = f, this.compressedContent = E;
      }
      l.prototype = { getContentWorker: function() {
        var h = new r(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), d = this;
        return h.on("end", function() {
          if (this.streamInfo.data_length !== d.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), h;
      }, getCompressedWorker: function() {
        return new r(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, l.createWorkerFrom = function(h, d, u) {
        return h.pipe(new o()).pipe(new a("uncompressedSize")).pipe(d.compressWorker(u)).pipe(new a("compressedSize")).withStreamInfo("compression", d);
      }, e.exports = l;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(t, e, i) {
      var n = t("./stream/GenericWorker");
      i.STORE = { magic: "\0\0", compressWorker: function() {
        return new n("STORE compression");
      }, uncompressWorker: function() {
        return new n("STORE decompression");
      } }, i.DEFLATE = t("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(t, e, i) {
      var n = t("./utils"), r = function() {
        for (var o, a = [], l = 0; l < 256; l++) {
          o = l;
          for (var h = 0; h < 8; h++)
            o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
          a[l] = o;
        }
        return a;
      }();
      e.exports = function(o, a) {
        return o !== void 0 && o.length ? n.getTypeOf(o) !== "string" ? function(l, h, d, u) {
          var f = r, E = u + d;
          l ^= -1;
          for (var p = u; p < E; p++)
            l = l >>> 8 ^ f[255 & (l ^ h[p])];
          return -1 ^ l;
        }(0 | a, o, o.length, 0) : function(l, h, d, u) {
          var f = r, E = u + d;
          l ^= -1;
          for (var p = u; p < E; p++)
            l = l >>> 8 ^ f[255 & (l ^ h.charCodeAt(p))];
          return -1 ^ l;
        }(0 | a, o, o.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(t, e, i) {
      i.base64 = !1, i.binary = !1, i.dir = !1, i.createFolders = !0, i.date = null, i.compression = null, i.compressionOptions = null, i.comment = null, i.unixPermissions = null, i.dosPermissions = null;
    }, {}], 6: [function(t, e, i) {
      var n = null;
      n = typeof Promise < "u" ? Promise : t("lie"), e.exports = { Promise: n };
    }, { lie: 37 }], 7: [function(t, e, i) {
      var n = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", r = t("pako"), o = t("./utils"), a = t("./stream/GenericWorker"), l = n ? "uint8array" : "array";
      function h(d, u) {
        a.call(this, "FlateWorker/" + d), this._pako = null, this._pakoAction = d, this._pakoOptions = u, this.meta = {};
      }
      i.magic = "\b\0", o.inherits(h, a), h.prototype.processChunk = function(d) {
        this.meta = d.meta, this._pako === null && this._createPako(), this._pako.push(o.transformTo(l, d.data), !1);
      }, h.prototype.flush = function() {
        a.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, h.prototype.cleanUp = function() {
        a.prototype.cleanUp.call(this), this._pako = null;
      }, h.prototype._createPako = function() {
        this._pako = new r[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var d = this;
        this._pako.onData = function(u) {
          d.push({ data: u, meta: d.meta });
        };
      }, i.compressWorker = function(d) {
        return new h("Deflate", d);
      }, i.uncompressWorker = function() {
        return new h("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(t, e, i) {
      function n(f, E) {
        var p, I = "";
        for (p = 0; p < E; p++)
          I += String.fromCharCode(255 & f), f >>>= 8;
        return I;
      }
      function r(f, E, p, I, m, C) {
        var R, g, y = f.file, F = f.compression, S = C !== l.utf8encode, L = o.transformTo("string", C(y.name)), N = o.transformTo("string", l.utf8encode(y.name)), x = y.comment, k = o.transformTo("string", C(x)), w = o.transformTo("string", l.utf8encode(x)), P = N.length !== y.name.length, _ = w.length !== x.length, v = "", Q = "", V = "", et = y.dir, H = y.date, nt = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        E && !p || (nt.crc32 = f.crc32, nt.compressedSize = f.compressedSize, nt.uncompressedSize = f.uncompressedSize);
        var z = 0;
        E && (z |= 8), S || !P && !_ || (z |= 2048);
        var U = 0, ot = 0;
        et && (U |= 16), m === "UNIX" ? (ot = 798, U |= function(tt, Rt) {
          var Ft = tt;
          return tt || (Ft = Rt ? 16893 : 33204), (65535 & Ft) << 16;
        }(y.unixPermissions, et)) : (ot = 20, U |= function(tt) {
          return 63 & (tt || 0);
        }(y.dosPermissions)), R = H.getUTCHours(), R <<= 6, R |= H.getUTCMinutes(), R <<= 5, R |= H.getUTCSeconds() / 2, g = H.getUTCFullYear() - 1980, g <<= 4, g |= H.getUTCMonth() + 1, g <<= 5, g |= H.getUTCDate(), P && (Q = n(1, 1) + n(h(L), 4) + N, v += "up" + n(Q.length, 2) + Q), _ && (V = n(1, 1) + n(h(k), 4) + w, v += "uc" + n(V.length, 2) + V);
        var st = "";
        return st += `
\0`, st += n(z, 2), st += F.magic, st += n(R, 2), st += n(g, 2), st += n(nt.crc32, 4), st += n(nt.compressedSize, 4), st += n(nt.uncompressedSize, 4), st += n(L.length, 2), st += n(v.length, 2), { fileRecord: d.LOCAL_FILE_HEADER + st + L + v, dirRecord: d.CENTRAL_FILE_HEADER + n(ot, 2) + st + n(k.length, 2) + "\0\0\0\0" + n(U, 4) + n(I, 4) + L + v + k };
      }
      var o = t("../utils"), a = t("../stream/GenericWorker"), l = t("../utf8"), h = t("../crc32"), d = t("../signature");
      function u(f, E, p, I) {
        a.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = E, this.zipPlatform = p, this.encodeFileName = I, this.streamFiles = f, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      o.inherits(u, a), u.prototype.push = function(f) {
        var E = f.meta.percent || 0, p = this.entriesCount, I = this._sources.length;
        this.accumulate ? this.contentBuffer.push(f) : (this.bytesWritten += f.data.length, a.prototype.push.call(this, { data: f.data, meta: { currentFile: this.currentFile, percent: p ? (E + 100 * (p - I - 1)) / p : 100 } }));
      }, u.prototype.openedSource = function(f) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = f.file.name;
        var E = this.streamFiles && !f.file.dir;
        if (E) {
          var p = r(f, E, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: p.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = !0;
      }, u.prototype.closedSource = function(f) {
        this.accumulate = !1;
        var E = this.streamFiles && !f.file.dir, p = r(f, E, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(p.dirRecord), E)
          this.push({ data: function(I) {
            return d.DATA_DESCRIPTOR + n(I.crc32, 4) + n(I.compressedSize, 4) + n(I.uncompressedSize, 4);
          }(f), meta: { percent: 100 } });
        else
          for (this.push({ data: p.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, u.prototype.flush = function() {
        for (var f = this.bytesWritten, E = 0; E < this.dirRecords.length; E++)
          this.push({ data: this.dirRecords[E], meta: { percent: 100 } });
        var p = this.bytesWritten - f, I = function(m, C, R, g, y) {
          var F = o.transformTo("string", y(g));
          return d.CENTRAL_DIRECTORY_END + "\0\0\0\0" + n(m, 2) + n(m, 2) + n(C, 4) + n(R, 4) + n(F.length, 2) + F;
        }(this.dirRecords.length, p, f, this.zipComment, this.encodeFileName);
        this.push({ data: I, meta: { percent: 100 } });
      }, u.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, u.prototype.registerPrevious = function(f) {
        this._sources.push(f);
        var E = this;
        return f.on("data", function(p) {
          E.processChunk(p);
        }), f.on("end", function() {
          E.closedSource(E.previous.streamInfo), E._sources.length ? E.prepareNextSource() : E.end();
        }), f.on("error", function(p) {
          E.error(p);
        }), this;
      }, u.prototype.resume = function() {
        return !!a.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, u.prototype.error = function(f) {
        var E = this._sources;
        if (!a.prototype.error.call(this, f))
          return !1;
        for (var p = 0; p < E.length; p++)
          try {
            E[p].error(f);
          } catch {
          }
        return !0;
      }, u.prototype.lock = function() {
        a.prototype.lock.call(this);
        for (var f = this._sources, E = 0; E < f.length; E++)
          f[E].lock();
      }, e.exports = u;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(t, e, i) {
      var n = t("../compressions"), r = t("./ZipFileWorker");
      i.generateWorker = function(o, a, l) {
        var h = new r(a.streamFiles, l, a.platform, a.encodeFileName), d = 0;
        try {
          o.forEach(function(u, f) {
            d++;
            var E = function(C, R) {
              var g = C || R, y = n[g];
              if (!y)
                throw new Error(g + " is not a valid compression method !");
              return y;
            }(f.options.compression, a.compression), p = f.options.compressionOptions || a.compressionOptions || {}, I = f.dir, m = f.date;
            f._compressWorker(E, p).withStreamInfo("file", { name: u, dir: I, date: m, comment: f.comment || "", unixPermissions: f.unixPermissions, dosPermissions: f.dosPermissions }).pipe(h);
          }), h.entriesCount = d;
        } catch (u) {
          h.error(u);
        }
        return h;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(t, e, i) {
      function n() {
        if (!(this instanceof n))
          return new n();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var r = new n();
          for (var o in this)
            typeof this[o] != "function" && (r[o] = this[o]);
          return r;
        };
      }
      (n.prototype = t("./object")).loadAsync = t("./load"), n.support = t("./support"), n.defaults = t("./defaults"), n.version = "3.10.1", n.loadAsync = function(r, o) {
        return new n().loadAsync(r, o);
      }, n.external = t("./external"), e.exports = n;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(t, e, i) {
      var n = t("./utils"), r = t("./external"), o = t("./utf8"), a = t("./zipEntries"), l = t("./stream/Crc32Probe"), h = t("./nodejsUtils");
      function d(u) {
        return new r.Promise(function(f, E) {
          var p = u.decompressed.getContentWorker().pipe(new l());
          p.on("error", function(I) {
            E(I);
          }).on("end", function() {
            p.streamInfo.crc32 !== u.decompressed.crc32 ? E(new Error("Corrupted zip : CRC32 mismatch")) : f();
          }).resume();
        });
      }
      e.exports = function(u, f) {
        var E = this;
        return f = n.extend(f || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: o.utf8decode }), h.isNode && h.isStream(u) ? r.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : n.prepareContent("the loaded zip file", u, !0, f.optimizedBinaryString, f.base64).then(function(p) {
          var I = new a(f);
          return I.load(p), I;
        }).then(function(p) {
          var I = [r.Promise.resolve(p)], m = p.files;
          if (f.checkCRC32)
            for (var C = 0; C < m.length; C++)
              I.push(d(m[C]));
          return r.Promise.all(I);
        }).then(function(p) {
          for (var I = p.shift(), m = I.files, C = 0; C < m.length; C++) {
            var R = m[C], g = R.fileNameStr, y = n.resolve(R.fileNameStr);
            E.file(y, R.decompressed, { binary: !0, optimizedBinaryString: !0, date: R.date, dir: R.dir, comment: R.fileCommentStr.length ? R.fileCommentStr : null, unixPermissions: R.unixPermissions, dosPermissions: R.dosPermissions, createFolders: f.createFolders }), R.dir || (E.file(y).unsafeOriginalName = g);
          }
          return I.zipComment.length && (E.comment = I.zipComment), E;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(t, e, i) {
      var n = t("../utils"), r = t("../stream/GenericWorker");
      function o(a, l) {
        r.call(this, "Nodejs stream input adapter for " + a), this._upstreamEnded = !1, this._bindStream(l);
      }
      n.inherits(o, r), o.prototype._bindStream = function(a) {
        var l = this;
        (this._stream = a).pause(), a.on("data", function(h) {
          l.push({ data: h, meta: { percent: 0 } });
        }).on("error", function(h) {
          l.isPaused ? this.generatedError = h : l.error(h);
        }).on("end", function() {
          l.isPaused ? l._upstreamEnded = !0 : l.end();
        });
      }, o.prototype.pause = function() {
        return !!r.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, o.prototype.resume = function() {
        return !!r.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, e.exports = o;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(t, e, i) {
      var n = t("readable-stream").Readable;
      function r(o, a, l) {
        n.call(this, a), this._helper = o;
        var h = this;
        o.on("data", function(d, u) {
          h.push(d) || h._helper.pause(), l && l(u);
        }).on("error", function(d) {
          h.emit("error", d);
        }).on("end", function() {
          h.push(null);
        });
      }
      t("../utils").inherits(r, n), r.prototype._read = function() {
        this._helper.resume();
      }, e.exports = r;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(t, e, i) {
      e.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(n, r) {
        if (Buffer.from && Buffer.from !== Uint8Array.from)
          return Buffer.from(n, r);
        if (typeof n == "number")
          throw new Error('The "data" argument must not be a number');
        return new Buffer(n, r);
      }, allocBuffer: function(n) {
        if (Buffer.alloc)
          return Buffer.alloc(n);
        var r = new Buffer(n);
        return r.fill(0), r;
      }, isBuffer: function(n) {
        return Buffer.isBuffer(n);
      }, isStream: function(n) {
        return n && typeof n.on == "function" && typeof n.pause == "function" && typeof n.resume == "function";
      } };
    }, {}], 15: [function(t, e, i) {
      function n(y, F, S) {
        var L, N = o.getTypeOf(F), x = o.extend(S || {}, h);
        x.date = x.date || /* @__PURE__ */ new Date(), x.compression !== null && (x.compression = x.compression.toUpperCase()), typeof x.unixPermissions == "string" && (x.unixPermissions = parseInt(x.unixPermissions, 8)), x.unixPermissions && 16384 & x.unixPermissions && (x.dir = !0), x.dosPermissions && 16 & x.dosPermissions && (x.dir = !0), x.dir && (y = m(y)), x.createFolders && (L = I(y)) && C.call(this, L, !0);
        var k = N === "string" && x.binary === !1 && x.base64 === !1;
        S && S.binary !== void 0 || (x.binary = !k), (F instanceof d && F.uncompressedSize === 0 || x.dir || !F || F.length === 0) && (x.base64 = !1, x.binary = !0, F = "", x.compression = "STORE", N = "string");
        var w = null;
        w = F instanceof d || F instanceof a ? F : E.isNode && E.isStream(F) ? new p(y, F) : o.prepareContent(y, F, x.binary, x.optimizedBinaryString, x.base64);
        var P = new u(y, w, x);
        this.files[y] = P;
      }
      var r = t("./utf8"), o = t("./utils"), a = t("./stream/GenericWorker"), l = t("./stream/StreamHelper"), h = t("./defaults"), d = t("./compressedObject"), u = t("./zipObject"), f = t("./generate"), E = t("./nodejsUtils"), p = t("./nodejs/NodejsStreamInputAdapter"), I = function(y) {
        y.slice(-1) === "/" && (y = y.substring(0, y.length - 1));
        var F = y.lastIndexOf("/");
        return 0 < F ? y.substring(0, F) : "";
      }, m = function(y) {
        return y.slice(-1) !== "/" && (y += "/"), y;
      }, C = function(y, F) {
        return F = F !== void 0 ? F : h.createFolders, y = m(y), this.files[y] || n.call(this, y, null, { dir: !0, createFolders: F }), this.files[y];
      };
      function R(y) {
        return Object.prototype.toString.call(y) === "[object RegExp]";
      }
      var g = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(y) {
        var F, S, L;
        for (F in this.files)
          L = this.files[F], (S = F.slice(this.root.length, F.length)) && F.slice(0, this.root.length) === this.root && y(S, L);
      }, filter: function(y) {
        var F = [];
        return this.forEach(function(S, L) {
          y(S, L) && F.push(L);
        }), F;
      }, file: function(y, F, S) {
        if (arguments.length !== 1)
          return y = this.root + y, n.call(this, y, F, S), this;
        if (R(y)) {
          var L = y;
          return this.filter(function(x, k) {
            return !k.dir && L.test(x);
          });
        }
        var N = this.files[this.root + y];
        return N && !N.dir ? N : null;
      }, folder: function(y) {
        if (!y)
          return this;
        if (R(y))
          return this.filter(function(N, x) {
            return x.dir && y.test(N);
          });
        var F = this.root + y, S = C.call(this, F), L = this.clone();
        return L.root = S.name, L;
      }, remove: function(y) {
        y = this.root + y;
        var F = this.files[y];
        if (F || (y.slice(-1) !== "/" && (y += "/"), F = this.files[y]), F && !F.dir)
          delete this.files[y];
        else
          for (var S = this.filter(function(N, x) {
            return x.name.slice(0, y.length) === y;
          }), L = 0; L < S.length; L++)
            delete this.files[S[L].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(y) {
        var F, S = {};
        try {
          if ((S = o.extend(y || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: r.utf8encode })).type = S.type.toLowerCase(), S.compression = S.compression.toUpperCase(), S.type === "binarystring" && (S.type = "string"), !S.type)
            throw new Error("No output type specified.");
          o.checkSupport(S.type), S.platform !== "darwin" && S.platform !== "freebsd" && S.platform !== "linux" && S.platform !== "sunos" || (S.platform = "UNIX"), S.platform === "win32" && (S.platform = "DOS");
          var L = S.comment || this.comment || "";
          F = f.generateWorker(this, S, L);
        } catch (N) {
          (F = new a("error")).error(N);
        }
        return new l(F, S.type || "string", S.mimeType);
      }, generateAsync: function(y, F) {
        return this.generateInternalStream(y).accumulate(F);
      }, generateNodeStream: function(y, F) {
        return (y = y || {}).type || (y.type = "nodebuffer"), this.generateInternalStream(y).toNodejsStream(F);
      } };
      e.exports = g;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(t, e, i) {
      e.exports = t("stream");
    }, { stream: void 0 }], 17: [function(t, e, i) {
      var n = t("./DataReader");
      function r(o) {
        n.call(this, o);
        for (var a = 0; a < this.data.length; a++)
          o[a] = 255 & o[a];
      }
      t("../utils").inherits(r, n), r.prototype.byteAt = function(o) {
        return this.data[this.zero + o];
      }, r.prototype.lastIndexOfSignature = function(o) {
        for (var a = o.charCodeAt(0), l = o.charCodeAt(1), h = o.charCodeAt(2), d = o.charCodeAt(3), u = this.length - 4; 0 <= u; --u)
          if (this.data[u] === a && this.data[u + 1] === l && this.data[u + 2] === h && this.data[u + 3] === d)
            return u - this.zero;
        return -1;
      }, r.prototype.readAndCheckSignature = function(o) {
        var a = o.charCodeAt(0), l = o.charCodeAt(1), h = o.charCodeAt(2), d = o.charCodeAt(3), u = this.readData(4);
        return a === u[0] && l === u[1] && h === u[2] && d === u[3];
      }, r.prototype.readData = function(o) {
        if (this.checkOffset(o), o === 0)
          return [];
        var a = this.data.slice(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, a;
      }, e.exports = r;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(t, e, i) {
      var n = t("../utils");
      function r(o) {
        this.data = o, this.length = o.length, this.index = 0, this.zero = 0;
      }
      r.prototype = { checkOffset: function(o) {
        this.checkIndex(this.index + o);
      }, checkIndex: function(o) {
        if (this.length < this.zero + o || o < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + o + "). Corrupted zip ?");
      }, setIndex: function(o) {
        this.checkIndex(o), this.index = o;
      }, skip: function(o) {
        this.setIndex(this.index + o);
      }, byteAt: function() {
      }, readInt: function(o) {
        var a, l = 0;
        for (this.checkOffset(o), a = this.index + o - 1; a >= this.index; a--)
          l = (l << 8) + this.byteAt(a);
        return this.index += o, l;
      }, readString: function(o) {
        return n.transformTo("string", this.readData(o));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var o = this.readInt(4);
        return new Date(Date.UTC(1980 + (o >> 25 & 127), (o >> 21 & 15) - 1, o >> 16 & 31, o >> 11 & 31, o >> 5 & 63, (31 & o) << 1));
      } }, e.exports = r;
    }, { "../utils": 32 }], 19: [function(t, e, i) {
      var n = t("./Uint8ArrayReader");
      function r(o) {
        n.call(this, o);
      }
      t("../utils").inherits(r, n), r.prototype.readData = function(o) {
        this.checkOffset(o);
        var a = this.data.slice(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, a;
      }, e.exports = r;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(t, e, i) {
      var n = t("./DataReader");
      function r(o) {
        n.call(this, o);
      }
      t("../utils").inherits(r, n), r.prototype.byteAt = function(o) {
        return this.data.charCodeAt(this.zero + o);
      }, r.prototype.lastIndexOfSignature = function(o) {
        return this.data.lastIndexOf(o) - this.zero;
      }, r.prototype.readAndCheckSignature = function(o) {
        return o === this.readData(4);
      }, r.prototype.readData = function(o) {
        this.checkOffset(o);
        var a = this.data.slice(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, a;
      }, e.exports = r;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(t, e, i) {
      var n = t("./ArrayReader");
      function r(o) {
        n.call(this, o);
      }
      t("../utils").inherits(r, n), r.prototype.readData = function(o) {
        if (this.checkOffset(o), o === 0)
          return new Uint8Array(0);
        var a = this.data.subarray(this.zero + this.index, this.zero + this.index + o);
        return this.index += o, a;
      }, e.exports = r;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(t, e, i) {
      var n = t("../utils"), r = t("../support"), o = t("./ArrayReader"), a = t("./StringReader"), l = t("./NodeBufferReader"), h = t("./Uint8ArrayReader");
      e.exports = function(d) {
        var u = n.getTypeOf(d);
        return n.checkSupport(u), u !== "string" || r.uint8array ? u === "nodebuffer" ? new l(d) : r.uint8array ? new h(n.transformTo("uint8array", d)) : new o(n.transformTo("array", d)) : new a(d);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(t, e, i) {
      i.LOCAL_FILE_HEADER = "PK", i.CENTRAL_FILE_HEADER = "PK", i.CENTRAL_DIRECTORY_END = "PK", i.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", i.ZIP64_CENTRAL_DIRECTORY_END = "PK", i.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(t, e, i) {
      var n = t("./GenericWorker"), r = t("../utils");
      function o(a) {
        n.call(this, "ConvertWorker to " + a), this.destType = a;
      }
      r.inherits(o, n), o.prototype.processChunk = function(a) {
        this.push({ data: r.transformTo(this.destType, a.data), meta: a.meta });
      }, e.exports = o;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(t, e, i) {
      var n = t("./GenericWorker"), r = t("../crc32");
      function o() {
        n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      t("../utils").inherits(o, n), o.prototype.processChunk = function(a) {
        this.streamInfo.crc32 = r(a.data, this.streamInfo.crc32 || 0), this.push(a);
      }, e.exports = o;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(t, e, i) {
      var n = t("../utils"), r = t("./GenericWorker");
      function o(a) {
        r.call(this, "DataLengthProbe for " + a), this.propName = a, this.withStreamInfo(a, 0);
      }
      n.inherits(o, r), o.prototype.processChunk = function(a) {
        if (a) {
          var l = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = l + a.data.length;
        }
        r.prototype.processChunk.call(this, a);
      }, e.exports = o;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(t, e, i) {
      var n = t("../utils"), r = t("./GenericWorker");
      function o(a) {
        r.call(this, "DataWorker");
        var l = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, a.then(function(h) {
          l.dataIsReady = !0, l.data = h, l.max = h && h.length || 0, l.type = n.getTypeOf(h), l.isPaused || l._tickAndRepeat();
        }, function(h) {
          l.error(h);
        });
      }
      n.inherits(o, r), o.prototype.cleanUp = function() {
        r.prototype.cleanUp.call(this), this.data = null;
      }, o.prototype.resume = function() {
        return !!r.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, n.delay(this._tickAndRepeat, [], this)), !0);
      }, o.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, o.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return !1;
        var a = null, l = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            a = this.data.substring(this.index, l);
            break;
          case "uint8array":
            a = this.data.subarray(this.index, l);
            break;
          case "array":
          case "nodebuffer":
            a = this.data.slice(this.index, l);
        }
        return this.index = l, this.push({ data: a, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, e.exports = o;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(t, e, i) {
      function n(r) {
        this.name = r || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      n.prototype = { push: function(r) {
        this.emit("data", r);
      }, end: function() {
        if (this.isFinished)
          return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (r) {
          this.emit("error", r);
        }
        return !0;
      }, error: function(r) {
        return !this.isFinished && (this.isPaused ? this.generatedError = r : (this.isFinished = !0, this.emit("error", r), this.previous && this.previous.error(r), this.cleanUp()), !0);
      }, on: function(r, o) {
        return this._listeners[r].push(o), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(r, o) {
        if (this._listeners[r])
          for (var a = 0; a < this._listeners[r].length; a++)
            this._listeners[r][a].call(this, o);
      }, pipe: function(r) {
        return r.registerPrevious(this);
      }, registerPrevious: function(r) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = r.streamInfo, this.mergeStreamInfo(), this.previous = r;
        var o = this;
        return r.on("data", function(a) {
          o.processChunk(a);
        }), r.on("end", function() {
          o.end();
        }), r.on("error", function(a) {
          o.error(a);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return !1;
        var r = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), r = !0), this.previous && this.previous.resume(), !r;
      }, flush: function() {
      }, processChunk: function(r) {
        this.push(r);
      }, withStreamInfo: function(r, o) {
        return this.extraStreamInfo[r] = o, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var r in this.extraStreamInfo)
          Object.prototype.hasOwnProperty.call(this.extraStreamInfo, r) && (this.streamInfo[r] = this.extraStreamInfo[r]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var r = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + r : r;
      } }, e.exports = n;
    }, {}], 29: [function(t, e, i) {
      var n = t("../utils"), r = t("./ConvertWorker"), o = t("./GenericWorker"), a = t("../base64"), l = t("../support"), h = t("../external"), d = null;
      if (l.nodestream)
        try {
          d = t("../nodejs/NodejsStreamOutputAdapter");
        } catch {
        }
      function u(E, p) {
        return new h.Promise(function(I, m) {
          var C = [], R = E._internalType, g = E._outputType, y = E._mimeType;
          E.on("data", function(F, S) {
            C.push(F), p && p(S);
          }).on("error", function(F) {
            C = [], m(F);
          }).on("end", function() {
            try {
              var F = function(S, L, N) {
                switch (S) {
                  case "blob":
                    return n.newBlob(n.transformTo("arraybuffer", L), N);
                  case "base64":
                    return a.encode(L);
                  default:
                    return n.transformTo(S, L);
                }
              }(g, function(S, L) {
                var N, x = 0, k = null, w = 0;
                for (N = 0; N < L.length; N++)
                  w += L[N].length;
                switch (S) {
                  case "string":
                    return L.join("");
                  case "array":
                    return Array.prototype.concat.apply([], L);
                  case "uint8array":
                    for (k = new Uint8Array(w), N = 0; N < L.length; N++)
                      k.set(L[N], x), x += L[N].length;
                    return k;
                  case "nodebuffer":
                    return Buffer.concat(L);
                  default:
                    throw new Error("concat : unsupported type '" + S + "'");
                }
              }(R, C), y);
              I(F);
            } catch (S) {
              m(S);
            }
            C = [];
          }).resume();
        });
      }
      function f(E, p, I) {
        var m = p;
        switch (p) {
          case "blob":
          case "arraybuffer":
            m = "uint8array";
            break;
          case "base64":
            m = "string";
        }
        try {
          this._internalType = m, this._outputType = p, this._mimeType = I, n.checkSupport(m), this._worker = E.pipe(new r(m)), E.lock();
        } catch (C) {
          this._worker = new o("error"), this._worker.error(C);
        }
      }
      f.prototype = { accumulate: function(E) {
        return u(this, E);
      }, on: function(E, p) {
        var I = this;
        return E === "data" ? this._worker.on(E, function(m) {
          p.call(I, m.data, m.meta);
        }) : this._worker.on(E, function() {
          n.delay(p, arguments, I);
        }), this;
      }, resume: function() {
        return n.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(E) {
        if (n.checkSupport("nodestream"), this._outputType !== "nodebuffer")
          throw new Error(this._outputType + " is not supported by this method");
        return new d(this, { objectMode: this._outputType !== "nodebuffer" }, E);
      } }, e.exports = f;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(t, e, i) {
      if (i.base64 = !0, i.array = !0, i.string = !0, i.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", i.nodebuffer = typeof Buffer < "u", i.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u")
        i.blob = !1;
      else {
        var n = new ArrayBuffer(0);
        try {
          i.blob = new Blob([n], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var r = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            r.append(n), i.blob = r.getBlob("application/zip").size === 0;
          } catch {
            i.blob = !1;
          }
        }
      }
      try {
        i.nodestream = !!t("readable-stream").Readable;
      } catch {
        i.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(t, e, i) {
      for (var n = t("./utils"), r = t("./support"), o = t("./nodejsUtils"), a = t("./stream/GenericWorker"), l = new Array(256), h = 0; h < 256; h++)
        l[h] = 252 <= h ? 6 : 248 <= h ? 5 : 240 <= h ? 4 : 224 <= h ? 3 : 192 <= h ? 2 : 1;
      l[254] = l[254] = 1;
      function d() {
        a.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function u() {
        a.call(this, "utf-8 encode");
      }
      i.utf8encode = function(f) {
        return r.nodebuffer ? o.newBufferFrom(f, "utf-8") : function(E) {
          var p, I, m, C, R, g = E.length, y = 0;
          for (C = 0; C < g; C++)
            (64512 & (I = E.charCodeAt(C))) == 55296 && C + 1 < g && (64512 & (m = E.charCodeAt(C + 1))) == 56320 && (I = 65536 + (I - 55296 << 10) + (m - 56320), C++), y += I < 128 ? 1 : I < 2048 ? 2 : I < 65536 ? 3 : 4;
          for (p = r.uint8array ? new Uint8Array(y) : new Array(y), C = R = 0; R < y; C++)
            (64512 & (I = E.charCodeAt(C))) == 55296 && C + 1 < g && (64512 & (m = E.charCodeAt(C + 1))) == 56320 && (I = 65536 + (I - 55296 << 10) + (m - 56320), C++), I < 128 ? p[R++] = I : (I < 2048 ? p[R++] = 192 | I >>> 6 : (I < 65536 ? p[R++] = 224 | I >>> 12 : (p[R++] = 240 | I >>> 18, p[R++] = 128 | I >>> 12 & 63), p[R++] = 128 | I >>> 6 & 63), p[R++] = 128 | 63 & I);
          return p;
        }(f);
      }, i.utf8decode = function(f) {
        return r.nodebuffer ? n.transformTo("nodebuffer", f).toString("utf-8") : function(E) {
          var p, I, m, C, R = E.length, g = new Array(2 * R);
          for (p = I = 0; p < R; )
            if ((m = E[p++]) < 128)
              g[I++] = m;
            else if (4 < (C = l[m]))
              g[I++] = 65533, p += C - 1;
            else {
              for (m &= C === 2 ? 31 : C === 3 ? 15 : 7; 1 < C && p < R; )
                m = m << 6 | 63 & E[p++], C--;
              1 < C ? g[I++] = 65533 : m < 65536 ? g[I++] = m : (m -= 65536, g[I++] = 55296 | m >> 10 & 1023, g[I++] = 56320 | 1023 & m);
            }
          return g.length !== I && (g.subarray ? g = g.subarray(0, I) : g.length = I), n.applyFromCharCode(g);
        }(f = n.transformTo(r.uint8array ? "uint8array" : "array", f));
      }, n.inherits(d, a), d.prototype.processChunk = function(f) {
        var E = n.transformTo(r.uint8array ? "uint8array" : "array", f.data);
        if (this.leftOver && this.leftOver.length) {
          if (r.uint8array) {
            var p = E;
            (E = new Uint8Array(p.length + this.leftOver.length)).set(this.leftOver, 0), E.set(p, this.leftOver.length);
          } else
            E = this.leftOver.concat(E);
          this.leftOver = null;
        }
        var I = function(C, R) {
          var g;
          for ((R = R || C.length) > C.length && (R = C.length), g = R - 1; 0 <= g && (192 & C[g]) == 128; )
            g--;
          return g < 0 || g === 0 ? R : g + l[C[g]] > R ? g : R;
        }(E), m = E;
        I !== E.length && (r.uint8array ? (m = E.subarray(0, I), this.leftOver = E.subarray(I, E.length)) : (m = E.slice(0, I), this.leftOver = E.slice(I, E.length))), this.push({ data: i.utf8decode(m), meta: f.meta });
      }, d.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: i.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, i.Utf8DecodeWorker = d, n.inherits(u, a), u.prototype.processChunk = function(f) {
        this.push({ data: i.utf8encode(f.data), meta: f.meta });
      }, i.Utf8EncodeWorker = u;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(t, e, i) {
      var n = t("./support"), r = t("./base64"), o = t("./nodejsUtils"), a = t("./external");
      function l(p) {
        return p;
      }
      function h(p, I) {
        for (var m = 0; m < p.length; ++m)
          I[m] = 255 & p.charCodeAt(m);
        return I;
      }
      t("setimmediate"), i.newBlob = function(p, I) {
        i.checkSupport("blob");
        try {
          return new Blob([p], { type: I });
        } catch {
          try {
            var m = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return m.append(p), m.getBlob(I);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var d = { stringifyByChunk: function(p, I, m) {
        var C = [], R = 0, g = p.length;
        if (g <= m)
          return String.fromCharCode.apply(null, p);
        for (; R < g; )
          I === "array" || I === "nodebuffer" ? C.push(String.fromCharCode.apply(null, p.slice(R, Math.min(R + m, g)))) : C.push(String.fromCharCode.apply(null, p.subarray(R, Math.min(R + m, g)))), R += m;
        return C.join("");
      }, stringifyByChar: function(p) {
        for (var I = "", m = 0; m < p.length; m++)
          I += String.fromCharCode(p[m]);
        return I;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return n.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return n.nodebuffer && String.fromCharCode.apply(null, o.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function u(p) {
        var I = 65536, m = i.getTypeOf(p), C = !0;
        if (m === "uint8array" ? C = d.applyCanBeUsed.uint8array : m === "nodebuffer" && (C = d.applyCanBeUsed.nodebuffer), C)
          for (; 1 < I; )
            try {
              return d.stringifyByChunk(p, m, I);
            } catch {
              I = Math.floor(I / 2);
            }
        return d.stringifyByChar(p);
      }
      function f(p, I) {
        for (var m = 0; m < p.length; m++)
          I[m] = p[m];
        return I;
      }
      i.applyFromCharCode = u;
      var E = {};
      E.string = { string: l, array: function(p) {
        return h(p, new Array(p.length));
      }, arraybuffer: function(p) {
        return E.string.uint8array(p).buffer;
      }, uint8array: function(p) {
        return h(p, new Uint8Array(p.length));
      }, nodebuffer: function(p) {
        return h(p, o.allocBuffer(p.length));
      } }, E.array = { string: u, array: l, arraybuffer: function(p) {
        return new Uint8Array(p).buffer;
      }, uint8array: function(p) {
        return new Uint8Array(p);
      }, nodebuffer: function(p) {
        return o.newBufferFrom(p);
      } }, E.arraybuffer = { string: function(p) {
        return u(new Uint8Array(p));
      }, array: function(p) {
        return f(new Uint8Array(p), new Array(p.byteLength));
      }, arraybuffer: l, uint8array: function(p) {
        return new Uint8Array(p);
      }, nodebuffer: function(p) {
        return o.newBufferFrom(new Uint8Array(p));
      } }, E.uint8array = { string: u, array: function(p) {
        return f(p, new Array(p.length));
      }, arraybuffer: function(p) {
        return p.buffer;
      }, uint8array: l, nodebuffer: function(p) {
        return o.newBufferFrom(p);
      } }, E.nodebuffer = { string: u, array: function(p) {
        return f(p, new Array(p.length));
      }, arraybuffer: function(p) {
        return E.nodebuffer.uint8array(p).buffer;
      }, uint8array: function(p) {
        return f(p, new Uint8Array(p.length));
      }, nodebuffer: l }, i.transformTo = function(p, I) {
        if (I = I || "", !p)
          return I;
        i.checkSupport(p);
        var m = i.getTypeOf(I);
        return E[m][p](I);
      }, i.resolve = function(p) {
        for (var I = p.split("/"), m = [], C = 0; C < I.length; C++) {
          var R = I[C];
          R === "." || R === "" && C !== 0 && C !== I.length - 1 || (R === ".." ? m.pop() : m.push(R));
        }
        return m.join("/");
      }, i.getTypeOf = function(p) {
        return typeof p == "string" ? "string" : Object.prototype.toString.call(p) === "[object Array]" ? "array" : n.nodebuffer && o.isBuffer(p) ? "nodebuffer" : n.uint8array && p instanceof Uint8Array ? "uint8array" : n.arraybuffer && p instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, i.checkSupport = function(p) {
        if (!n[p.toLowerCase()])
          throw new Error(p + " is not supported by this platform");
      }, i.MAX_VALUE_16BITS = 65535, i.MAX_VALUE_32BITS = -1, i.pretty = function(p) {
        var I, m, C = "";
        for (m = 0; m < (p || "").length; m++)
          C += "\\x" + ((I = p.charCodeAt(m)) < 16 ? "0" : "") + I.toString(16).toUpperCase();
        return C;
      }, i.delay = function(p, I, m) {
        setImmediate(function() {
          p.apply(m || null, I || []);
        });
      }, i.inherits = function(p, I) {
        function m() {
        }
        m.prototype = I.prototype, p.prototype = new m();
      }, i.extend = function() {
        var p, I, m = {};
        for (p = 0; p < arguments.length; p++)
          for (I in arguments[p])
            Object.prototype.hasOwnProperty.call(arguments[p], I) && m[I] === void 0 && (m[I] = arguments[p][I]);
        return m;
      }, i.prepareContent = function(p, I, m, C, R) {
        return a.Promise.resolve(I).then(function(g) {
          return n.blob && (g instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(g)) !== -1) && typeof FileReader < "u" ? new a.Promise(function(y, F) {
            var S = new FileReader();
            S.onload = function(L) {
              y(L.target.result);
            }, S.onerror = function(L) {
              F(L.target.error);
            }, S.readAsArrayBuffer(g);
          }) : g;
        }).then(function(g) {
          var y = i.getTypeOf(g);
          return y ? (y === "arraybuffer" ? g = i.transformTo("uint8array", g) : y === "string" && (R ? g = r.decode(g) : m && C !== !0 && (g = function(F) {
            return h(F, n.uint8array ? new Uint8Array(F.length) : new Array(F.length));
          }(g))), g) : a.Promise.reject(new Error("Can't read the data of '" + p + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(t, e, i) {
      var n = t("./reader/readerFor"), r = t("./utils"), o = t("./signature"), a = t("./zipEntry"), l = t("./support");
      function h(d) {
        this.files = [], this.loadOptions = d;
      }
      h.prototype = { checkSignature: function(d) {
        if (!this.reader.readAndCheckSignature(d)) {
          this.reader.index -= 4;
          var u = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + r.pretty(u) + ", expected " + r.pretty(d) + ")");
        }
      }, isSignature: function(d, u) {
        var f = this.reader.index;
        this.reader.setIndex(d);
        var E = this.reader.readString(4) === u;
        return this.reader.setIndex(f), E;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var d = this.reader.readData(this.zipCommentLength), u = l.uint8array ? "uint8array" : "array", f = r.transformTo(u, d);
        this.zipComment = this.loadOptions.decodeFileName(f);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var d, u, f, E = this.zip64EndOfCentralSize - 44; 0 < E; )
          d = this.reader.readInt(2), u = this.reader.readInt(4), f = this.reader.readData(u), this.zip64ExtensibleData[d] = { id: d, length: u, value: f };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var d, u;
        for (d = 0; d < this.files.length; d++)
          u = this.files[d], this.reader.setIndex(u.localHeaderOffset), this.checkSignature(o.LOCAL_FILE_HEADER), u.readLocalPart(this.reader), u.handleUTF8(), u.processAttributes();
      }, readCentralDir: function() {
        var d;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(o.CENTRAL_FILE_HEADER); )
          (d = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(d);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var d = this.reader.lastIndexOfSignature(o.CENTRAL_DIRECTORY_END);
        if (d < 0)
          throw this.isSignature(0, o.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(d);
        var u = d;
        if (this.checkSignature(o.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === r.MAX_VALUE_16BITS || this.diskWithCentralDirStart === r.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === r.MAX_VALUE_16BITS || this.centralDirRecords === r.MAX_VALUE_16BITS || this.centralDirSize === r.MAX_VALUE_32BITS || this.centralDirOffset === r.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (d = this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(d), this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, o.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(o.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(o.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var f = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (f += 20, f += 12 + this.zip64EndOfCentralSize);
        var E = u - f;
        if (0 < E)
          this.isSignature(u, o.CENTRAL_FILE_HEADER) || (this.reader.zero = E);
        else if (E < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(E) + " bytes.");
      }, prepareReader: function(d) {
        this.reader = n(d);
      }, load: function(d) {
        this.prepareReader(d), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, e.exports = h;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(t, e, i) {
      var n = t("./reader/readerFor"), r = t("./utils"), o = t("./compressedObject"), a = t("./crc32"), l = t("./utf8"), h = t("./compressions"), d = t("./support");
      function u(f, E) {
        this.options = f, this.loadOptions = E;
      }
      u.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(f) {
        var E, p;
        if (f.skip(22), this.fileNameLength = f.readInt(2), p = f.readInt(2), this.fileName = f.readData(this.fileNameLength), f.skip(p), this.compressedSize === -1 || this.uncompressedSize === -1)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((E = function(I) {
          for (var m in h)
            if (Object.prototype.hasOwnProperty.call(h, m) && h[m].magic === I)
              return h[m];
          return null;
        }(this.compressionMethod)) === null)
          throw new Error("Corrupted zip : compression " + r.pretty(this.compressionMethod) + " unknown (inner file : " + r.transformTo("string", this.fileName) + ")");
        this.decompressed = new o(this.compressedSize, this.uncompressedSize, this.crc32, E, f.readData(this.compressedSize));
      }, readCentralPart: function(f) {
        this.versionMadeBy = f.readInt(2), f.skip(2), this.bitFlag = f.readInt(2), this.compressionMethod = f.readString(2), this.date = f.readDate(), this.crc32 = f.readInt(4), this.compressedSize = f.readInt(4), this.uncompressedSize = f.readInt(4);
        var E = f.readInt(2);
        if (this.extraFieldsLength = f.readInt(2), this.fileCommentLength = f.readInt(2), this.diskNumberStart = f.readInt(2), this.internalFileAttributes = f.readInt(2), this.externalFileAttributes = f.readInt(4), this.localHeaderOffset = f.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        f.skip(E), this.readExtraFields(f), this.parseZIP64ExtraField(f), this.fileComment = f.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var f = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), f == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), f == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var f = n(this.extraFields[1].value);
          this.uncompressedSize === r.MAX_VALUE_32BITS && (this.uncompressedSize = f.readInt(8)), this.compressedSize === r.MAX_VALUE_32BITS && (this.compressedSize = f.readInt(8)), this.localHeaderOffset === r.MAX_VALUE_32BITS && (this.localHeaderOffset = f.readInt(8)), this.diskNumberStart === r.MAX_VALUE_32BITS && (this.diskNumberStart = f.readInt(4));
        }
      }, readExtraFields: function(f) {
        var E, p, I, m = f.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); f.index + 4 < m; )
          E = f.readInt(2), p = f.readInt(2), I = f.readData(p), this.extraFields[E] = { id: E, length: p, value: I };
        f.setIndex(m);
      }, handleUTF8: function() {
        var f = d.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = l.utf8decode(this.fileName), this.fileCommentStr = l.utf8decode(this.fileComment);
        else {
          var E = this.findExtraFieldUnicodePath();
          if (E !== null)
            this.fileNameStr = E;
          else {
            var p = r.transformTo(f, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(p);
          }
          var I = this.findExtraFieldUnicodeComment();
          if (I !== null)
            this.fileCommentStr = I;
          else {
            var m = r.transformTo(f, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(m);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var f = this.extraFields[28789];
        if (f) {
          var E = n(f.value);
          return E.readInt(1) !== 1 || a(this.fileName) !== E.readInt(4) ? null : l.utf8decode(E.readData(f.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var f = this.extraFields[25461];
        if (f) {
          var E = n(f.value);
          return E.readInt(1) !== 1 || a(this.fileComment) !== E.readInt(4) ? null : l.utf8decode(E.readData(f.length - 5));
        }
        return null;
      } }, e.exports = u;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(t, e, i) {
      function n(E, p, I) {
        this.name = E, this.dir = I.dir, this.date = I.date, this.comment = I.comment, this.unixPermissions = I.unixPermissions, this.dosPermissions = I.dosPermissions, this._data = p, this._dataBinary = I.binary, this.options = { compression: I.compression, compressionOptions: I.compressionOptions };
      }
      var r = t("./stream/StreamHelper"), o = t("./stream/DataWorker"), a = t("./utf8"), l = t("./compressedObject"), h = t("./stream/GenericWorker");
      n.prototype = { internalStream: function(E) {
        var p = null, I = "string";
        try {
          if (!E)
            throw new Error("No output type specified.");
          var m = (I = E.toLowerCase()) === "string" || I === "text";
          I !== "binarystring" && I !== "text" || (I = "string"), p = this._decompressWorker();
          var C = !this._dataBinary;
          C && !m && (p = p.pipe(new a.Utf8EncodeWorker())), !C && m && (p = p.pipe(new a.Utf8DecodeWorker()));
        } catch (R) {
          (p = new h("error")).error(R);
        }
        return new r(p, I, "");
      }, async: function(E, p) {
        return this.internalStream(E).accumulate(p);
      }, nodeStream: function(E, p) {
        return this.internalStream(E || "nodebuffer").toNodejsStream(p);
      }, _compressWorker: function(E, p) {
        if (this._data instanceof l && this._data.compression.magic === E.magic)
          return this._data.getCompressedWorker();
        var I = this._decompressWorker();
        return this._dataBinary || (I = I.pipe(new a.Utf8EncodeWorker())), l.createWorkerFrom(I, E, p);
      }, _decompressWorker: function() {
        return this._data instanceof l ? this._data.getContentWorker() : this._data instanceof h ? this._data : new o(this._data);
      } };
      for (var d = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], u = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, f = 0; f < d.length; f++)
        n.prototype[d[f]] = u;
      e.exports = n;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(t, e, i) {
      (function(n) {
        var r, o, a = n.MutationObserver || n.WebKitMutationObserver;
        if (a) {
          var l = 0, h = new a(E), d = n.document.createTextNode("");
          h.observe(d, { characterData: !0 }), r = function() {
            d.data = l = ++l % 2;
          };
        } else if (n.setImmediate || n.MessageChannel === void 0)
          r = "document" in n && "onreadystatechange" in n.document.createElement("script") ? function() {
            var p = n.document.createElement("script");
            p.onreadystatechange = function() {
              E(), p.onreadystatechange = null, p.parentNode.removeChild(p), p = null;
            }, n.document.documentElement.appendChild(p);
          } : function() {
            setTimeout(E, 0);
          };
        else {
          var u = new n.MessageChannel();
          u.port1.onmessage = E, r = function() {
            u.port2.postMessage(0);
          };
        }
        var f = [];
        function E() {
          var p, I;
          o = !0;
          for (var m = f.length; m; ) {
            for (I = f, f = [], p = -1; ++p < m; )
              I[p]();
            m = f.length;
          }
          o = !1;
        }
        e.exports = function(p) {
          f.push(p) !== 1 || o || r();
        };
      }).call(this, typeof ii < "u" ? ii : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(t, e, i) {
      var n = t("immediate");
      function r() {
      }
      var o = {}, a = ["REJECTED"], l = ["FULFILLED"], h = ["PENDING"];
      function d(m) {
        if (typeof m != "function")
          throw new TypeError("resolver must be a function");
        this.state = h, this.queue = [], this.outcome = void 0, m !== r && p(this, m);
      }
      function u(m, C, R) {
        this.promise = m, typeof C == "function" && (this.onFulfilled = C, this.callFulfilled = this.otherCallFulfilled), typeof R == "function" && (this.onRejected = R, this.callRejected = this.otherCallRejected);
      }
      function f(m, C, R) {
        n(function() {
          var g;
          try {
            g = C(R);
          } catch (y) {
            return o.reject(m, y);
          }
          g === m ? o.reject(m, new TypeError("Cannot resolve promise with itself")) : o.resolve(m, g);
        });
      }
      function E(m) {
        var C = m && m.then;
        if (m && (typeof m == "object" || typeof m == "function") && typeof C == "function")
          return function() {
            C.apply(m, arguments);
          };
      }
      function p(m, C) {
        var R = !1;
        function g(S) {
          R || (R = !0, o.reject(m, S));
        }
        function y(S) {
          R || (R = !0, o.resolve(m, S));
        }
        var F = I(function() {
          C(y, g);
        });
        F.status === "error" && g(F.value);
      }
      function I(m, C) {
        var R = {};
        try {
          R.value = m(C), R.status = "success";
        } catch (g) {
          R.status = "error", R.value = g;
        }
        return R;
      }
      (e.exports = d).prototype.finally = function(m) {
        if (typeof m != "function")
          return this;
        var C = this.constructor;
        return this.then(function(R) {
          return C.resolve(m()).then(function() {
            return R;
          });
        }, function(R) {
          return C.resolve(m()).then(function() {
            throw R;
          });
        });
      }, d.prototype.catch = function(m) {
        return this.then(null, m);
      }, d.prototype.then = function(m, C) {
        if (typeof m != "function" && this.state === l || typeof C != "function" && this.state === a)
          return this;
        var R = new this.constructor(r);
        return this.state !== h ? f(R, this.state === l ? m : C, this.outcome) : this.queue.push(new u(R, m, C)), R;
      }, u.prototype.callFulfilled = function(m) {
        o.resolve(this.promise, m);
      }, u.prototype.otherCallFulfilled = function(m) {
        f(this.promise, this.onFulfilled, m);
      }, u.prototype.callRejected = function(m) {
        o.reject(this.promise, m);
      }, u.prototype.otherCallRejected = function(m) {
        f(this.promise, this.onRejected, m);
      }, o.resolve = function(m, C) {
        var R = I(E, C);
        if (R.status === "error")
          return o.reject(m, R.value);
        var g = R.value;
        if (g)
          p(m, g);
        else {
          m.state = l, m.outcome = C;
          for (var y = -1, F = m.queue.length; ++y < F; )
            m.queue[y].callFulfilled(C);
        }
        return m;
      }, o.reject = function(m, C) {
        m.state = a, m.outcome = C;
        for (var R = -1, g = m.queue.length; ++R < g; )
          m.queue[R].callRejected(C);
        return m;
      }, d.resolve = function(m) {
        return m instanceof this ? m : o.resolve(new this(r), m);
      }, d.reject = function(m) {
        var C = new this(r);
        return o.reject(C, m);
      }, d.all = function(m) {
        var C = this;
        if (Object.prototype.toString.call(m) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var R = m.length, g = !1;
        if (!R)
          return this.resolve([]);
        for (var y = new Array(R), F = 0, S = -1, L = new this(r); ++S < R; )
          N(m[S], S);
        return L;
        function N(x, k) {
          C.resolve(x).then(function(w) {
            y[k] = w, ++F !== R || g || (g = !0, o.resolve(L, y));
          }, function(w) {
            g || (g = !0, o.reject(L, w));
          });
        }
      }, d.race = function(m) {
        var C = this;
        if (Object.prototype.toString.call(m) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var R = m.length, g = !1;
        if (!R)
          return this.resolve([]);
        for (var y = -1, F = new this(r); ++y < R; )
          S = m[y], C.resolve(S).then(function(L) {
            g || (g = !0, o.resolve(F, L));
          }, function(L) {
            g || (g = !0, o.reject(F, L));
          });
        var S;
        return F;
      };
    }, { immediate: 36 }], 38: [function(t, e, i) {
      var n = {};
      (0, t("./lib/utils/common").assign)(n, t("./lib/deflate"), t("./lib/inflate"), t("./lib/zlib/constants")), e.exports = n;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(t, e, i) {
      var n = t("./zlib/deflate"), r = t("./utils/common"), o = t("./utils/strings"), a = t("./zlib/messages"), l = t("./zlib/zstream"), h = Object.prototype.toString, d = 0, u = -1, f = 0, E = 8;
      function p(m) {
        if (!(this instanceof p))
          return new p(m);
        this.options = r.assign({ level: u, method: E, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: f, to: "" }, m || {});
        var C = this.options;
        C.raw && 0 < C.windowBits ? C.windowBits = -C.windowBits : C.gzip && 0 < C.windowBits && C.windowBits < 16 && (C.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new l(), this.strm.avail_out = 0;
        var R = n.deflateInit2(this.strm, C.level, C.method, C.windowBits, C.memLevel, C.strategy);
        if (R !== d)
          throw new Error(a[R]);
        if (C.header && n.deflateSetHeader(this.strm, C.header), C.dictionary) {
          var g;
          if (g = typeof C.dictionary == "string" ? o.string2buf(C.dictionary) : h.call(C.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(C.dictionary) : C.dictionary, (R = n.deflateSetDictionary(this.strm, g)) !== d)
            throw new Error(a[R]);
          this._dict_set = !0;
        }
      }
      function I(m, C) {
        var R = new p(C);
        if (R.push(m, !0), R.err)
          throw R.msg || a[R.err];
        return R.result;
      }
      p.prototype.push = function(m, C) {
        var R, g, y = this.strm, F = this.options.chunkSize;
        if (this.ended)
          return !1;
        g = C === ~~C ? C : C === !0 ? 4 : 0, typeof m == "string" ? y.input = o.string2buf(m) : h.call(m) === "[object ArrayBuffer]" ? y.input = new Uint8Array(m) : y.input = m, y.next_in = 0, y.avail_in = y.input.length;
        do {
          if (y.avail_out === 0 && (y.output = new r.Buf8(F), y.next_out = 0, y.avail_out = F), (R = n.deflate(y, g)) !== 1 && R !== d)
            return this.onEnd(R), !(this.ended = !0);
          y.avail_out !== 0 && (y.avail_in !== 0 || g !== 4 && g !== 2) || (this.options.to === "string" ? this.onData(o.buf2binstring(r.shrinkBuf(y.output, y.next_out))) : this.onData(r.shrinkBuf(y.output, y.next_out)));
        } while ((0 < y.avail_in || y.avail_out === 0) && R !== 1);
        return g === 4 ? (R = n.deflateEnd(this.strm), this.onEnd(R), this.ended = !0, R === d) : g !== 2 || (this.onEnd(d), !(y.avail_out = 0));
      }, p.prototype.onData = function(m) {
        this.chunks.push(m);
      }, p.prototype.onEnd = function(m) {
        m === d && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = r.flattenChunks(this.chunks)), this.chunks = [], this.err = m, this.msg = this.strm.msg;
      }, i.Deflate = p, i.deflate = I, i.deflateRaw = function(m, C) {
        return (C = C || {}).raw = !0, I(m, C);
      }, i.gzip = function(m, C) {
        return (C = C || {}).gzip = !0, I(m, C);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(t, e, i) {
      var n = t("./zlib/inflate"), r = t("./utils/common"), o = t("./utils/strings"), a = t("./zlib/constants"), l = t("./zlib/messages"), h = t("./zlib/zstream"), d = t("./zlib/gzheader"), u = Object.prototype.toString;
      function f(p) {
        if (!(this instanceof f))
          return new f(p);
        this.options = r.assign({ chunkSize: 16384, windowBits: 0, to: "" }, p || {});
        var I = this.options;
        I.raw && 0 <= I.windowBits && I.windowBits < 16 && (I.windowBits = -I.windowBits, I.windowBits === 0 && (I.windowBits = -15)), !(0 <= I.windowBits && I.windowBits < 16) || p && p.windowBits || (I.windowBits += 32), 15 < I.windowBits && I.windowBits < 48 && !(15 & I.windowBits) && (I.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new h(), this.strm.avail_out = 0;
        var m = n.inflateInit2(this.strm, I.windowBits);
        if (m !== a.Z_OK)
          throw new Error(l[m]);
        this.header = new d(), n.inflateGetHeader(this.strm, this.header);
      }
      function E(p, I) {
        var m = new f(I);
        if (m.push(p, !0), m.err)
          throw m.msg || l[m.err];
        return m.result;
      }
      f.prototype.push = function(p, I) {
        var m, C, R, g, y, F, S = this.strm, L = this.options.chunkSize, N = this.options.dictionary, x = !1;
        if (this.ended)
          return !1;
        C = I === ~~I ? I : I === !0 ? a.Z_FINISH : a.Z_NO_FLUSH, typeof p == "string" ? S.input = o.binstring2buf(p) : u.call(p) === "[object ArrayBuffer]" ? S.input = new Uint8Array(p) : S.input = p, S.next_in = 0, S.avail_in = S.input.length;
        do {
          if (S.avail_out === 0 && (S.output = new r.Buf8(L), S.next_out = 0, S.avail_out = L), (m = n.inflate(S, a.Z_NO_FLUSH)) === a.Z_NEED_DICT && N && (F = typeof N == "string" ? o.string2buf(N) : u.call(N) === "[object ArrayBuffer]" ? new Uint8Array(N) : N, m = n.inflateSetDictionary(this.strm, F)), m === a.Z_BUF_ERROR && x === !0 && (m = a.Z_OK, x = !1), m !== a.Z_STREAM_END && m !== a.Z_OK)
            return this.onEnd(m), !(this.ended = !0);
          S.next_out && (S.avail_out !== 0 && m !== a.Z_STREAM_END && (S.avail_in !== 0 || C !== a.Z_FINISH && C !== a.Z_SYNC_FLUSH) || (this.options.to === "string" ? (R = o.utf8border(S.output, S.next_out), g = S.next_out - R, y = o.buf2string(S.output, R), S.next_out = g, S.avail_out = L - g, g && r.arraySet(S.output, S.output, R, g, 0), this.onData(y)) : this.onData(r.shrinkBuf(S.output, S.next_out)))), S.avail_in === 0 && S.avail_out === 0 && (x = !0);
        } while ((0 < S.avail_in || S.avail_out === 0) && m !== a.Z_STREAM_END);
        return m === a.Z_STREAM_END && (C = a.Z_FINISH), C === a.Z_FINISH ? (m = n.inflateEnd(this.strm), this.onEnd(m), this.ended = !0, m === a.Z_OK) : C !== a.Z_SYNC_FLUSH || (this.onEnd(a.Z_OK), !(S.avail_out = 0));
      }, f.prototype.onData = function(p) {
        this.chunks.push(p);
      }, f.prototype.onEnd = function(p) {
        p === a.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = r.flattenChunks(this.chunks)), this.chunks = [], this.err = p, this.msg = this.strm.msg;
      }, i.Inflate = f, i.inflate = E, i.inflateRaw = function(p, I) {
        return (I = I || {}).raw = !0, E(p, I);
      }, i.ungzip = E;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(t, e, i) {
      var n = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      i.assign = function(a) {
        for (var l = Array.prototype.slice.call(arguments, 1); l.length; ) {
          var h = l.shift();
          if (h) {
            if (typeof h != "object")
              throw new TypeError(h + "must be non-object");
            for (var d in h)
              h.hasOwnProperty(d) && (a[d] = h[d]);
          }
        }
        return a;
      }, i.shrinkBuf = function(a, l) {
        return a.length === l ? a : a.subarray ? a.subarray(0, l) : (a.length = l, a);
      };
      var r = { arraySet: function(a, l, h, d, u) {
        if (l.subarray && a.subarray)
          a.set(l.subarray(h, h + d), u);
        else
          for (var f = 0; f < d; f++)
            a[u + f] = l[h + f];
      }, flattenChunks: function(a) {
        var l, h, d, u, f, E;
        for (l = d = 0, h = a.length; l < h; l++)
          d += a[l].length;
        for (E = new Uint8Array(d), l = u = 0, h = a.length; l < h; l++)
          f = a[l], E.set(f, u), u += f.length;
        return E;
      } }, o = { arraySet: function(a, l, h, d, u) {
        for (var f = 0; f < d; f++)
          a[u + f] = l[h + f];
      }, flattenChunks: function(a) {
        return [].concat.apply([], a);
      } };
      i.setTyped = function(a) {
        a ? (i.Buf8 = Uint8Array, i.Buf16 = Uint16Array, i.Buf32 = Int32Array, i.assign(i, r)) : (i.Buf8 = Array, i.Buf16 = Array, i.Buf32 = Array, i.assign(i, o));
      }, i.setTyped(n);
    }, {}], 42: [function(t, e, i) {
      var n = t("./common"), r = !0, o = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        r = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        o = !1;
      }
      for (var a = new n.Buf8(256), l = 0; l < 256; l++)
        a[l] = 252 <= l ? 6 : 248 <= l ? 5 : 240 <= l ? 4 : 224 <= l ? 3 : 192 <= l ? 2 : 1;
      function h(d, u) {
        if (u < 65537 && (d.subarray && o || !d.subarray && r))
          return String.fromCharCode.apply(null, n.shrinkBuf(d, u));
        for (var f = "", E = 0; E < u; E++)
          f += String.fromCharCode(d[E]);
        return f;
      }
      a[254] = a[254] = 1, i.string2buf = function(d) {
        var u, f, E, p, I, m = d.length, C = 0;
        for (p = 0; p < m; p++)
          (64512 & (f = d.charCodeAt(p))) == 55296 && p + 1 < m && (64512 & (E = d.charCodeAt(p + 1))) == 56320 && (f = 65536 + (f - 55296 << 10) + (E - 56320), p++), C += f < 128 ? 1 : f < 2048 ? 2 : f < 65536 ? 3 : 4;
        for (u = new n.Buf8(C), p = I = 0; I < C; p++)
          (64512 & (f = d.charCodeAt(p))) == 55296 && p + 1 < m && (64512 & (E = d.charCodeAt(p + 1))) == 56320 && (f = 65536 + (f - 55296 << 10) + (E - 56320), p++), f < 128 ? u[I++] = f : (f < 2048 ? u[I++] = 192 | f >>> 6 : (f < 65536 ? u[I++] = 224 | f >>> 12 : (u[I++] = 240 | f >>> 18, u[I++] = 128 | f >>> 12 & 63), u[I++] = 128 | f >>> 6 & 63), u[I++] = 128 | 63 & f);
        return u;
      }, i.buf2binstring = function(d) {
        return h(d, d.length);
      }, i.binstring2buf = function(d) {
        for (var u = new n.Buf8(d.length), f = 0, E = u.length; f < E; f++)
          u[f] = d.charCodeAt(f);
        return u;
      }, i.buf2string = function(d, u) {
        var f, E, p, I, m = u || d.length, C = new Array(2 * m);
        for (f = E = 0; f < m; )
          if ((p = d[f++]) < 128)
            C[E++] = p;
          else if (4 < (I = a[p]))
            C[E++] = 65533, f += I - 1;
          else {
            for (p &= I === 2 ? 31 : I === 3 ? 15 : 7; 1 < I && f < m; )
              p = p << 6 | 63 & d[f++], I--;
            1 < I ? C[E++] = 65533 : p < 65536 ? C[E++] = p : (p -= 65536, C[E++] = 55296 | p >> 10 & 1023, C[E++] = 56320 | 1023 & p);
          }
        return h(C, E);
      }, i.utf8border = function(d, u) {
        var f;
        for ((u = u || d.length) > d.length && (u = d.length), f = u - 1; 0 <= f && (192 & d[f]) == 128; )
          f--;
        return f < 0 || f === 0 ? u : f + a[d[f]] > u ? f : u;
      };
    }, { "./common": 41 }], 43: [function(t, e, i) {
      e.exports = function(n, r, o, a) {
        for (var l = 65535 & n | 0, h = n >>> 16 & 65535 | 0, d = 0; o !== 0; ) {
          for (o -= d = 2e3 < o ? 2e3 : o; h = h + (l = l + r[a++] | 0) | 0, --d; )
            ;
          l %= 65521, h %= 65521;
        }
        return l | h << 16 | 0;
      };
    }, {}], 44: [function(t, e, i) {
      e.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(t, e, i) {
      var n = function() {
        for (var r, o = [], a = 0; a < 256; a++) {
          r = a;
          for (var l = 0; l < 8; l++)
            r = 1 & r ? 3988292384 ^ r >>> 1 : r >>> 1;
          o[a] = r;
        }
        return o;
      }();
      e.exports = function(r, o, a, l) {
        var h = n, d = l + a;
        r ^= -1;
        for (var u = l; u < d; u++)
          r = r >>> 8 ^ h[255 & (r ^ o[u])];
        return -1 ^ r;
      };
    }, {}], 46: [function(t, e, i) {
      var n, r = t("../utils/common"), o = t("./trees"), a = t("./adler32"), l = t("./crc32"), h = t("./messages"), d = 0, u = 4, f = 0, E = -2, p = -1, I = 4, m = 2, C = 8, R = 9, g = 286, y = 30, F = 19, S = 2 * g + 1, L = 15, N = 3, x = 258, k = x + N + 1, w = 42, P = 113, _ = 1, v = 2, Q = 3, V = 4;
      function et(A, W) {
        return A.msg = h[W], W;
      }
      function H(A) {
        return (A << 1) - (4 < A ? 9 : 0);
      }
      function nt(A) {
        for (var W = A.length; 0 <= --W; )
          A[W] = 0;
      }
      function z(A) {
        var W = A.state, Y = W.pending;
        Y > A.avail_out && (Y = A.avail_out), Y !== 0 && (r.arraySet(A.output, W.pending_buf, W.pending_out, Y, A.next_out), A.next_out += Y, W.pending_out += Y, A.total_out += Y, A.avail_out -= Y, W.pending -= Y, W.pending === 0 && (W.pending_out = 0));
      }
      function U(A, W) {
        o._tr_flush_block(A, 0 <= A.block_start ? A.block_start : -1, A.strstart - A.block_start, W), A.block_start = A.strstart, z(A.strm);
      }
      function ot(A, W) {
        A.pending_buf[A.pending++] = W;
      }
      function st(A, W) {
        A.pending_buf[A.pending++] = W >>> 8 & 255, A.pending_buf[A.pending++] = 255 & W;
      }
      function tt(A, W) {
        var Y, b, O = A.max_chain_length, D = A.strstart, Z = A.prev_length, $ = A.nice_match, B = A.strstart > A.w_size - k ? A.strstart - (A.w_size - k) : 0, K = A.window, it = A.w_mask, J = A.prev, ct = A.strstart + x, Ct = K[D + Z - 1], pt = K[D + Z];
        A.prev_length >= A.good_match && (O >>= 2), $ > A.lookahead && ($ = A.lookahead);
        do
          if (K[(Y = W) + Z] === pt && K[Y + Z - 1] === Ct && K[Y] === K[D] && K[++Y] === K[D + 1]) {
            D += 2, Y++;
            do
              ;
            while (K[++D] === K[++Y] && K[++D] === K[++Y] && K[++D] === K[++Y] && K[++D] === K[++Y] && K[++D] === K[++Y] && K[++D] === K[++Y] && K[++D] === K[++Y] && K[++D] === K[++Y] && D < ct);
            if (b = x - (ct - D), D = ct - x, Z < b) {
              if (A.match_start = W, $ <= (Z = b))
                break;
              Ct = K[D + Z - 1], pt = K[D + Z];
            }
          }
        while ((W = J[W & it]) > B && --O != 0);
        return Z <= A.lookahead ? Z : A.lookahead;
      }
      function Rt(A) {
        var W, Y, b, O, D, Z, $, B, K, it, J = A.w_size;
        do {
          if (O = A.window_size - A.lookahead - A.strstart, A.strstart >= J + (J - k)) {
            for (r.arraySet(A.window, A.window, J, J, 0), A.match_start -= J, A.strstart -= J, A.block_start -= J, W = Y = A.hash_size; b = A.head[--W], A.head[W] = J <= b ? b - J : 0, --Y; )
              ;
            for (W = Y = J; b = A.prev[--W], A.prev[W] = J <= b ? b - J : 0, --Y; )
              ;
            O += J;
          }
          if (A.strm.avail_in === 0)
            break;
          if (Z = A.strm, $ = A.window, B = A.strstart + A.lookahead, K = O, it = void 0, it = Z.avail_in, K < it && (it = K), Y = it === 0 ? 0 : (Z.avail_in -= it, r.arraySet($, Z.input, Z.next_in, it, B), Z.state.wrap === 1 ? Z.adler = a(Z.adler, $, it, B) : Z.state.wrap === 2 && (Z.adler = l(Z.adler, $, it, B)), Z.next_in += it, Z.total_in += it, it), A.lookahead += Y, A.lookahead + A.insert >= N)
            for (D = A.strstart - A.insert, A.ins_h = A.window[D], A.ins_h = (A.ins_h << A.hash_shift ^ A.window[D + 1]) & A.hash_mask; A.insert && (A.ins_h = (A.ins_h << A.hash_shift ^ A.window[D + N - 1]) & A.hash_mask, A.prev[D & A.w_mask] = A.head[A.ins_h], A.head[A.ins_h] = D, D++, A.insert--, !(A.lookahead + A.insert < N)); )
              ;
        } while (A.lookahead < k && A.strm.avail_in !== 0);
      }
      function Ft(A, W) {
        for (var Y, b; ; ) {
          if (A.lookahead < k) {
            if (Rt(A), A.lookahead < k && W === d)
              return _;
            if (A.lookahead === 0)
              break;
          }
          if (Y = 0, A.lookahead >= N && (A.ins_h = (A.ins_h << A.hash_shift ^ A.window[A.strstart + N - 1]) & A.hash_mask, Y = A.prev[A.strstart & A.w_mask] = A.head[A.ins_h], A.head[A.ins_h] = A.strstart), Y !== 0 && A.strstart - Y <= A.w_size - k && (A.match_length = tt(A, Y)), A.match_length >= N)
            if (b = o._tr_tally(A, A.strstart - A.match_start, A.match_length - N), A.lookahead -= A.match_length, A.match_length <= A.max_lazy_match && A.lookahead >= N) {
              for (A.match_length--; A.strstart++, A.ins_h = (A.ins_h << A.hash_shift ^ A.window[A.strstart + N - 1]) & A.hash_mask, Y = A.prev[A.strstart & A.w_mask] = A.head[A.ins_h], A.head[A.ins_h] = A.strstart, --A.match_length != 0; )
                ;
              A.strstart++;
            } else
              A.strstart += A.match_length, A.match_length = 0, A.ins_h = A.window[A.strstart], A.ins_h = (A.ins_h << A.hash_shift ^ A.window[A.strstart + 1]) & A.hash_mask;
          else
            b = o._tr_tally(A, 0, A.window[A.strstart]), A.lookahead--, A.strstart++;
          if (b && (U(A, !1), A.strm.avail_out === 0))
            return _;
        }
        return A.insert = A.strstart < N - 1 ? A.strstart : N - 1, W === u ? (U(A, !0), A.strm.avail_out === 0 ? Q : V) : A.last_lit && (U(A, !1), A.strm.avail_out === 0) ? _ : v;
      }
      function at(A, W) {
        for (var Y, b, O; ; ) {
          if (A.lookahead < k) {
            if (Rt(A), A.lookahead < k && W === d)
              return _;
            if (A.lookahead === 0)
              break;
          }
          if (Y = 0, A.lookahead >= N && (A.ins_h = (A.ins_h << A.hash_shift ^ A.window[A.strstart + N - 1]) & A.hash_mask, Y = A.prev[A.strstart & A.w_mask] = A.head[A.ins_h], A.head[A.ins_h] = A.strstart), A.prev_length = A.match_length, A.prev_match = A.match_start, A.match_length = N - 1, Y !== 0 && A.prev_length < A.max_lazy_match && A.strstart - Y <= A.w_size - k && (A.match_length = tt(A, Y), A.match_length <= 5 && (A.strategy === 1 || A.match_length === N && 4096 < A.strstart - A.match_start) && (A.match_length = N - 1)), A.prev_length >= N && A.match_length <= A.prev_length) {
            for (O = A.strstart + A.lookahead - N, b = o._tr_tally(A, A.strstart - 1 - A.prev_match, A.prev_length - N), A.lookahead -= A.prev_length - 1, A.prev_length -= 2; ++A.strstart <= O && (A.ins_h = (A.ins_h << A.hash_shift ^ A.window[A.strstart + N - 1]) & A.hash_mask, Y = A.prev[A.strstart & A.w_mask] = A.head[A.ins_h], A.head[A.ins_h] = A.strstart), --A.prev_length != 0; )
              ;
            if (A.match_available = 0, A.match_length = N - 1, A.strstart++, b && (U(A, !1), A.strm.avail_out === 0))
              return _;
          } else if (A.match_available) {
            if ((b = o._tr_tally(A, 0, A.window[A.strstart - 1])) && U(A, !1), A.strstart++, A.lookahead--, A.strm.avail_out === 0)
              return _;
          } else
            A.match_available = 1, A.strstart++, A.lookahead--;
        }
        return A.match_available && (b = o._tr_tally(A, 0, A.window[A.strstart - 1]), A.match_available = 0), A.insert = A.strstart < N - 1 ? A.strstart : N - 1, W === u ? (U(A, !0), A.strm.avail_out === 0 ? Q : V) : A.last_lit && (U(A, !1), A.strm.avail_out === 0) ? _ : v;
      }
      function ft(A, W, Y, b, O) {
        this.good_length = A, this.max_lazy = W, this.nice_length = Y, this.max_chain = b, this.func = O;
      }
      function ut() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = C, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new r.Buf16(2 * S), this.dyn_dtree = new r.Buf16(2 * (2 * y + 1)), this.bl_tree = new r.Buf16(2 * (2 * F + 1)), nt(this.dyn_ltree), nt(this.dyn_dtree), nt(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new r.Buf16(L + 1), this.heap = new r.Buf16(2 * g + 1), nt(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new r.Buf16(2 * g + 1), nt(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function It(A) {
        var W;
        return A && A.state ? (A.total_in = A.total_out = 0, A.data_type = m, (W = A.state).pending = 0, W.pending_out = 0, W.wrap < 0 && (W.wrap = -W.wrap), W.status = W.wrap ? w : P, A.adler = W.wrap === 2 ? 0 : 1, W.last_flush = d, o._tr_init(W), f) : et(A, E);
      }
      function Gt(A) {
        var W = It(A);
        return W === f && function(Y) {
          Y.window_size = 2 * Y.w_size, nt(Y.head), Y.max_lazy_match = n[Y.level].max_lazy, Y.good_match = n[Y.level].good_length, Y.nice_match = n[Y.level].nice_length, Y.max_chain_length = n[Y.level].max_chain, Y.strstart = 0, Y.block_start = 0, Y.lookahead = 0, Y.insert = 0, Y.match_length = Y.prev_length = N - 1, Y.match_available = 0, Y.ins_h = 0;
        }(A.state), W;
      }
      function Mt(A, W, Y, b, O, D) {
        if (!A)
          return E;
        var Z = 1;
        if (W === p && (W = 6), b < 0 ? (Z = 0, b = -b) : 15 < b && (Z = 2, b -= 16), O < 1 || R < O || Y !== C || b < 8 || 15 < b || W < 0 || 9 < W || D < 0 || I < D)
          return et(A, E);
        b === 8 && (b = 9);
        var $ = new ut();
        return (A.state = $).strm = A, $.wrap = Z, $.gzhead = null, $.w_bits = b, $.w_size = 1 << $.w_bits, $.w_mask = $.w_size - 1, $.hash_bits = O + 7, $.hash_size = 1 << $.hash_bits, $.hash_mask = $.hash_size - 1, $.hash_shift = ~~(($.hash_bits + N - 1) / N), $.window = new r.Buf8(2 * $.w_size), $.head = new r.Buf16($.hash_size), $.prev = new r.Buf16($.w_size), $.lit_bufsize = 1 << O + 6, $.pending_buf_size = 4 * $.lit_bufsize, $.pending_buf = new r.Buf8($.pending_buf_size), $.d_buf = 1 * $.lit_bufsize, $.l_buf = 3 * $.lit_bufsize, $.level = W, $.strategy = D, $.method = Y, Gt(A);
      }
      n = [new ft(0, 0, 0, 0, function(A, W) {
        var Y = 65535;
        for (Y > A.pending_buf_size - 5 && (Y = A.pending_buf_size - 5); ; ) {
          if (A.lookahead <= 1) {
            if (Rt(A), A.lookahead === 0 && W === d)
              return _;
            if (A.lookahead === 0)
              break;
          }
          A.strstart += A.lookahead, A.lookahead = 0;
          var b = A.block_start + Y;
          if ((A.strstart === 0 || A.strstart >= b) && (A.lookahead = A.strstart - b, A.strstart = b, U(A, !1), A.strm.avail_out === 0) || A.strstart - A.block_start >= A.w_size - k && (U(A, !1), A.strm.avail_out === 0))
            return _;
        }
        return A.insert = 0, W === u ? (U(A, !0), A.strm.avail_out === 0 ? Q : V) : (A.strstart > A.block_start && (U(A, !1), A.strm.avail_out), _);
      }), new ft(4, 4, 8, 4, Ft), new ft(4, 5, 16, 8, Ft), new ft(4, 6, 32, 32, Ft), new ft(4, 4, 16, 16, at), new ft(8, 16, 32, 32, at), new ft(8, 16, 128, 128, at), new ft(8, 32, 128, 256, at), new ft(32, 128, 258, 1024, at), new ft(32, 258, 258, 4096, at)], i.deflateInit = function(A, W) {
        return Mt(A, W, C, 15, 8, 0);
      }, i.deflateInit2 = Mt, i.deflateReset = Gt, i.deflateResetKeep = It, i.deflateSetHeader = function(A, W) {
        return A && A.state ? A.state.wrap !== 2 ? E : (A.state.gzhead = W, f) : E;
      }, i.deflate = function(A, W) {
        var Y, b, O, D;
        if (!A || !A.state || 5 < W || W < 0)
          return A ? et(A, E) : E;
        if (b = A.state, !A.output || !A.input && A.avail_in !== 0 || b.status === 666 && W !== u)
          return et(A, A.avail_out === 0 ? -5 : E);
        if (b.strm = A, Y = b.last_flush, b.last_flush = W, b.status === w)
          if (b.wrap === 2)
            A.adler = 0, ot(b, 31), ot(b, 139), ot(b, 8), b.gzhead ? (ot(b, (b.gzhead.text ? 1 : 0) + (b.gzhead.hcrc ? 2 : 0) + (b.gzhead.extra ? 4 : 0) + (b.gzhead.name ? 8 : 0) + (b.gzhead.comment ? 16 : 0)), ot(b, 255 & b.gzhead.time), ot(b, b.gzhead.time >> 8 & 255), ot(b, b.gzhead.time >> 16 & 255), ot(b, b.gzhead.time >> 24 & 255), ot(b, b.level === 9 ? 2 : 2 <= b.strategy || b.level < 2 ? 4 : 0), ot(b, 255 & b.gzhead.os), b.gzhead.extra && b.gzhead.extra.length && (ot(b, 255 & b.gzhead.extra.length), ot(b, b.gzhead.extra.length >> 8 & 255)), b.gzhead.hcrc && (A.adler = l(A.adler, b.pending_buf, b.pending, 0)), b.gzindex = 0, b.status = 69) : (ot(b, 0), ot(b, 0), ot(b, 0), ot(b, 0), ot(b, 0), ot(b, b.level === 9 ? 2 : 2 <= b.strategy || b.level < 2 ? 4 : 0), ot(b, 3), b.status = P);
          else {
            var Z = C + (b.w_bits - 8 << 4) << 8;
            Z |= (2 <= b.strategy || b.level < 2 ? 0 : b.level < 6 ? 1 : b.level === 6 ? 2 : 3) << 6, b.strstart !== 0 && (Z |= 32), Z += 31 - Z % 31, b.status = P, st(b, Z), b.strstart !== 0 && (st(b, A.adler >>> 16), st(b, 65535 & A.adler)), A.adler = 1;
          }
        if (b.status === 69)
          if (b.gzhead.extra) {
            for (O = b.pending; b.gzindex < (65535 & b.gzhead.extra.length) && (b.pending !== b.pending_buf_size || (b.gzhead.hcrc && b.pending > O && (A.adler = l(A.adler, b.pending_buf, b.pending - O, O)), z(A), O = b.pending, b.pending !== b.pending_buf_size)); )
              ot(b, 255 & b.gzhead.extra[b.gzindex]), b.gzindex++;
            b.gzhead.hcrc && b.pending > O && (A.adler = l(A.adler, b.pending_buf, b.pending - O, O)), b.gzindex === b.gzhead.extra.length && (b.gzindex = 0, b.status = 73);
          } else
            b.status = 73;
        if (b.status === 73)
          if (b.gzhead.name) {
            O = b.pending;
            do {
              if (b.pending === b.pending_buf_size && (b.gzhead.hcrc && b.pending > O && (A.adler = l(A.adler, b.pending_buf, b.pending - O, O)), z(A), O = b.pending, b.pending === b.pending_buf_size)) {
                D = 1;
                break;
              }
              D = b.gzindex < b.gzhead.name.length ? 255 & b.gzhead.name.charCodeAt(b.gzindex++) : 0, ot(b, D);
            } while (D !== 0);
            b.gzhead.hcrc && b.pending > O && (A.adler = l(A.adler, b.pending_buf, b.pending - O, O)), D === 0 && (b.gzindex = 0, b.status = 91);
          } else
            b.status = 91;
        if (b.status === 91)
          if (b.gzhead.comment) {
            O = b.pending;
            do {
              if (b.pending === b.pending_buf_size && (b.gzhead.hcrc && b.pending > O && (A.adler = l(A.adler, b.pending_buf, b.pending - O, O)), z(A), O = b.pending, b.pending === b.pending_buf_size)) {
                D = 1;
                break;
              }
              D = b.gzindex < b.gzhead.comment.length ? 255 & b.gzhead.comment.charCodeAt(b.gzindex++) : 0, ot(b, D);
            } while (D !== 0);
            b.gzhead.hcrc && b.pending > O && (A.adler = l(A.adler, b.pending_buf, b.pending - O, O)), D === 0 && (b.status = 103);
          } else
            b.status = 103;
        if (b.status === 103 && (b.gzhead.hcrc ? (b.pending + 2 > b.pending_buf_size && z(A), b.pending + 2 <= b.pending_buf_size && (ot(b, 255 & A.adler), ot(b, A.adler >> 8 & 255), A.adler = 0, b.status = P)) : b.status = P), b.pending !== 0) {
          if (z(A), A.avail_out === 0)
            return b.last_flush = -1, f;
        } else if (A.avail_in === 0 && H(W) <= H(Y) && W !== u)
          return et(A, -5);
        if (b.status === 666 && A.avail_in !== 0)
          return et(A, -5);
        if (A.avail_in !== 0 || b.lookahead !== 0 || W !== d && b.status !== 666) {
          var $ = b.strategy === 2 ? function(B, K) {
            for (var it; ; ) {
              if (B.lookahead === 0 && (Rt(B), B.lookahead === 0)) {
                if (K === d)
                  return _;
                break;
              }
              if (B.match_length = 0, it = o._tr_tally(B, 0, B.window[B.strstart]), B.lookahead--, B.strstart++, it && (U(B, !1), B.strm.avail_out === 0))
                return _;
            }
            return B.insert = 0, K === u ? (U(B, !0), B.strm.avail_out === 0 ? Q : V) : B.last_lit && (U(B, !1), B.strm.avail_out === 0) ? _ : v;
          }(b, W) : b.strategy === 3 ? function(B, K) {
            for (var it, J, ct, Ct, pt = B.window; ; ) {
              if (B.lookahead <= x) {
                if (Rt(B), B.lookahead <= x && K === d)
                  return _;
                if (B.lookahead === 0)
                  break;
              }
              if (B.match_length = 0, B.lookahead >= N && 0 < B.strstart && (J = pt[ct = B.strstart - 1]) === pt[++ct] && J === pt[++ct] && J === pt[++ct]) {
                Ct = B.strstart + x;
                do
                  ;
                while (J === pt[++ct] && J === pt[++ct] && J === pt[++ct] && J === pt[++ct] && J === pt[++ct] && J === pt[++ct] && J === pt[++ct] && J === pt[++ct] && ct < Ct);
                B.match_length = x - (Ct - ct), B.match_length > B.lookahead && (B.match_length = B.lookahead);
              }
              if (B.match_length >= N ? (it = o._tr_tally(B, 1, B.match_length - N), B.lookahead -= B.match_length, B.strstart += B.match_length, B.match_length = 0) : (it = o._tr_tally(B, 0, B.window[B.strstart]), B.lookahead--, B.strstart++), it && (U(B, !1), B.strm.avail_out === 0))
                return _;
            }
            return B.insert = 0, K === u ? (U(B, !0), B.strm.avail_out === 0 ? Q : V) : B.last_lit && (U(B, !1), B.strm.avail_out === 0) ? _ : v;
          }(b, W) : n[b.level].func(b, W);
          if ($ !== Q && $ !== V || (b.status = 666), $ === _ || $ === Q)
            return A.avail_out === 0 && (b.last_flush = -1), f;
          if ($ === v && (W === 1 ? o._tr_align(b) : W !== 5 && (o._tr_stored_block(b, 0, 0, !1), W === 3 && (nt(b.head), b.lookahead === 0 && (b.strstart = 0, b.block_start = 0, b.insert = 0))), z(A), A.avail_out === 0))
            return b.last_flush = -1, f;
        }
        return W !== u ? f : b.wrap <= 0 ? 1 : (b.wrap === 2 ? (ot(b, 255 & A.adler), ot(b, A.adler >> 8 & 255), ot(b, A.adler >> 16 & 255), ot(b, A.adler >> 24 & 255), ot(b, 255 & A.total_in), ot(b, A.total_in >> 8 & 255), ot(b, A.total_in >> 16 & 255), ot(b, A.total_in >> 24 & 255)) : (st(b, A.adler >>> 16), st(b, 65535 & A.adler)), z(A), 0 < b.wrap && (b.wrap = -b.wrap), b.pending !== 0 ? f : 1);
      }, i.deflateEnd = function(A) {
        var W;
        return A && A.state ? (W = A.state.status) !== w && W !== 69 && W !== 73 && W !== 91 && W !== 103 && W !== P && W !== 666 ? et(A, E) : (A.state = null, W === P ? et(A, -3) : f) : E;
      }, i.deflateSetDictionary = function(A, W) {
        var Y, b, O, D, Z, $, B, K, it = W.length;
        if (!A || !A.state || (D = (Y = A.state).wrap) === 2 || D === 1 && Y.status !== w || Y.lookahead)
          return E;
        for (D === 1 && (A.adler = a(A.adler, W, it, 0)), Y.wrap = 0, it >= Y.w_size && (D === 0 && (nt(Y.head), Y.strstart = 0, Y.block_start = 0, Y.insert = 0), K = new r.Buf8(Y.w_size), r.arraySet(K, W, it - Y.w_size, Y.w_size, 0), W = K, it = Y.w_size), Z = A.avail_in, $ = A.next_in, B = A.input, A.avail_in = it, A.next_in = 0, A.input = W, Rt(Y); Y.lookahead >= N; ) {
          for (b = Y.strstart, O = Y.lookahead - (N - 1); Y.ins_h = (Y.ins_h << Y.hash_shift ^ Y.window[b + N - 1]) & Y.hash_mask, Y.prev[b & Y.w_mask] = Y.head[Y.ins_h], Y.head[Y.ins_h] = b, b++, --O; )
            ;
          Y.strstart = b, Y.lookahead = N - 1, Rt(Y);
        }
        return Y.strstart += Y.lookahead, Y.block_start = Y.strstart, Y.insert = Y.lookahead, Y.lookahead = 0, Y.match_length = Y.prev_length = N - 1, Y.match_available = 0, A.next_in = $, A.input = B, A.avail_in = Z, Y.wrap = D, f;
      }, i.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(t, e, i) {
      e.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(t, e, i) {
      e.exports = function(n, r) {
        var o, a, l, h, d, u, f, E, p, I, m, C, R, g, y, F, S, L, N, x, k, w, P, _, v;
        o = n.state, a = n.next_in, _ = n.input, l = a + (n.avail_in - 5), h = n.next_out, v = n.output, d = h - (r - n.avail_out), u = h + (n.avail_out - 257), f = o.dmax, E = o.wsize, p = o.whave, I = o.wnext, m = o.window, C = o.hold, R = o.bits, g = o.lencode, y = o.distcode, F = (1 << o.lenbits) - 1, S = (1 << o.distbits) - 1;
        t:
          do {
            R < 15 && (C += _[a++] << R, R += 8, C += _[a++] << R, R += 8), L = g[C & F];
            e:
              for (; ; ) {
                if (C >>>= N = L >>> 24, R -= N, (N = L >>> 16 & 255) === 0)
                  v[h++] = 65535 & L;
                else {
                  if (!(16 & N)) {
                    if (!(64 & N)) {
                      L = g[(65535 & L) + (C & (1 << N) - 1)];
                      continue e;
                    }
                    if (32 & N) {
                      o.mode = 12;
                      break t;
                    }
                    n.msg = "invalid literal/length code", o.mode = 30;
                    break t;
                  }
                  x = 65535 & L, (N &= 15) && (R < N && (C += _[a++] << R, R += 8), x += C & (1 << N) - 1, C >>>= N, R -= N), R < 15 && (C += _[a++] << R, R += 8, C += _[a++] << R, R += 8), L = y[C & S];
                  s:
                    for (; ; ) {
                      if (C >>>= N = L >>> 24, R -= N, !(16 & (N = L >>> 16 & 255))) {
                        if (!(64 & N)) {
                          L = y[(65535 & L) + (C & (1 << N) - 1)];
                          continue s;
                        }
                        n.msg = "invalid distance code", o.mode = 30;
                        break t;
                      }
                      if (k = 65535 & L, R < (N &= 15) && (C += _[a++] << R, (R += 8) < N && (C += _[a++] << R, R += 8)), f < (k += C & (1 << N) - 1)) {
                        n.msg = "invalid distance too far back", o.mode = 30;
                        break t;
                      }
                      if (C >>>= N, R -= N, (N = h - d) < k) {
                        if (p < (N = k - N) && o.sane) {
                          n.msg = "invalid distance too far back", o.mode = 30;
                          break t;
                        }
                        if (P = m, (w = 0) === I) {
                          if (w += E - N, N < x) {
                            for (x -= N; v[h++] = m[w++], --N; )
                              ;
                            w = h - k, P = v;
                          }
                        } else if (I < N) {
                          if (w += E + I - N, (N -= I) < x) {
                            for (x -= N; v[h++] = m[w++], --N; )
                              ;
                            if (w = 0, I < x) {
                              for (x -= N = I; v[h++] = m[w++], --N; )
                                ;
                              w = h - k, P = v;
                            }
                          }
                        } else if (w += I - N, N < x) {
                          for (x -= N; v[h++] = m[w++], --N; )
                            ;
                          w = h - k, P = v;
                        }
                        for (; 2 < x; )
                          v[h++] = P[w++], v[h++] = P[w++], v[h++] = P[w++], x -= 3;
                        x && (v[h++] = P[w++], 1 < x && (v[h++] = P[w++]));
                      } else {
                        for (w = h - k; v[h++] = v[w++], v[h++] = v[w++], v[h++] = v[w++], 2 < (x -= 3); )
                          ;
                        x && (v[h++] = v[w++], 1 < x && (v[h++] = v[w++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (a < l && h < u);
        a -= x = R >> 3, C &= (1 << (R -= x << 3)) - 1, n.next_in = a, n.next_out = h, n.avail_in = a < l ? l - a + 5 : 5 - (a - l), n.avail_out = h < u ? u - h + 257 : 257 - (h - u), o.hold = C, o.bits = R;
      };
    }, {}], 49: [function(t, e, i) {
      var n = t("../utils/common"), r = t("./adler32"), o = t("./crc32"), a = t("./inffast"), l = t("./inftrees"), h = 1, d = 2, u = 0, f = -2, E = 1, p = 852, I = 592;
      function m(w) {
        return (w >>> 24 & 255) + (w >>> 8 & 65280) + ((65280 & w) << 8) + ((255 & w) << 24);
      }
      function C() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new n.Buf16(320), this.work = new n.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function R(w) {
        var P;
        return w && w.state ? (P = w.state, w.total_in = w.total_out = P.total = 0, w.msg = "", P.wrap && (w.adler = 1 & P.wrap), P.mode = E, P.last = 0, P.havedict = 0, P.dmax = 32768, P.head = null, P.hold = 0, P.bits = 0, P.lencode = P.lendyn = new n.Buf32(p), P.distcode = P.distdyn = new n.Buf32(I), P.sane = 1, P.back = -1, u) : f;
      }
      function g(w) {
        var P;
        return w && w.state ? ((P = w.state).wsize = 0, P.whave = 0, P.wnext = 0, R(w)) : f;
      }
      function y(w, P) {
        var _, v;
        return w && w.state ? (v = w.state, P < 0 ? (_ = 0, P = -P) : (_ = 1 + (P >> 4), P < 48 && (P &= 15)), P && (P < 8 || 15 < P) ? f : (v.window !== null && v.wbits !== P && (v.window = null), v.wrap = _, v.wbits = P, g(w))) : f;
      }
      function F(w, P) {
        var _, v;
        return w ? (v = new C(), (w.state = v).window = null, (_ = y(w, P)) !== u && (w.state = null), _) : f;
      }
      var S, L, N = !0;
      function x(w) {
        if (N) {
          var P;
          for (S = new n.Buf32(512), L = new n.Buf32(32), P = 0; P < 144; )
            w.lens[P++] = 8;
          for (; P < 256; )
            w.lens[P++] = 9;
          for (; P < 280; )
            w.lens[P++] = 7;
          for (; P < 288; )
            w.lens[P++] = 8;
          for (l(h, w.lens, 0, 288, S, 0, w.work, { bits: 9 }), P = 0; P < 32; )
            w.lens[P++] = 5;
          l(d, w.lens, 0, 32, L, 0, w.work, { bits: 5 }), N = !1;
        }
        w.lencode = S, w.lenbits = 9, w.distcode = L, w.distbits = 5;
      }
      function k(w, P, _, v) {
        var Q, V = w.state;
        return V.window === null && (V.wsize = 1 << V.wbits, V.wnext = 0, V.whave = 0, V.window = new n.Buf8(V.wsize)), v >= V.wsize ? (n.arraySet(V.window, P, _ - V.wsize, V.wsize, 0), V.wnext = 0, V.whave = V.wsize) : (v < (Q = V.wsize - V.wnext) && (Q = v), n.arraySet(V.window, P, _ - v, Q, V.wnext), (v -= Q) ? (n.arraySet(V.window, P, _ - v, v, 0), V.wnext = v, V.whave = V.wsize) : (V.wnext += Q, V.wnext === V.wsize && (V.wnext = 0), V.whave < V.wsize && (V.whave += Q))), 0;
      }
      i.inflateReset = g, i.inflateReset2 = y, i.inflateResetKeep = R, i.inflateInit = function(w) {
        return F(w, 15);
      }, i.inflateInit2 = F, i.inflate = function(w, P) {
        var _, v, Q, V, et, H, nt, z, U, ot, st, tt, Rt, Ft, at, ft, ut, It, Gt, Mt, A, W, Y, b, O = 0, D = new n.Buf8(4), Z = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!w || !w.state || !w.output || !w.input && w.avail_in !== 0)
          return f;
        (_ = w.state).mode === 12 && (_.mode = 13), et = w.next_out, Q = w.output, nt = w.avail_out, V = w.next_in, v = w.input, H = w.avail_in, z = _.hold, U = _.bits, ot = H, st = nt, W = u;
        t:
          for (; ; )
            switch (_.mode) {
              case E:
                if (_.wrap === 0) {
                  _.mode = 13;
                  break;
                }
                for (; U < 16; ) {
                  if (H === 0)
                    break t;
                  H--, z += v[V++] << U, U += 8;
                }
                if (2 & _.wrap && z === 35615) {
                  D[_.check = 0] = 255 & z, D[1] = z >>> 8 & 255, _.check = o(_.check, D, 2, 0), U = z = 0, _.mode = 2;
                  break;
                }
                if (_.flags = 0, _.head && (_.head.done = !1), !(1 & _.wrap) || (((255 & z) << 8) + (z >> 8)) % 31) {
                  w.msg = "incorrect header check", _.mode = 30;
                  break;
                }
                if ((15 & z) != 8) {
                  w.msg = "unknown compression method", _.mode = 30;
                  break;
                }
                if (U -= 4, A = 8 + (15 & (z >>>= 4)), _.wbits === 0)
                  _.wbits = A;
                else if (A > _.wbits) {
                  w.msg = "invalid window size", _.mode = 30;
                  break;
                }
                _.dmax = 1 << A, w.adler = _.check = 1, _.mode = 512 & z ? 10 : 12, U = z = 0;
                break;
              case 2:
                for (; U < 16; ) {
                  if (H === 0)
                    break t;
                  H--, z += v[V++] << U, U += 8;
                }
                if (_.flags = z, (255 & _.flags) != 8) {
                  w.msg = "unknown compression method", _.mode = 30;
                  break;
                }
                if (57344 & _.flags) {
                  w.msg = "unknown header flags set", _.mode = 30;
                  break;
                }
                _.head && (_.head.text = z >> 8 & 1), 512 & _.flags && (D[0] = 255 & z, D[1] = z >>> 8 & 255, _.check = o(_.check, D, 2, 0)), U = z = 0, _.mode = 3;
              case 3:
                for (; U < 32; ) {
                  if (H === 0)
                    break t;
                  H--, z += v[V++] << U, U += 8;
                }
                _.head && (_.head.time = z), 512 & _.flags && (D[0] = 255 & z, D[1] = z >>> 8 & 255, D[2] = z >>> 16 & 255, D[3] = z >>> 24 & 255, _.check = o(_.check, D, 4, 0)), U = z = 0, _.mode = 4;
              case 4:
                for (; U < 16; ) {
                  if (H === 0)
                    break t;
                  H--, z += v[V++] << U, U += 8;
                }
                _.head && (_.head.xflags = 255 & z, _.head.os = z >> 8), 512 & _.flags && (D[0] = 255 & z, D[1] = z >>> 8 & 255, _.check = o(_.check, D, 2, 0)), U = z = 0, _.mode = 5;
              case 5:
                if (1024 & _.flags) {
                  for (; U < 16; ) {
                    if (H === 0)
                      break t;
                    H--, z += v[V++] << U, U += 8;
                  }
                  _.length = z, _.head && (_.head.extra_len = z), 512 & _.flags && (D[0] = 255 & z, D[1] = z >>> 8 & 255, _.check = o(_.check, D, 2, 0)), U = z = 0;
                } else
                  _.head && (_.head.extra = null);
                _.mode = 6;
              case 6:
                if (1024 & _.flags && (H < (tt = _.length) && (tt = H), tt && (_.head && (A = _.head.extra_len - _.length, _.head.extra || (_.head.extra = new Array(_.head.extra_len)), n.arraySet(_.head.extra, v, V, tt, A)), 512 & _.flags && (_.check = o(_.check, v, tt, V)), H -= tt, V += tt, _.length -= tt), _.length))
                  break t;
                _.length = 0, _.mode = 7;
              case 7:
                if (2048 & _.flags) {
                  if (H === 0)
                    break t;
                  for (tt = 0; A = v[V + tt++], _.head && A && _.length < 65536 && (_.head.name += String.fromCharCode(A)), A && tt < H; )
                    ;
                  if (512 & _.flags && (_.check = o(_.check, v, tt, V)), H -= tt, V += tt, A)
                    break t;
                } else
                  _.head && (_.head.name = null);
                _.length = 0, _.mode = 8;
              case 8:
                if (4096 & _.flags) {
                  if (H === 0)
                    break t;
                  for (tt = 0; A = v[V + tt++], _.head && A && _.length < 65536 && (_.head.comment += String.fromCharCode(A)), A && tt < H; )
                    ;
                  if (512 & _.flags && (_.check = o(_.check, v, tt, V)), H -= tt, V += tt, A)
                    break t;
                } else
                  _.head && (_.head.comment = null);
                _.mode = 9;
              case 9:
                if (512 & _.flags) {
                  for (; U < 16; ) {
                    if (H === 0)
                      break t;
                    H--, z += v[V++] << U, U += 8;
                  }
                  if (z !== (65535 & _.check)) {
                    w.msg = "header crc mismatch", _.mode = 30;
                    break;
                  }
                  U = z = 0;
                }
                _.head && (_.head.hcrc = _.flags >> 9 & 1, _.head.done = !0), w.adler = _.check = 0, _.mode = 12;
                break;
              case 10:
                for (; U < 32; ) {
                  if (H === 0)
                    break t;
                  H--, z += v[V++] << U, U += 8;
                }
                w.adler = _.check = m(z), U = z = 0, _.mode = 11;
              case 11:
                if (_.havedict === 0)
                  return w.next_out = et, w.avail_out = nt, w.next_in = V, w.avail_in = H, _.hold = z, _.bits = U, 2;
                w.adler = _.check = 1, _.mode = 12;
              case 12:
                if (P === 5 || P === 6)
                  break t;
              case 13:
                if (_.last) {
                  z >>>= 7 & U, U -= 7 & U, _.mode = 27;
                  break;
                }
                for (; U < 3; ) {
                  if (H === 0)
                    break t;
                  H--, z += v[V++] << U, U += 8;
                }
                switch (_.last = 1 & z, U -= 1, 3 & (z >>>= 1)) {
                  case 0:
                    _.mode = 14;
                    break;
                  case 1:
                    if (x(_), _.mode = 20, P !== 6)
                      break;
                    z >>>= 2, U -= 2;
                    break t;
                  case 2:
                    _.mode = 17;
                    break;
                  case 3:
                    w.msg = "invalid block type", _.mode = 30;
                }
                z >>>= 2, U -= 2;
                break;
              case 14:
                for (z >>>= 7 & U, U -= 7 & U; U < 32; ) {
                  if (H === 0)
                    break t;
                  H--, z += v[V++] << U, U += 8;
                }
                if ((65535 & z) != (z >>> 16 ^ 65535)) {
                  w.msg = "invalid stored block lengths", _.mode = 30;
                  break;
                }
                if (_.length = 65535 & z, U = z = 0, _.mode = 15, P === 6)
                  break t;
              case 15:
                _.mode = 16;
              case 16:
                if (tt = _.length) {
                  if (H < tt && (tt = H), nt < tt && (tt = nt), tt === 0)
                    break t;
                  n.arraySet(Q, v, V, tt, et), H -= tt, V += tt, nt -= tt, et += tt, _.length -= tt;
                  break;
                }
                _.mode = 12;
                break;
              case 17:
                for (; U < 14; ) {
                  if (H === 0)
                    break t;
                  H--, z += v[V++] << U, U += 8;
                }
                if (_.nlen = 257 + (31 & z), z >>>= 5, U -= 5, _.ndist = 1 + (31 & z), z >>>= 5, U -= 5, _.ncode = 4 + (15 & z), z >>>= 4, U -= 4, 286 < _.nlen || 30 < _.ndist) {
                  w.msg = "too many length or distance symbols", _.mode = 30;
                  break;
                }
                _.have = 0, _.mode = 18;
              case 18:
                for (; _.have < _.ncode; ) {
                  for (; U < 3; ) {
                    if (H === 0)
                      break t;
                    H--, z += v[V++] << U, U += 8;
                  }
                  _.lens[Z[_.have++]] = 7 & z, z >>>= 3, U -= 3;
                }
                for (; _.have < 19; )
                  _.lens[Z[_.have++]] = 0;
                if (_.lencode = _.lendyn, _.lenbits = 7, Y = { bits: _.lenbits }, W = l(0, _.lens, 0, 19, _.lencode, 0, _.work, Y), _.lenbits = Y.bits, W) {
                  w.msg = "invalid code lengths set", _.mode = 30;
                  break;
                }
                _.have = 0, _.mode = 19;
              case 19:
                for (; _.have < _.nlen + _.ndist; ) {
                  for (; ft = (O = _.lencode[z & (1 << _.lenbits) - 1]) >>> 16 & 255, ut = 65535 & O, !((at = O >>> 24) <= U); ) {
                    if (H === 0)
                      break t;
                    H--, z += v[V++] << U, U += 8;
                  }
                  if (ut < 16)
                    z >>>= at, U -= at, _.lens[_.have++] = ut;
                  else {
                    if (ut === 16) {
                      for (b = at + 2; U < b; ) {
                        if (H === 0)
                          break t;
                        H--, z += v[V++] << U, U += 8;
                      }
                      if (z >>>= at, U -= at, _.have === 0) {
                        w.msg = "invalid bit length repeat", _.mode = 30;
                        break;
                      }
                      A = _.lens[_.have - 1], tt = 3 + (3 & z), z >>>= 2, U -= 2;
                    } else if (ut === 17) {
                      for (b = at + 3; U < b; ) {
                        if (H === 0)
                          break t;
                        H--, z += v[V++] << U, U += 8;
                      }
                      U -= at, A = 0, tt = 3 + (7 & (z >>>= at)), z >>>= 3, U -= 3;
                    } else {
                      for (b = at + 7; U < b; ) {
                        if (H === 0)
                          break t;
                        H--, z += v[V++] << U, U += 8;
                      }
                      U -= at, A = 0, tt = 11 + (127 & (z >>>= at)), z >>>= 7, U -= 7;
                    }
                    if (_.have + tt > _.nlen + _.ndist) {
                      w.msg = "invalid bit length repeat", _.mode = 30;
                      break;
                    }
                    for (; tt--; )
                      _.lens[_.have++] = A;
                  }
                }
                if (_.mode === 30)
                  break;
                if (_.lens[256] === 0) {
                  w.msg = "invalid code -- missing end-of-block", _.mode = 30;
                  break;
                }
                if (_.lenbits = 9, Y = { bits: _.lenbits }, W = l(h, _.lens, 0, _.nlen, _.lencode, 0, _.work, Y), _.lenbits = Y.bits, W) {
                  w.msg = "invalid literal/lengths set", _.mode = 30;
                  break;
                }
                if (_.distbits = 6, _.distcode = _.distdyn, Y = { bits: _.distbits }, W = l(d, _.lens, _.nlen, _.ndist, _.distcode, 0, _.work, Y), _.distbits = Y.bits, W) {
                  w.msg = "invalid distances set", _.mode = 30;
                  break;
                }
                if (_.mode = 20, P === 6)
                  break t;
              case 20:
                _.mode = 21;
              case 21:
                if (6 <= H && 258 <= nt) {
                  w.next_out = et, w.avail_out = nt, w.next_in = V, w.avail_in = H, _.hold = z, _.bits = U, a(w, st), et = w.next_out, Q = w.output, nt = w.avail_out, V = w.next_in, v = w.input, H = w.avail_in, z = _.hold, U = _.bits, _.mode === 12 && (_.back = -1);
                  break;
                }
                for (_.back = 0; ft = (O = _.lencode[z & (1 << _.lenbits) - 1]) >>> 16 & 255, ut = 65535 & O, !((at = O >>> 24) <= U); ) {
                  if (H === 0)
                    break t;
                  H--, z += v[V++] << U, U += 8;
                }
                if (ft && !(240 & ft)) {
                  for (It = at, Gt = ft, Mt = ut; ft = (O = _.lencode[Mt + ((z & (1 << It + Gt) - 1) >> It)]) >>> 16 & 255, ut = 65535 & O, !(It + (at = O >>> 24) <= U); ) {
                    if (H === 0)
                      break t;
                    H--, z += v[V++] << U, U += 8;
                  }
                  z >>>= It, U -= It, _.back += It;
                }
                if (z >>>= at, U -= at, _.back += at, _.length = ut, ft === 0) {
                  _.mode = 26;
                  break;
                }
                if (32 & ft) {
                  _.back = -1, _.mode = 12;
                  break;
                }
                if (64 & ft) {
                  w.msg = "invalid literal/length code", _.mode = 30;
                  break;
                }
                _.extra = 15 & ft, _.mode = 22;
              case 22:
                if (_.extra) {
                  for (b = _.extra; U < b; ) {
                    if (H === 0)
                      break t;
                    H--, z += v[V++] << U, U += 8;
                  }
                  _.length += z & (1 << _.extra) - 1, z >>>= _.extra, U -= _.extra, _.back += _.extra;
                }
                _.was = _.length, _.mode = 23;
              case 23:
                for (; ft = (O = _.distcode[z & (1 << _.distbits) - 1]) >>> 16 & 255, ut = 65535 & O, !((at = O >>> 24) <= U); ) {
                  if (H === 0)
                    break t;
                  H--, z += v[V++] << U, U += 8;
                }
                if (!(240 & ft)) {
                  for (It = at, Gt = ft, Mt = ut; ft = (O = _.distcode[Mt + ((z & (1 << It + Gt) - 1) >> It)]) >>> 16 & 255, ut = 65535 & O, !(It + (at = O >>> 24) <= U); ) {
                    if (H === 0)
                      break t;
                    H--, z += v[V++] << U, U += 8;
                  }
                  z >>>= It, U -= It, _.back += It;
                }
                if (z >>>= at, U -= at, _.back += at, 64 & ft) {
                  w.msg = "invalid distance code", _.mode = 30;
                  break;
                }
                _.offset = ut, _.extra = 15 & ft, _.mode = 24;
              case 24:
                if (_.extra) {
                  for (b = _.extra; U < b; ) {
                    if (H === 0)
                      break t;
                    H--, z += v[V++] << U, U += 8;
                  }
                  _.offset += z & (1 << _.extra) - 1, z >>>= _.extra, U -= _.extra, _.back += _.extra;
                }
                if (_.offset > _.dmax) {
                  w.msg = "invalid distance too far back", _.mode = 30;
                  break;
                }
                _.mode = 25;
              case 25:
                if (nt === 0)
                  break t;
                if (tt = st - nt, _.offset > tt) {
                  if ((tt = _.offset - tt) > _.whave && _.sane) {
                    w.msg = "invalid distance too far back", _.mode = 30;
                    break;
                  }
                  Rt = tt > _.wnext ? (tt -= _.wnext, _.wsize - tt) : _.wnext - tt, tt > _.length && (tt = _.length), Ft = _.window;
                } else
                  Ft = Q, Rt = et - _.offset, tt = _.length;
                for (nt < tt && (tt = nt), nt -= tt, _.length -= tt; Q[et++] = Ft[Rt++], --tt; )
                  ;
                _.length === 0 && (_.mode = 21);
                break;
              case 26:
                if (nt === 0)
                  break t;
                Q[et++] = _.length, nt--, _.mode = 21;
                break;
              case 27:
                if (_.wrap) {
                  for (; U < 32; ) {
                    if (H === 0)
                      break t;
                    H--, z |= v[V++] << U, U += 8;
                  }
                  if (st -= nt, w.total_out += st, _.total += st, st && (w.adler = _.check = _.flags ? o(_.check, Q, st, et - st) : r(_.check, Q, st, et - st)), st = nt, (_.flags ? z : m(z)) !== _.check) {
                    w.msg = "incorrect data check", _.mode = 30;
                    break;
                  }
                  U = z = 0;
                }
                _.mode = 28;
              case 28:
                if (_.wrap && _.flags) {
                  for (; U < 32; ) {
                    if (H === 0)
                      break t;
                    H--, z += v[V++] << U, U += 8;
                  }
                  if (z !== (4294967295 & _.total)) {
                    w.msg = "incorrect length check", _.mode = 30;
                    break;
                  }
                  U = z = 0;
                }
                _.mode = 29;
              case 29:
                W = 1;
                break t;
              case 30:
                W = -3;
                break t;
              case 31:
                return -4;
              case 32:
              default:
                return f;
            }
        return w.next_out = et, w.avail_out = nt, w.next_in = V, w.avail_in = H, _.hold = z, _.bits = U, (_.wsize || st !== w.avail_out && _.mode < 30 && (_.mode < 27 || P !== 4)) && k(w, w.output, w.next_out, st - w.avail_out) ? (_.mode = 31, -4) : (ot -= w.avail_in, st -= w.avail_out, w.total_in += ot, w.total_out += st, _.total += st, _.wrap && st && (w.adler = _.check = _.flags ? o(_.check, Q, st, w.next_out - st) : r(_.check, Q, st, w.next_out - st)), w.data_type = _.bits + (_.last ? 64 : 0) + (_.mode === 12 ? 128 : 0) + (_.mode === 20 || _.mode === 15 ? 256 : 0), (ot == 0 && st === 0 || P === 4) && W === u && (W = -5), W);
      }, i.inflateEnd = function(w) {
        if (!w || !w.state)
          return f;
        var P = w.state;
        return P.window && (P.window = null), w.state = null, u;
      }, i.inflateGetHeader = function(w, P) {
        var _;
        return w && w.state && 2 & (_ = w.state).wrap ? ((_.head = P).done = !1, u) : f;
      }, i.inflateSetDictionary = function(w, P) {
        var _, v = P.length;
        return w && w.state ? (_ = w.state).wrap !== 0 && _.mode !== 11 ? f : _.mode === 11 && r(1, P, v, 0) !== _.check ? -3 : k(w, P, v, v) ? (_.mode = 31, -4) : (_.havedict = 1, u) : f;
      }, i.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(t, e, i) {
      var n = t("../utils/common"), r = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], o = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], a = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], l = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      e.exports = function(h, d, u, f, E, p, I, m) {
        var C, R, g, y, F, S, L, N, x, k = m.bits, w = 0, P = 0, _ = 0, v = 0, Q = 0, V = 0, et = 0, H = 0, nt = 0, z = 0, U = null, ot = 0, st = new n.Buf16(16), tt = new n.Buf16(16), Rt = null, Ft = 0;
        for (w = 0; w <= 15; w++)
          st[w] = 0;
        for (P = 0; P < f; P++)
          st[d[u + P]]++;
        for (Q = k, v = 15; 1 <= v && st[v] === 0; v--)
          ;
        if (v < Q && (Q = v), v === 0)
          return E[p++] = 20971520, E[p++] = 20971520, m.bits = 1, 0;
        for (_ = 1; _ < v && st[_] === 0; _++)
          ;
        for (Q < _ && (Q = _), w = H = 1; w <= 15; w++)
          if (H <<= 1, (H -= st[w]) < 0)
            return -1;
        if (0 < H && (h === 0 || v !== 1))
          return -1;
        for (tt[1] = 0, w = 1; w < 15; w++)
          tt[w + 1] = tt[w] + st[w];
        for (P = 0; P < f; P++)
          d[u + P] !== 0 && (I[tt[d[u + P]]++] = P);
        if (S = h === 0 ? (U = Rt = I, 19) : h === 1 ? (U = r, ot -= 257, Rt = o, Ft -= 257, 256) : (U = a, Rt = l, -1), w = _, F = p, et = P = z = 0, g = -1, y = (nt = 1 << (V = Q)) - 1, h === 1 && 852 < nt || h === 2 && 592 < nt)
          return 1;
        for (; ; ) {
          for (L = w - et, x = I[P] < S ? (N = 0, I[P]) : I[P] > S ? (N = Rt[Ft + I[P]], U[ot + I[P]]) : (N = 96, 0), C = 1 << w - et, _ = R = 1 << V; E[F + (z >> et) + (R -= C)] = L << 24 | N << 16 | x | 0, R !== 0; )
            ;
          for (C = 1 << w - 1; z & C; )
            C >>= 1;
          if (C !== 0 ? (z &= C - 1, z += C) : z = 0, P++, --st[w] == 0) {
            if (w === v)
              break;
            w = d[u + I[P]];
          }
          if (Q < w && (z & y) !== g) {
            for (et === 0 && (et = Q), F += _, H = 1 << (V = w - et); V + et < v && !((H -= st[V + et]) <= 0); )
              V++, H <<= 1;
            if (nt += 1 << V, h === 1 && 852 < nt || h === 2 && 592 < nt)
              return 1;
            E[g = z & y] = Q << 24 | V << 16 | F - p | 0;
          }
        }
        return z !== 0 && (E[F + z] = w - et << 24 | 64 << 16 | 0), m.bits = Q, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(t, e, i) {
      e.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(t, e, i) {
      var n = t("../utils/common"), r = 0, o = 1;
      function a(O) {
        for (var D = O.length; 0 <= --D; )
          O[D] = 0;
      }
      var l = 0, h = 29, d = 256, u = d + 1 + h, f = 30, E = 19, p = 2 * u + 1, I = 15, m = 16, C = 7, R = 256, g = 16, y = 17, F = 18, S = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], L = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], N = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], x = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], k = new Array(2 * (u + 2));
      a(k);
      var w = new Array(2 * f);
      a(w);
      var P = new Array(512);
      a(P);
      var _ = new Array(256);
      a(_);
      var v = new Array(h);
      a(v);
      var Q, V, et, H = new Array(f);
      function nt(O, D, Z, $, B) {
        this.static_tree = O, this.extra_bits = D, this.extra_base = Z, this.elems = $, this.max_length = B, this.has_stree = O && O.length;
      }
      function z(O, D) {
        this.dyn_tree = O, this.max_code = 0, this.stat_desc = D;
      }
      function U(O) {
        return O < 256 ? P[O] : P[256 + (O >>> 7)];
      }
      function ot(O, D) {
        O.pending_buf[O.pending++] = 255 & D, O.pending_buf[O.pending++] = D >>> 8 & 255;
      }
      function st(O, D, Z) {
        O.bi_valid > m - Z ? (O.bi_buf |= D << O.bi_valid & 65535, ot(O, O.bi_buf), O.bi_buf = D >> m - O.bi_valid, O.bi_valid += Z - m) : (O.bi_buf |= D << O.bi_valid & 65535, O.bi_valid += Z);
      }
      function tt(O, D, Z) {
        st(O, Z[2 * D], Z[2 * D + 1]);
      }
      function Rt(O, D) {
        for (var Z = 0; Z |= 1 & O, O >>>= 1, Z <<= 1, 0 < --D; )
          ;
        return Z >>> 1;
      }
      function Ft(O, D, Z) {
        var $, B, K = new Array(I + 1), it = 0;
        for ($ = 1; $ <= I; $++)
          K[$] = it = it + Z[$ - 1] << 1;
        for (B = 0; B <= D; B++) {
          var J = O[2 * B + 1];
          J !== 0 && (O[2 * B] = Rt(K[J]++, J));
        }
      }
      function at(O) {
        var D;
        for (D = 0; D < u; D++)
          O.dyn_ltree[2 * D] = 0;
        for (D = 0; D < f; D++)
          O.dyn_dtree[2 * D] = 0;
        for (D = 0; D < E; D++)
          O.bl_tree[2 * D] = 0;
        O.dyn_ltree[2 * R] = 1, O.opt_len = O.static_len = 0, O.last_lit = O.matches = 0;
      }
      function ft(O) {
        8 < O.bi_valid ? ot(O, O.bi_buf) : 0 < O.bi_valid && (O.pending_buf[O.pending++] = O.bi_buf), O.bi_buf = 0, O.bi_valid = 0;
      }
      function ut(O, D, Z, $) {
        var B = 2 * D, K = 2 * Z;
        return O[B] < O[K] || O[B] === O[K] && $[D] <= $[Z];
      }
      function It(O, D, Z) {
        for (var $ = O.heap[Z], B = Z << 1; B <= O.heap_len && (B < O.heap_len && ut(D, O.heap[B + 1], O.heap[B], O.depth) && B++, !ut(D, $, O.heap[B], O.depth)); )
          O.heap[Z] = O.heap[B], Z = B, B <<= 1;
        O.heap[Z] = $;
      }
      function Gt(O, D, Z) {
        var $, B, K, it, J = 0;
        if (O.last_lit !== 0)
          for (; $ = O.pending_buf[O.d_buf + 2 * J] << 8 | O.pending_buf[O.d_buf + 2 * J + 1], B = O.pending_buf[O.l_buf + J], J++, $ === 0 ? tt(O, B, D) : (tt(O, (K = _[B]) + d + 1, D), (it = S[K]) !== 0 && st(O, B -= v[K], it), tt(O, K = U(--$), Z), (it = L[K]) !== 0 && st(O, $ -= H[K], it)), J < O.last_lit; )
            ;
        tt(O, R, D);
      }
      function Mt(O, D) {
        var Z, $, B, K = D.dyn_tree, it = D.stat_desc.static_tree, J = D.stat_desc.has_stree, ct = D.stat_desc.elems, Ct = -1;
        for (O.heap_len = 0, O.heap_max = p, Z = 0; Z < ct; Z++)
          K[2 * Z] !== 0 ? (O.heap[++O.heap_len] = Ct = Z, O.depth[Z] = 0) : K[2 * Z + 1] = 0;
        for (; O.heap_len < 2; )
          K[2 * (B = O.heap[++O.heap_len] = Ct < 2 ? ++Ct : 0)] = 1, O.depth[B] = 0, O.opt_len--, J && (O.static_len -= it[2 * B + 1]);
        for (D.max_code = Ct, Z = O.heap_len >> 1; 1 <= Z; Z--)
          It(O, K, Z);
        for (B = ct; Z = O.heap[1], O.heap[1] = O.heap[O.heap_len--], It(O, K, 1), $ = O.heap[1], O.heap[--O.heap_max] = Z, O.heap[--O.heap_max] = $, K[2 * B] = K[2 * Z] + K[2 * $], O.depth[B] = (O.depth[Z] >= O.depth[$] ? O.depth[Z] : O.depth[$]) + 1, K[2 * Z + 1] = K[2 * $ + 1] = B, O.heap[1] = B++, It(O, K, 1), 2 <= O.heap_len; )
          ;
        O.heap[--O.heap_max] = O.heap[1], function(pt, Ht) {
          var ss, ie, is, Ot, Ps, Oi, ue = Ht.dyn_tree, Nn = Ht.max_code, Jr = Ht.stat_desc.static_tree, to = Ht.stat_desc.has_stree, eo = Ht.stat_desc.extra_bits, bn = Ht.stat_desc.extra_base, ns = Ht.stat_desc.max_length, Ls = 0;
          for (Ot = 0; Ot <= I; Ot++)
            pt.bl_count[Ot] = 0;
          for (ue[2 * pt.heap[pt.heap_max] + 1] = 0, ss = pt.heap_max + 1; ss < p; ss++)
            ns < (Ot = ue[2 * ue[2 * (ie = pt.heap[ss]) + 1] + 1] + 1) && (Ot = ns, Ls++), ue[2 * ie + 1] = Ot, Nn < ie || (pt.bl_count[Ot]++, Ps = 0, bn <= ie && (Ps = eo[ie - bn]), Oi = ue[2 * ie], pt.opt_len += Oi * (Ot + Ps), to && (pt.static_len += Oi * (Jr[2 * ie + 1] + Ps)));
          if (Ls !== 0) {
            do {
              for (Ot = ns - 1; pt.bl_count[Ot] === 0; )
                Ot--;
              pt.bl_count[Ot]--, pt.bl_count[Ot + 1] += 2, pt.bl_count[ns]--, Ls -= 2;
            } while (0 < Ls);
            for (Ot = ns; Ot !== 0; Ot--)
              for (ie = pt.bl_count[Ot]; ie !== 0; )
                Nn < (is = pt.heap[--ss]) || (ue[2 * is + 1] !== Ot && (pt.opt_len += (Ot - ue[2 * is + 1]) * ue[2 * is], ue[2 * is + 1] = Ot), ie--);
          }
        }(O, D), Ft(K, Ct, O.bl_count);
      }
      function A(O, D, Z) {
        var $, B, K = -1, it = D[1], J = 0, ct = 7, Ct = 4;
        for (it === 0 && (ct = 138, Ct = 3), D[2 * (Z + 1) + 1] = 65535, $ = 0; $ <= Z; $++)
          B = it, it = D[2 * ($ + 1) + 1], ++J < ct && B === it || (J < Ct ? O.bl_tree[2 * B] += J : B !== 0 ? (B !== K && O.bl_tree[2 * B]++, O.bl_tree[2 * g]++) : J <= 10 ? O.bl_tree[2 * y]++ : O.bl_tree[2 * F]++, K = B, Ct = (J = 0) === it ? (ct = 138, 3) : B === it ? (ct = 6, 3) : (ct = 7, 4));
      }
      function W(O, D, Z) {
        var $, B, K = -1, it = D[1], J = 0, ct = 7, Ct = 4;
        for (it === 0 && (ct = 138, Ct = 3), $ = 0; $ <= Z; $++)
          if (B = it, it = D[2 * ($ + 1) + 1], !(++J < ct && B === it)) {
            if (J < Ct)
              for (; tt(O, B, O.bl_tree), --J != 0; )
                ;
            else
              B !== 0 ? (B !== K && (tt(O, B, O.bl_tree), J--), tt(O, g, O.bl_tree), st(O, J - 3, 2)) : J <= 10 ? (tt(O, y, O.bl_tree), st(O, J - 3, 3)) : (tt(O, F, O.bl_tree), st(O, J - 11, 7));
            K = B, Ct = (J = 0) === it ? (ct = 138, 3) : B === it ? (ct = 6, 3) : (ct = 7, 4);
          }
      }
      a(H);
      var Y = !1;
      function b(O, D, Z, $) {
        st(O, (l << 1) + ($ ? 1 : 0), 3), function(B, K, it, J) {
          ft(B), ot(B, it), ot(B, ~it), n.arraySet(B.pending_buf, B.window, K, it, B.pending), B.pending += it;
        }(O, D, Z);
      }
      i._tr_init = function(O) {
        Y || (function() {
          var D, Z, $, B, K, it = new Array(I + 1);
          for (B = $ = 0; B < h - 1; B++)
            for (v[B] = $, D = 0; D < 1 << S[B]; D++)
              _[$++] = B;
          for (_[$ - 1] = B, B = K = 0; B < 16; B++)
            for (H[B] = K, D = 0; D < 1 << L[B]; D++)
              P[K++] = B;
          for (K >>= 7; B < f; B++)
            for (H[B] = K << 7, D = 0; D < 1 << L[B] - 7; D++)
              P[256 + K++] = B;
          for (Z = 0; Z <= I; Z++)
            it[Z] = 0;
          for (D = 0; D <= 143; )
            k[2 * D + 1] = 8, D++, it[8]++;
          for (; D <= 255; )
            k[2 * D + 1] = 9, D++, it[9]++;
          for (; D <= 279; )
            k[2 * D + 1] = 7, D++, it[7]++;
          for (; D <= 287; )
            k[2 * D + 1] = 8, D++, it[8]++;
          for (Ft(k, u + 1, it), D = 0; D < f; D++)
            w[2 * D + 1] = 5, w[2 * D] = Rt(D, 5);
          Q = new nt(k, S, d + 1, u, I), V = new nt(w, L, 0, f, I), et = new nt(new Array(0), N, 0, E, C);
        }(), Y = !0), O.l_desc = new z(O.dyn_ltree, Q), O.d_desc = new z(O.dyn_dtree, V), O.bl_desc = new z(O.bl_tree, et), O.bi_buf = 0, O.bi_valid = 0, at(O);
      }, i._tr_stored_block = b, i._tr_flush_block = function(O, D, Z, $) {
        var B, K, it = 0;
        0 < O.level ? (O.strm.data_type === 2 && (O.strm.data_type = function(J) {
          var ct, Ct = 4093624447;
          for (ct = 0; ct <= 31; ct++, Ct >>>= 1)
            if (1 & Ct && J.dyn_ltree[2 * ct] !== 0)
              return r;
          if (J.dyn_ltree[18] !== 0 || J.dyn_ltree[20] !== 0 || J.dyn_ltree[26] !== 0)
            return o;
          for (ct = 32; ct < d; ct++)
            if (J.dyn_ltree[2 * ct] !== 0)
              return o;
          return r;
        }(O)), Mt(O, O.l_desc), Mt(O, O.d_desc), it = function(J) {
          var ct;
          for (A(J, J.dyn_ltree, J.l_desc.max_code), A(J, J.dyn_dtree, J.d_desc.max_code), Mt(J, J.bl_desc), ct = E - 1; 3 <= ct && J.bl_tree[2 * x[ct] + 1] === 0; ct--)
            ;
          return J.opt_len += 3 * (ct + 1) + 5 + 5 + 4, ct;
        }(O), B = O.opt_len + 3 + 7 >>> 3, (K = O.static_len + 3 + 7 >>> 3) <= B && (B = K)) : B = K = Z + 5, Z + 4 <= B && D !== -1 ? b(O, D, Z, $) : O.strategy === 4 || K === B ? (st(O, 2 + ($ ? 1 : 0), 3), Gt(O, k, w)) : (st(O, 4 + ($ ? 1 : 0), 3), function(J, ct, Ct, pt) {
          var Ht;
          for (st(J, ct - 257, 5), st(J, Ct - 1, 5), st(J, pt - 4, 4), Ht = 0; Ht < pt; Ht++)
            st(J, J.bl_tree[2 * x[Ht] + 1], 3);
          W(J, J.dyn_ltree, ct - 1), W(J, J.dyn_dtree, Ct - 1);
        }(O, O.l_desc.max_code + 1, O.d_desc.max_code + 1, it + 1), Gt(O, O.dyn_ltree, O.dyn_dtree)), at(O), $ && ft(O);
      }, i._tr_tally = function(O, D, Z) {
        return O.pending_buf[O.d_buf + 2 * O.last_lit] = D >>> 8 & 255, O.pending_buf[O.d_buf + 2 * O.last_lit + 1] = 255 & D, O.pending_buf[O.l_buf + O.last_lit] = 255 & Z, O.last_lit++, D === 0 ? O.dyn_ltree[2 * Z]++ : (O.matches++, D--, O.dyn_ltree[2 * (_[Z] + d + 1)]++, O.dyn_dtree[2 * U(D)]++), O.last_lit === O.lit_bufsize - 1;
      }, i._tr_align = function(O) {
        st(O, 2, 3), tt(O, R, k), function(D) {
          D.bi_valid === 16 ? (ot(D, D.bi_buf), D.bi_buf = 0, D.bi_valid = 0) : 8 <= D.bi_valid && (D.pending_buf[D.pending++] = 255 & D.bi_buf, D.bi_buf >>= 8, D.bi_valid -= 8);
        }(O);
      };
    }, { "../utils/common": 41 }], 53: [function(t, e, i) {
      e.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(t, e, i) {
      (function(n) {
        (function(r, o) {
          if (!r.setImmediate) {
            var a, l, h, d, u = 1, f = {}, E = !1, p = r.document, I = Object.getPrototypeOf && Object.getPrototypeOf(r);
            I = I && I.setTimeout ? I : r, a = {}.toString.call(r.process) === "[object process]" ? function(g) {
              process.nextTick(function() {
                C(g);
              });
            } : function() {
              if (r.postMessage && !r.importScripts) {
                var g = !0, y = r.onmessage;
                return r.onmessage = function() {
                  g = !1;
                }, r.postMessage("", "*"), r.onmessage = y, g;
              }
            }() ? (d = "setImmediate$" + Math.random() + "$", r.addEventListener ? r.addEventListener("message", R, !1) : r.attachEvent("onmessage", R), function(g) {
              r.postMessage(d + g, "*");
            }) : r.MessageChannel ? ((h = new MessageChannel()).port1.onmessage = function(g) {
              C(g.data);
            }, function(g) {
              h.port2.postMessage(g);
            }) : p && "onreadystatechange" in p.createElement("script") ? (l = p.documentElement, function(g) {
              var y = p.createElement("script");
              y.onreadystatechange = function() {
                C(g), y.onreadystatechange = null, l.removeChild(y), y = null;
              }, l.appendChild(y);
            }) : function(g) {
              setTimeout(C, 0, g);
            }, I.setImmediate = function(g) {
              typeof g != "function" && (g = new Function("" + g));
              for (var y = new Array(arguments.length - 1), F = 0; F < y.length; F++)
                y[F] = arguments[F + 1];
              var S = { callback: g, args: y };
              return f[u] = S, a(u), u++;
            }, I.clearImmediate = m;
          }
          function m(g) {
            delete f[g];
          }
          function C(g) {
            if (E)
              setTimeout(C, 0, g);
            else {
              var y = f[g];
              if (y) {
                E = !0;
                try {
                  (function(F) {
                    var S = F.callback, L = F.args;
                    switch (L.length) {
                      case 0:
                        S();
                        break;
                      case 1:
                        S(L[0]);
                        break;
                      case 2:
                        S(L[0], L[1]);
                        break;
                      case 3:
                        S(L[0], L[1], L[2]);
                        break;
                      default:
                        S.apply(o, L);
                    }
                  })(y);
                } finally {
                  m(g), E = !1;
                }
              }
            }
          }
          function R(g) {
            g.source === r && typeof g.data == "string" && g.data.indexOf(d) === 0 && C(+g.data.slice(d.length));
          }
        })(typeof self > "u" ? n === void 0 ? this : n : self);
      }).call(this, typeof ii < "u" ? ii : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(Wr);
var hc = Wr.exports;
const Cr = /* @__PURE__ */ lc(hc);
var Fn = {}, Si = {};
(function(c) {
  const s = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", t = s + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040", e = "[" + s + "][" + t + "]*", i = new RegExp("^" + e + "$"), n = function(o, a) {
    const l = [];
    let h = a.exec(o);
    for (; h; ) {
      const d = [];
      d.startIndex = a.lastIndex - h[0].length;
      const u = h.length;
      for (let f = 0; f < u; f++)
        d.push(h[f]);
      l.push(d), h = a.exec(o);
    }
    return l;
  }, r = function(o) {
    const a = i.exec(o);
    return !(a === null || typeof a > "u");
  };
  c.isExist = function(o) {
    return typeof o < "u";
  }, c.isEmptyObject = function(o) {
    return Object.keys(o).length === 0;
  }, c.merge = function(o, a, l) {
    if (a) {
      const h = Object.keys(a), d = h.length;
      for (let u = 0; u < d; u++)
        l === "strict" ? o[h[u]] = [a[h[u]]] : o[h[u]] = a[h[u]];
    }
  }, c.getValue = function(o) {
    return c.isExist(o) ? o : "";
  }, c.isName = r, c.getAllMatches = n, c.nameRegexp = e;
})(Si);
const Sn = Si, dc = {
  allowBooleanAttributes: !1,
  //A tag can have attributes without any value
  unpairedTags: []
};
Fn.validate = function(c, s) {
  s = Object.assign({}, dc, s);
  const t = [];
  let e = !1, i = !1;
  c[0] === "\uFEFF" && (c = c.substr(1));
  for (let n = 0; n < c.length; n++)
    if (c[n] === "<" && c[n + 1] === "?") {
      if (n += 2, n = _r(c, n), n.err)
        return n;
    } else if (c[n] === "<") {
      let r = n;
      if (n++, c[n] === "!") {
        n = Ar(c, n);
        continue;
      } else {
        let o = !1;
        c[n] === "/" && (o = !0, n++);
        let a = "";
        for (; n < c.length && c[n] !== ">" && c[n] !== " " && c[n] !== "	" && c[n] !== `
` && c[n] !== "\r"; n++)
          a += c[n];
        if (a = a.trim(), a[a.length - 1] === "/" && (a = a.substring(0, a.length - 1), n--), !Cc(a)) {
          let d;
          return a.trim().length === 0 ? d = "Invalid space after '<'." : d = "Tag '" + a + "' is an invalid name.", bt("InvalidTag", d, Ut(c, n));
        }
        const l = pc(c, n);
        if (l === !1)
          return bt("InvalidAttr", "Attributes for '" + a + "' have open quote.", Ut(c, n));
        let h = l.value;
        if (n = l.index, h[h.length - 1] === "/") {
          const d = n - h.length;
          h = h.substring(0, h.length - 1);
          const u = Rr(h, s);
          if (u === !0)
            e = !0;
          else
            return bt(u.err.code, u.err.msg, Ut(c, d + u.err.line));
        } else if (o)
          if (l.tagClosed) {
            if (h.trim().length > 0)
              return bt("InvalidTag", "Closing tag '" + a + "' can't have attributes or invalid starting.", Ut(c, r));
            if (t.length === 0)
              return bt("InvalidTag", "Closing tag '" + a + "' has not been opened.", Ut(c, r));
            {
              const d = t.pop();
              if (a !== d.tagName) {
                let u = Ut(c, d.tagStartPos);
                return bt(
                  "InvalidTag",
                  "Expected closing tag '" + d.tagName + "' (opened in line " + u.line + ", col " + u.col + ") instead of closing tag '" + a + "'.",
                  Ut(c, r)
                );
              }
              t.length == 0 && (i = !0);
            }
          } else
            return bt("InvalidTag", "Closing tag '" + a + "' doesn't have proper closing.", Ut(c, n));
        else {
          const d = Rr(h, s);
          if (d !== !0)
            return bt(d.err.code, d.err.msg, Ut(c, n - h.length + d.err.line));
          if (i === !0)
            return bt("InvalidXml", "Multiple possible root nodes found.", Ut(c, n));
          s.unpairedTags.indexOf(a) !== -1 || t.push({ tagName: a, tagStartPos: r }), e = !0;
        }
        for (n++; n < c.length; n++)
          if (c[n] === "<")
            if (c[n + 1] === "!") {
              n++, n = Ar(c, n);
              continue;
            } else if (c[n + 1] === "?") {
              if (n = _r(c, ++n), n.err)
                return n;
            } else
              break;
          else if (c[n] === "&") {
            const d = Ic(c, n);
            if (d == -1)
              return bt("InvalidChar", "char '&' is not expected.", Ut(c, n));
            n = d;
          } else if (i === !0 && !Tr(c[n]))
            return bt("InvalidXml", "Extra text at the end", Ut(c, n));
        c[n] === "<" && n--;
      }
    } else {
      if (Tr(c[n]))
        continue;
      return bt("InvalidChar", "char '" + c[n] + "' is not expected.", Ut(c, n));
    }
  if (e) {
    if (t.length == 1)
      return bt("InvalidTag", "Unclosed tag '" + t[0].tagName + "'.", Ut(c, t[0].tagStartPos));
    if (t.length > 0)
      return bt("InvalidXml", "Invalid '" + JSON.stringify(t.map((n) => n.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
  } else
    return bt("InvalidXml", "Start tag expected.", 1);
  return !0;
};
function Tr(c) {
  return c === " " || c === "	" || c === `
` || c === "\r";
}
function _r(c, s) {
  const t = s;
  for (; s < c.length; s++)
    if (c[s] == "?" || c[s] == " ") {
      const e = c.substr(t, s - t);
      if (s > 5 && e === "xml")
        return bt("InvalidXml", "XML declaration allowed only at the start of the document.", Ut(c, s));
      if (c[s] == "?" && c[s + 1] == ">") {
        s++;
        break;
      } else
        continue;
    }
  return s;
}
function Ar(c, s) {
  if (c.length > s + 5 && c[s + 1] === "-" && c[s + 2] === "-") {
    for (s += 3; s < c.length; s++)
      if (c[s] === "-" && c[s + 1] === "-" && c[s + 2] === ">") {
        s += 2;
        break;
      }
  } else if (c.length > s + 8 && c[s + 1] === "D" && c[s + 2] === "O" && c[s + 3] === "C" && c[s + 4] === "T" && c[s + 5] === "Y" && c[s + 6] === "P" && c[s + 7] === "E") {
    let t = 1;
    for (s += 8; s < c.length; s++)
      if (c[s] === "<")
        t++;
      else if (c[s] === ">" && (t--, t === 0))
        break;
  } else if (c.length > s + 9 && c[s + 1] === "[" && c[s + 2] === "C" && c[s + 3] === "D" && c[s + 4] === "A" && c[s + 5] === "T" && c[s + 6] === "A" && c[s + 7] === "[") {
    for (s += 8; s < c.length; s++)
      if (c[s] === "]" && c[s + 1] === "]" && c[s + 2] === ">") {
        s += 2;
        break;
      }
  }
  return s;
}
const uc = '"', fc = "'";
function pc(c, s) {
  let t = "", e = "", i = !1;
  for (; s < c.length; s++) {
    if (c[s] === uc || c[s] === fc)
      e === "" ? e = c[s] : e !== c[s] || (e = "");
    else if (c[s] === ">" && e === "") {
      i = !0;
      break;
    }
    t += c[s];
  }
  return e !== "" ? !1 : {
    value: t,
    index: s,
    tagClosed: i
  };
}
const Ec = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
function Rr(c, s) {
  const t = Sn.getAllMatches(c, Ec), e = {};
  for (let i = 0; i < t.length; i++) {
    if (t[i][1].length === 0)
      return bt("InvalidAttr", "Attribute '" + t[i][2] + "' has no space in starting.", Cs(t[i]));
    if (t[i][3] !== void 0 && t[i][4] === void 0)
      return bt("InvalidAttr", "Attribute '" + t[i][2] + "' is without value.", Cs(t[i]));
    if (t[i][3] === void 0 && !s.allowBooleanAttributes)
      return bt("InvalidAttr", "boolean attribute '" + t[i][2] + "' is not allowed.", Cs(t[i]));
    const n = t[i][2];
    if (!gc(n))
      return bt("InvalidAttr", "Attribute '" + n + "' is an invalid name.", Cs(t[i]));
    if (!e.hasOwnProperty(n))
      e[n] = 1;
    else
      return bt("InvalidAttr", "Attribute '" + n + "' is repeated.", Cs(t[i]));
  }
  return !0;
}
function mc(c, s) {
  let t = /\d/;
  for (c[s] === "x" && (s++, t = /[\da-fA-F]/); s < c.length; s++) {
    if (c[s] === ";")
      return s;
    if (!c[s].match(t))
      break;
  }
  return -1;
}
function Ic(c, s) {
  if (s++, c[s] === ";")
    return -1;
  if (c[s] === "#")
    return s++, mc(c, s);
  let t = 0;
  for (; s < c.length; s++, t++)
    if (!(c[s].match(/\w/) && t < 20)) {
      if (c[s] === ";")
        break;
      return -1;
    }
  return s;
}
function bt(c, s, t) {
  return {
    err: {
      code: c,
      msg: s,
      line: t.line || t,
      col: t.col
    }
  };
}
function gc(c) {
  return Sn.isName(c);
}
function Cc(c) {
  return Sn.isName(c);
}
function Ut(c, s) {
  const t = c.substring(0, s).split(/\r?\n/);
  return {
    line: t.length,
    // column number is last line's length + 1, because column numbering starts at 1:
    col: t[t.length - 1].length + 1
  };
}
function Cs(c) {
  return c.startIndex + c[1].length;
}
var On = {};
const Xr = {
  preserveOrder: !1,
  attributeNamePrefix: "@_",
  attributesGroupName: !1,
  textNodeName: "#text",
  ignoreAttributes: !0,
  removeNSPrefix: !1,
  // remove NS from tag name or attribute name if true
  allowBooleanAttributes: !1,
  //a tag can have attributes without any value
  //ignoreRootElement : false,
  parseTagValue: !0,
  parseAttributeValue: !1,
  trimValues: !0,
  //Trim string values of tag and attributes
  cdataPropName: !1,
  numberParseOptions: {
    hex: !0,
    leadingZeros: !0,
    eNotation: !0
  },
  tagValueProcessor: function(c, s) {
    return s;
  },
  attributeValueProcessor: function(c, s) {
    return s;
  },
  stopNodes: [],
  //nested tags will not be parsed even for errors
  alwaysCreateTextNode: !1,
  isArray: () => !1,
  commentPropName: !1,
  unpairedTags: [],
  processEntities: !0,
  htmlEntities: !1,
  ignoreDeclaration: !1,
  ignorePiTags: !1,
  transformTagName: !1,
  transformAttributeName: !1,
  updateTag: function(c, s, t) {
    return c;
  }
  // skipEmptyListItem: false
}, Tc = function(c) {
  return Object.assign({}, Xr, c);
};
On.buildOptions = Tc;
On.defaultOptions = Xr;
class _c {
  constructor(s) {
    this.tagname = s, this.child = [], this[":@"] = {};
  }
  add(s, t) {
    s === "__proto__" && (s = "#__proto__"), this.child.push({ [s]: t });
  }
  addChild(s) {
    s.tagname === "__proto__" && (s.tagname = "#__proto__"), s[":@"] && Object.keys(s[":@"]).length > 0 ? this.child.push({ [s.tagname]: s.child, ":@": s[":@"] }) : this.child.push({ [s.tagname]: s.child });
  }
}
var Ac = _c;
const Rc = Si;
function yc(c, s) {
  const t = {};
  if (c[s + 3] === "O" && c[s + 4] === "C" && c[s + 5] === "T" && c[s + 6] === "Y" && c[s + 7] === "P" && c[s + 8] === "E") {
    s = s + 9;
    let e = 1, i = !1, n = !1, r = "";
    for (; s < c.length; s++)
      if (c[s] === "<" && !n) {
        if (i && Sc(c, s))
          s += 7, [entityName, val, s] = wc(c, s + 1), val.indexOf("&") === -1 && (t[Pc(entityName)] = {
            regx: RegExp(`&${entityName};`, "g"),
            val
          });
        else if (i && Oc(c, s))
          s += 8;
        else if (i && Nc(c, s))
          s += 8;
        else if (i && bc(c, s))
          s += 9;
        else if (Fc)
          n = !0;
        else
          throw new Error("Invalid DOCTYPE");
        e++, r = "";
      } else if (c[s] === ">") {
        if (n ? c[s - 1] === "-" && c[s - 2] === "-" && (n = !1, e--) : e--, e === 0)
          break;
      } else
        c[s] === "[" ? i = !0 : r += c[s];
    if (e !== 0)
      throw new Error("Unclosed DOCTYPE");
  } else
    throw new Error("Invalid Tag instead of DOCTYPE");
  return { entities: t, i: s };
}
function wc(c, s) {
  let t = "";
  for (; s < c.length && c[s] !== "'" && c[s] !== '"'; s++)
    t += c[s];
  if (t = t.trim(), t.indexOf(" ") !== -1)
    throw new Error("External entites are not supported");
  const e = c[s++];
  let i = "";
  for (; s < c.length && c[s] !== e; s++)
    i += c[s];
  return [t, i, s];
}
function Fc(c, s) {
  return c[s + 1] === "!" && c[s + 2] === "-" && c[s + 3] === "-";
}
function Sc(c, s) {
  return c[s + 1] === "!" && c[s + 2] === "E" && c[s + 3] === "N" && c[s + 4] === "T" && c[s + 5] === "I" && c[s + 6] === "T" && c[s + 7] === "Y";
}
function Oc(c, s) {
  return c[s + 1] === "!" && c[s + 2] === "E" && c[s + 3] === "L" && c[s + 4] === "E" && c[s + 5] === "M" && c[s + 6] === "E" && c[s + 7] === "N" && c[s + 8] === "T";
}
function Nc(c, s) {
  return c[s + 1] === "!" && c[s + 2] === "A" && c[s + 3] === "T" && c[s + 4] === "T" && c[s + 5] === "L" && c[s + 6] === "I" && c[s + 7] === "S" && c[s + 8] === "T";
}
function bc(c, s) {
  return c[s + 1] === "!" && c[s + 2] === "N" && c[s + 3] === "O" && c[s + 4] === "T" && c[s + 5] === "A" && c[s + 6] === "T" && c[s + 7] === "I" && c[s + 8] === "O" && c[s + 9] === "N";
}
function Pc(c) {
  if (Rc.isName(c))
    return c;
  throw new Error(`Invalid entity name ${c}`);
}
var Lc = yc;
const Mc = /^[-+]?0x[a-fA-F0-9]+$/, xc = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
!Number.parseInt && window.parseInt && (Number.parseInt = window.parseInt);
!Number.parseFloat && window.parseFloat && (Number.parseFloat = window.parseFloat);
const vc = {
  hex: !0,
  leadingZeros: !0,
  decimalPoint: ".",
  eNotation: !0
  //skipLike: /regex/
};
function Dc(c, s = {}) {
  if (s = Object.assign({}, vc, s), !c || typeof c != "string")
    return c;
  let t = c.trim();
  if (s.skipLike !== void 0 && s.skipLike.test(t))
    return c;
  if (s.hex && Mc.test(t))
    return Number.parseInt(t, 16);
  {
    const e = xc.exec(t);
    if (e) {
      const i = e[1], n = e[2];
      let r = Uc(e[3]);
      const o = e[4] || e[6];
      if (!s.leadingZeros && n.length > 0 && i && t[2] !== ".")
        return c;
      if (!s.leadingZeros && n.length > 0 && !i && t[1] !== ".")
        return c;
      {
        const a = Number(t), l = "" + a;
        return l.search(/[eE]/) !== -1 || o ? s.eNotation ? a : c : t.indexOf(".") !== -1 ? l === "0" && r === "" || l === r || i && l === "-" + r ? a : c : n ? r === l || i + r === l ? a : c : t === l || t === i + l ? a : c;
      }
    } else
      return c;
  }
}
function Uc(c) {
  return c && c.indexOf(".") !== -1 && (c = c.replace(/0+$/, ""), c === "." ? c = "0" : c[0] === "." ? c = "0" + c : c[c.length - 1] === "." && (c = c.substr(0, c.length - 1))), c;
}
var Bc = Dc;
const Zr = Si, Ts = Ac, zc = Lc, kc = Bc;
let Vc = class {
  constructor(s) {
    this.options = s, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = {
      apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
      gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
      lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
      quot: { regex: /&(quot|#34|#x22);/g, val: '"' }
    }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }, this.htmlEntities = {
      space: { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      cent: { regex: /&(cent|#162);/g, val: "" },
      pound: { regex: /&(pound|#163);/g, val: "" },
      yen: { regex: /&(yen|#165);/g, val: "" },
      euro: { regex: /&(euro|#8364);/g, val: "" },
      copyright: { regex: /&(copy|#169);/g, val: "" },
      reg: { regex: /&(reg|#174);/g, val: "" },
      inr: { regex: /&(inr|#8377);/g, val: "" },
      num_dec: { regex: /&#([0-9]{1,7});/g, val: (t, e) => String.fromCharCode(Number.parseInt(e, 10)) },
      num_hex: { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (t, e) => String.fromCharCode(Number.parseInt(e, 16)) }
    }, this.addExternalEntities = Yc, this.parseXml = Zc, this.parseTextData = Gc, this.resolveNameSpace = Hc, this.buildAttributesMap = Xc, this.isItStopNode = qc, this.replaceEntitiesValue = jc, this.readStopNodeData = Jc, this.saveTextToParentTag = Qc, this.addChild = $c;
  }
};
function Yc(c) {
  const s = Object.keys(c);
  for (let t = 0; t < s.length; t++) {
    const e = s[t];
    this.lastEntities[e] = {
      regex: new RegExp("&" + e + ";", "g"),
      val: c[e]
    };
  }
}
function Gc(c, s, t, e, i, n, r) {
  if (c !== void 0 && (this.options.trimValues && !e && (c = c.trim()), c.length > 0)) {
    r || (c = this.replaceEntitiesValue(c));
    const o = this.options.tagValueProcessor(s, c, t, i, n);
    return o == null ? c : typeof o != typeof c || o !== c ? o : this.options.trimValues ? pn(c, this.options.parseTagValue, this.options.numberParseOptions) : c.trim() === c ? pn(c, this.options.parseTagValue, this.options.numberParseOptions) : c;
  }
}
function Hc(c) {
  if (this.options.removeNSPrefix) {
    const s = c.split(":"), t = c.charAt(0) === "/" ? "/" : "";
    if (s[0] === "xmlns")
      return "";
    s.length === 2 && (c = t + s[1]);
  }
  return c;
}
const Wc = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
function Xc(c, s, t) {
  if (!this.options.ignoreAttributes && typeof c == "string") {
    const e = Zr.getAllMatches(c, Wc), i = e.length, n = {};
    for (let r = 0; r < i; r++) {
      const o = this.resolveNameSpace(e[r][1]);
      let a = e[r][4], l = this.options.attributeNamePrefix + o;
      if (o.length)
        if (this.options.transformAttributeName && (l = this.options.transformAttributeName(l)), l === "__proto__" && (l = "#__proto__"), a !== void 0) {
          this.options.trimValues && (a = a.trim()), a = this.replaceEntitiesValue(a);
          const h = this.options.attributeValueProcessor(o, a, s);
          h == null ? n[l] = a : typeof h != typeof a || h !== a ? n[l] = h : n[l] = pn(
            a,
            this.options.parseAttributeValue,
            this.options.numberParseOptions
          );
        } else
          this.options.allowBooleanAttributes && (n[l] = !0);
    }
    if (!Object.keys(n).length)
      return;
    if (this.options.attributesGroupName) {
      const r = {};
      return r[this.options.attributesGroupName] = n, r;
    }
    return n;
  }
}
const Zc = function(c) {
  c = c.replace(/\r\n?/g, `
`);
  const s = new Ts("!xml");
  let t = s, e = "", i = "";
  for (let n = 0; n < c.length; n++)
    if (c[n] === "<")
      if (c[n + 1] === "/") {
        const o = Me(c, ">", n, "Closing Tag is not closed.");
        let a = c.substring(n + 2, o).trim();
        if (this.options.removeNSPrefix) {
          const d = a.indexOf(":");
          d !== -1 && (a = a.substr(d + 1));
        }
        this.options.transformTagName && (a = this.options.transformTagName(a)), t && (e = this.saveTextToParentTag(e, t, i));
        const l = i.substring(i.lastIndexOf(".") + 1);
        if (a && this.options.unpairedTags.indexOf(a) !== -1)
          throw new Error(`Unpaired tag can not be used as closing tag: </${a}>`);
        let h = 0;
        l && this.options.unpairedTags.indexOf(l) !== -1 ? (h = i.lastIndexOf(".", i.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : h = i.lastIndexOf("."), i = i.substring(0, h), t = this.tagsNodeStack.pop(), e = "", n = o;
      } else if (c[n + 1] === "?") {
        let o = fn(c, n, !1, "?>");
        if (!o)
          throw new Error("Pi Tag is not closed.");
        if (e = this.saveTextToParentTag(e, t, i), !(this.options.ignoreDeclaration && o.tagName === "?xml" || this.options.ignorePiTags)) {
          const a = new Ts(o.tagName);
          a.add(this.options.textNodeName, ""), o.tagName !== o.tagExp && o.attrExpPresent && (a[":@"] = this.buildAttributesMap(o.tagExp, i, o.tagName)), this.addChild(t, a, i);
        }
        n = o.closeIndex + 1;
      } else if (c.substr(n + 1, 3) === "!--") {
        const o = Me(c, "-->", n + 4, "Comment is not closed.");
        if (this.options.commentPropName) {
          const a = c.substring(n + 4, o - 2);
          e = this.saveTextToParentTag(e, t, i), t.add(this.options.commentPropName, [{ [this.options.textNodeName]: a }]);
        }
        n = o;
      } else if (c.substr(n + 1, 2) === "!D") {
        const o = zc(c, n);
        this.docTypeEntities = o.entities, n = o.i;
      } else if (c.substr(n + 1, 2) === "![") {
        const o = Me(c, "]]>", n, "CDATA is not closed.") - 2, a = c.substring(n + 9, o);
        e = this.saveTextToParentTag(e, t, i);
        let l = this.parseTextData(a, t.tagname, i, !0, !1, !0, !0);
        l == null && (l = ""), this.options.cdataPropName ? t.add(this.options.cdataPropName, [{ [this.options.textNodeName]: a }]) : t.add(this.options.textNodeName, l), n = o + 2;
      } else {
        let o = fn(c, n, this.options.removeNSPrefix), a = o.tagName;
        const l = o.rawTagName;
        let h = o.tagExp, d = o.attrExpPresent, u = o.closeIndex;
        this.options.transformTagName && (a = this.options.transformTagName(a)), t && e && t.tagname !== "!xml" && (e = this.saveTextToParentTag(e, t, i, !1));
        const f = t;
        if (f && this.options.unpairedTags.indexOf(f.tagname) !== -1 && (t = this.tagsNodeStack.pop(), i = i.substring(0, i.lastIndexOf("."))), a !== s.tagname && (i += i ? "." + a : a), this.isItStopNode(this.options.stopNodes, i, a)) {
          let E = "";
          if (h.length > 0 && h.lastIndexOf("/") === h.length - 1)
            a[a.length - 1] === "/" ? (a = a.substr(0, a.length - 1), i = i.substr(0, i.length - 1), h = a) : h = h.substr(0, h.length - 1), n = o.closeIndex;
          else if (this.options.unpairedTags.indexOf(a) !== -1)
            n = o.closeIndex;
          else {
            const I = this.readStopNodeData(c, l, u + 1);
            if (!I)
              throw new Error(`Unexpected end of ${l}`);
            n = I.i, E = I.tagContent;
          }
          const p = new Ts(a);
          a !== h && d && (p[":@"] = this.buildAttributesMap(h, i, a)), E && (E = this.parseTextData(E, a, i, !0, d, !0, !0)), i = i.substr(0, i.lastIndexOf(".")), p.add(this.options.textNodeName, E), this.addChild(t, p, i);
        } else {
          if (h.length > 0 && h.lastIndexOf("/") === h.length - 1) {
            a[a.length - 1] === "/" ? (a = a.substr(0, a.length - 1), i = i.substr(0, i.length - 1), h = a) : h = h.substr(0, h.length - 1), this.options.transformTagName && (a = this.options.transformTagName(a));
            const E = new Ts(a);
            a !== h && d && (E[":@"] = this.buildAttributesMap(h, i, a)), this.addChild(t, E, i), i = i.substr(0, i.lastIndexOf("."));
          } else {
            const E = new Ts(a);
            this.tagsNodeStack.push(t), a !== h && d && (E[":@"] = this.buildAttributesMap(h, i, a)), this.addChild(t, E, i), t = E;
          }
          e = "", n = u;
        }
      }
    else
      e += c[n];
  return s.child;
};
function $c(c, s, t) {
  const e = this.options.updateTag(s.tagname, t, s[":@"]);
  e === !1 || (typeof e == "string" && (s.tagname = e), c.addChild(s));
}
const jc = function(c) {
  if (this.options.processEntities) {
    for (let s in this.docTypeEntities) {
      const t = this.docTypeEntities[s];
      c = c.replace(t.regx, t.val);
    }
    for (let s in this.lastEntities) {
      const t = this.lastEntities[s];
      c = c.replace(t.regex, t.val);
    }
    if (this.options.htmlEntities)
      for (let s in this.htmlEntities) {
        const t = this.htmlEntities[s];
        c = c.replace(t.regex, t.val);
      }
    c = c.replace(this.ampEntity.regex, this.ampEntity.val);
  }
  return c;
};
function Qc(c, s, t, e) {
  return c && (e === void 0 && (e = Object.keys(s.child).length === 0), c = this.parseTextData(
    c,
    s.tagname,
    t,
    !1,
    s[":@"] ? Object.keys(s[":@"]).length !== 0 : !1,
    e
  ), c !== void 0 && c !== "" && s.add(this.options.textNodeName, c), c = ""), c;
}
function qc(c, s, t) {
  const e = "*." + t;
  for (const i in c) {
    const n = c[i];
    if (e === n || s === n)
      return !0;
  }
  return !1;
}
function Kc(c, s, t = ">") {
  let e, i = "";
  for (let n = s; n < c.length; n++) {
    let r = c[n];
    if (e)
      r === e && (e = "");
    else if (r === '"' || r === "'")
      e = r;
    else if (r === t[0])
      if (t[1]) {
        if (c[n + 1] === t[1])
          return {
            data: i,
            index: n
          };
      } else
        return {
          data: i,
          index: n
        };
    else
      r === "	" && (r = " ");
    i += r;
  }
}
function Me(c, s, t, e) {
  const i = c.indexOf(s, t);
  if (i === -1)
    throw new Error(e);
  return i + s.length - 1;
}
function fn(c, s, t, e = ">") {
  const i = Kc(c, s + 1, e);
  if (!i)
    return;
  let n = i.data;
  const r = i.index, o = n.search(/\s/);
  let a = n, l = !0;
  o !== -1 && (a = n.substring(0, o), n = n.substring(o + 1).trimStart());
  const h = a;
  if (t) {
    const d = a.indexOf(":");
    d !== -1 && (a = a.substr(d + 1), l = a !== i.data.substr(d + 1));
  }
  return {
    tagName: a,
    tagExp: n,
    closeIndex: r,
    attrExpPresent: l,
    rawTagName: h
  };
}
function Jc(c, s, t) {
  const e = t;
  let i = 1;
  for (; t < c.length; t++)
    if (c[t] === "<")
      if (c[t + 1] === "/") {
        const n = Me(c, ">", t, `${s} is not closed`);
        if (c.substring(t + 2, n).trim() === s && (i--, i === 0))
          return {
            tagContent: c.substring(e, t),
            i: n
          };
        t = n;
      } else if (c[t + 1] === "?")
        t = Me(c, "?>", t + 1, "StopNode is not closed.");
      else if (c.substr(t + 1, 3) === "!--")
        t = Me(c, "-->", t + 3, "StopNode is not closed.");
      else if (c.substr(t + 1, 2) === "![")
        t = Me(c, "]]>", t, "StopNode is not closed.") - 2;
      else {
        const n = fn(c, t, ">");
        n && ((n && n.tagName) === s && n.tagExp[n.tagExp.length - 1] !== "/" && i++, t = n.closeIndex);
      }
}
function pn(c, s, t) {
  if (s && typeof c == "string") {
    const e = c.trim();
    return e === "true" ? !0 : e === "false" ? !1 : kc(c, t);
  } else
    return Zr.isExist(c) ? c : "";
}
var tl = Vc, $r = {};
function el(c, s) {
  return jr(c, s);
}
function jr(c, s, t) {
  let e;
  const i = {};
  for (let n = 0; n < c.length; n++) {
    const r = c[n], o = sl(r);
    let a = "";
    if (t === void 0 ? a = o : a = t + "." + o, o === s.textNodeName)
      e === void 0 ? e = r[o] : e += "" + r[o];
    else {
      if (o === void 0)
        continue;
      if (r[o]) {
        let l = jr(r[o], s, a);
        const h = nl(l, s);
        r[":@"] ? il(l, r[":@"], a, s) : Object.keys(l).length === 1 && l[s.textNodeName] !== void 0 && !s.alwaysCreateTextNode ? l = l[s.textNodeName] : Object.keys(l).length === 0 && (s.alwaysCreateTextNode ? l[s.textNodeName] = "" : l = ""), i[o] !== void 0 && i.hasOwnProperty(o) ? (Array.isArray(i[o]) || (i[o] = [i[o]]), i[o].push(l)) : s.isArray(o, a, h) ? i[o] = [l] : i[o] = l;
      }
    }
  }
  return typeof e == "string" ? e.length > 0 && (i[s.textNodeName] = e) : e !== void 0 && (i[s.textNodeName] = e), i;
}
function sl(c) {
  const s = Object.keys(c);
  for (let t = 0; t < s.length; t++) {
    const e = s[t];
    if (e !== ":@")
      return e;
  }
}
function il(c, s, t, e) {
  if (s) {
    const i = Object.keys(s), n = i.length;
    for (let r = 0; r < n; r++) {
      const o = i[r];
      e.isArray(o, t + "." + o, !0, !0) ? c[o] = [s[o]] : c[o] = s[o];
    }
  }
}
function nl(c, s) {
  const { textNodeName: t } = s, e = Object.keys(c).length;
  return !!(e === 0 || e === 1 && (c[t] || typeof c[t] == "boolean" || c[t] === 0));
}
$r.prettify = el;
const { buildOptions: rl } = On, ol = tl, { prettify: al } = $r, cl = Fn;
let ll = class {
  constructor(s) {
    this.externalEntities = {}, this.options = rl(s);
  }
  /**
   * Parse XML dats to JS object 
   * @param {string|Buffer} xmlData 
   * @param {boolean|Object} validationOption 
   */
  parse(s, t) {
    if (typeof s != "string")
      if (s.toString)
        s = s.toString();
      else
        throw new Error("XML data is accepted in String or Bytes[] form.");
    if (t) {
      t === !0 && (t = {});
      const n = cl.validate(s, t);
      if (n !== !0)
        throw Error(`${n.err.msg}:${n.err.line}:${n.err.col}`);
    }
    const e = new ol(this.options);
    e.addExternalEntities(this.externalEntities);
    const i = e.parseXml(s);
    return this.options.preserveOrder || i === void 0 ? i : al(i, this.options);
  }
  /**
   * Add Entity which is not by default supported by this library
   * @param {string} key 
   * @param {string} value 
   */
  addEntity(s, t) {
    if (t.indexOf("&") !== -1)
      throw new Error("Entity value can't have '&'");
    if (s.indexOf("&") !== -1 || s.indexOf(";") !== -1)
      throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
    if (t === "&")
      throw new Error("An entity with value '&' is not permitted");
    this.externalEntities[s] = t;
  }
};
var hl = ll;
const dl = `
`;
function ul(c, s) {
  let t = "";
  return s.format && s.indentBy.length > 0 && (t = dl), Qr(c, s, "", t);
}
function Qr(c, s, t, e) {
  let i = "", n = !1;
  for (let r = 0; r < c.length; r++) {
    const o = c[r], a = fl(o);
    if (a === void 0)
      continue;
    let l = "";
    if (t.length === 0 ? l = a : l = `${t}.${a}`, a === s.textNodeName) {
      let E = o[a];
      pl(l, s) || (E = s.tagValueProcessor(a, E), E = qr(E, s)), n && (i += e), i += E, n = !1;
      continue;
    } else if (a === s.cdataPropName) {
      n && (i += e), i += `<![CDATA[${o[a][0][s.textNodeName]}]]>`, n = !1;
      continue;
    } else if (a === s.commentPropName) {
      i += e + `<!--${o[a][0][s.textNodeName]}-->`, n = !0;
      continue;
    } else if (a[0] === "?") {
      const E = yr(o[":@"], s), p = a === "?xml" ? "" : e;
      let I = o[a][0][s.textNodeName];
      I = I.length !== 0 ? " " + I : "", i += p + `<${a}${I}${E}?>`, n = !0;
      continue;
    }
    let h = e;
    h !== "" && (h += s.indentBy);
    const d = yr(o[":@"], s), u = e + `<${a}${d}`, f = Qr(o[a], s, l, h);
    s.unpairedTags.indexOf(a) !== -1 ? s.suppressUnpairedNode ? i += u + ">" : i += u + "/>" : (!f || f.length === 0) && s.suppressEmptyNode ? i += u + "/>" : f && f.endsWith(">") ? i += u + `>${f}${e}</${a}>` : (i += u + ">", f && e !== "" && (f.includes("/>") || f.includes("</")) ? i += e + s.indentBy + f + e : i += f, i += `</${a}>`), n = !0;
  }
  return i;
}
function fl(c) {
  const s = Object.keys(c);
  for (let t = 0; t < s.length; t++) {
    const e = s[t];
    if (c.hasOwnProperty(e) && e !== ":@")
      return e;
  }
}
function yr(c, s) {
  let t = "";
  if (c && !s.ignoreAttributes)
    for (let e in c) {
      if (!c.hasOwnProperty(e))
        continue;
      let i = s.attributeValueProcessor(e, c[e]);
      i = qr(i, s), i === !0 && s.suppressBooleanAttributes ? t += ` ${e.substr(s.attributeNamePrefix.length)}` : t += ` ${e.substr(s.attributeNamePrefix.length)}="${i}"`;
    }
  return t;
}
function pl(c, s) {
  c = c.substr(0, c.length - s.textNodeName.length - 1);
  let t = c.substr(c.lastIndexOf(".") + 1);
  for (let e in s.stopNodes)
    if (s.stopNodes[e] === c || s.stopNodes[e] === "*." + t)
      return !0;
  return !1;
}
function qr(c, s) {
  if (c && c.length > 0 && s.processEntities)
    for (let t = 0; t < s.entities.length; t++) {
      const e = s.entities[t];
      c = c.replace(e.regex, e.val);
    }
  return c;
}
var El = ul;
const ml = El, Il = {
  attributeNamePrefix: "@_",
  attributesGroupName: !1,
  textNodeName: "#text",
  ignoreAttributes: !0,
  cdataPropName: !1,
  format: !1,
  indentBy: "  ",
  suppressEmptyNode: !1,
  suppressUnpairedNode: !0,
  suppressBooleanAttributes: !0,
  tagValueProcessor: function(c, s) {
    return s;
  },
  attributeValueProcessor: function(c, s) {
    return s;
  },
  preserveOrder: !1,
  commentPropName: !1,
  unpairedTags: [],
  entities: [
    { regex: new RegExp("&", "g"), val: "&amp;" },
    //it must be on top
    { regex: new RegExp(">", "g"), val: "&gt;" },
    { regex: new RegExp("<", "g"), val: "&lt;" },
    { regex: new RegExp("'", "g"), val: "&apos;" },
    { regex: new RegExp('"', "g"), val: "&quot;" }
  ],
  processEntities: !0,
  stopNodes: [],
  // transformTagName: false,
  // transformAttributeName: false,
  oneListGroup: !1
};
function Se(c) {
  this.options = Object.assign({}, Il, c), this.options.ignoreAttributes || this.options.attributesGroupName ? this.isAttribute = function() {
    return !1;
  } : (this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = Tl), this.processTextOrObjNode = gl, this.options.format ? (this.indentate = Cl, this.tagEndChar = `>
`, this.newLine = `
`) : (this.indentate = function() {
    return "";
  }, this.tagEndChar = ">", this.newLine = "");
}
Se.prototype.build = function(c) {
  return this.options.preserveOrder ? ml(c, this.options) : (Array.isArray(c) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (c = {
    [this.options.arrayNodeName]: c
  }), this.j2x(c, 0).val);
};
Se.prototype.j2x = function(c, s) {
  let t = "", e = "";
  for (let i in c)
    if (Object.prototype.hasOwnProperty.call(c, i))
      if (typeof c[i] > "u")
        this.isAttribute(i) && (e += "");
      else if (c[i] === null)
        this.isAttribute(i) ? e += "" : i[0] === "?" ? e += this.indentate(s) + "<" + i + "?" + this.tagEndChar : e += this.indentate(s) + "<" + i + "/" + this.tagEndChar;
      else if (c[i] instanceof Date)
        e += this.buildTextValNode(c[i], i, "", s);
      else if (typeof c[i] != "object") {
        const n = this.isAttribute(i);
        if (n)
          t += this.buildAttrPairStr(n, "" + c[i]);
        else if (i === this.options.textNodeName) {
          let r = this.options.tagValueProcessor(i, "" + c[i]);
          e += this.replaceEntitiesValue(r);
        } else
          e += this.buildTextValNode(c[i], i, "", s);
      } else if (Array.isArray(c[i])) {
        const n = c[i].length;
        let r = "", o = "";
        for (let a = 0; a < n; a++) {
          const l = c[i][a];
          if (!(typeof l > "u"))
            if (l === null)
              i[0] === "?" ? e += this.indentate(s) + "<" + i + "?" + this.tagEndChar : e += this.indentate(s) + "<" + i + "/" + this.tagEndChar;
            else if (typeof l == "object")
              if (this.options.oneListGroup) {
                const h = this.j2x(l, s + 1);
                r += h.val, this.options.attributesGroupName && l.hasOwnProperty(this.options.attributesGroupName) && (o += h.attrStr);
              } else
                r += this.processTextOrObjNode(l, i, s);
            else if (this.options.oneListGroup) {
              let h = this.options.tagValueProcessor(i, l);
              h = this.replaceEntitiesValue(h), r += h;
            } else
              r += this.buildTextValNode(l, i, "", s);
        }
        this.options.oneListGroup && (r = this.buildObjectNode(r, i, o, s)), e += r;
      } else if (this.options.attributesGroupName && i === this.options.attributesGroupName) {
        const n = Object.keys(c[i]), r = n.length;
        for (let o = 0; o < r; o++)
          t += this.buildAttrPairStr(n[o], "" + c[i][n[o]]);
      } else
        e += this.processTextOrObjNode(c[i], i, s);
  return { attrStr: t, val: e };
};
Se.prototype.buildAttrPairStr = function(c, s) {
  return s = this.options.attributeValueProcessor(c, "" + s), s = this.replaceEntitiesValue(s), this.options.suppressBooleanAttributes && s === "true" ? " " + c : " " + c + '="' + s + '"';
};
function gl(c, s, t) {
  const e = this.j2x(c, t + 1);
  return c[this.options.textNodeName] !== void 0 && Object.keys(c).length === 1 ? this.buildTextValNode(c[this.options.textNodeName], s, e.attrStr, t) : this.buildObjectNode(e.val, s, e.attrStr, t);
}
Se.prototype.buildObjectNode = function(c, s, t, e) {
  if (c === "")
    return s[0] === "?" ? this.indentate(e) + "<" + s + t + "?" + this.tagEndChar : this.indentate(e) + "<" + s + t + this.closeTag(s) + this.tagEndChar;
  {
    let i = "</" + s + this.tagEndChar, n = "";
    return s[0] === "?" && (n = "?", i = ""), (t || t === "") && c.indexOf("<") === -1 ? this.indentate(e) + "<" + s + t + n + ">" + c + i : this.options.commentPropName !== !1 && s === this.options.commentPropName && n.length === 0 ? this.indentate(e) + `<!--${c}-->` + this.newLine : this.indentate(e) + "<" + s + t + n + this.tagEndChar + c + this.indentate(e) + i;
  }
};
Se.prototype.closeTag = function(c) {
  let s = "";
  return this.options.unpairedTags.indexOf(c) !== -1 ? this.options.suppressUnpairedNode || (s = "/") : this.options.suppressEmptyNode ? s = "/" : s = `></${c}`, s;
};
Se.prototype.buildTextValNode = function(c, s, t, e) {
  if (this.options.cdataPropName !== !1 && s === this.options.cdataPropName)
    return this.indentate(e) + `<![CDATA[${c}]]>` + this.newLine;
  if (this.options.commentPropName !== !1 && s === this.options.commentPropName)
    return this.indentate(e) + `<!--${c}-->` + this.newLine;
  if (s[0] === "?")
    return this.indentate(e) + "<" + s + t + "?" + this.tagEndChar;
  {
    let i = this.options.tagValueProcessor(s, c);
    return i = this.replaceEntitiesValue(i), i === "" ? this.indentate(e) + "<" + s + t + this.closeTag(s) + this.tagEndChar : this.indentate(e) + "<" + s + t + ">" + i + "</" + s + this.tagEndChar;
  }
};
Se.prototype.replaceEntitiesValue = function(c) {
  if (c && c.length > 0 && this.options.processEntities)
    for (let s = 0; s < this.options.entities.length; s++) {
      const t = this.options.entities[s];
      c = c.replace(t.regex, t.val);
    }
  return c;
};
function Cl(c) {
  return this.options.indentBy.repeat(c);
}
function Tl(c) {
  return c.startsWith(this.options.attributeNamePrefix) && c !== this.options.textNodeName ? c.substr(this.attrPrefixLen) : !1;
}
var _l = Se;
const Al = Fn, Rl = hl, yl = _l;
var wl = {
  XMLParser: Rl,
  XMLValidator: Al,
  XMLBuilder: yl
};
class En {
  /**
   * Constructs a new BCF Topic Comment instance.
   * @param components - The Components instance.
   * @param text - The initial comment text.
   */
  constructor(s, t) {
    T(this, "date", /* @__PURE__ */ new Date());
    T(this, "author");
    T(this, "guid", me.create());
    T(this, "viewpoint");
    T(this, "modifiedAuthor");
    T(this, "modifiedDate");
    T(this, "topic");
    T(this, "_components");
    T(this, "_comment", "");
    this._components = s, this._comment = t;
    const e = this._components.get(Lt);
    this.author = e.config.author;
  }
  /**
   * Sets the comment text and updates the modified date and author.
   * The author will be the one defined in BCFTopics.config.author
   * @param value - The new comment text.
   */
  set comment(s) {
    var e;
    const t = this._components.get(Lt);
    this._comment = s, this.modifiedDate = /* @__PURE__ */ new Date(), this.modifiedAuthor = t.config.author, (e = this.topic) == null || e.comments.set(this.guid, this);
  }
  /**
   * Gets the comment text.
   * @returns The comment text.
   */
  get comment() {
    return this._comment;
  }
  /**
   * Serializes the Comment instance into a BCF compliant XML string.
   *
   * @returns A string representing the Comment in BCFv2 XML format.
   */
  serialize() {
    let s = null;
    this.viewpoint && (s = `<Viewpoint Guid="${this.viewpoint.guid}"/>`);
    let t = null;
    this.modifiedDate && (t = `<ModifiedDate>${this.modifiedDate.toISOString()}</ModifiedDate>`);
    let e = null;
    return this.modifiedAuthor && (e = `<ModifiedAuthor>${this.modifiedAuthor}</ModifiedAuthor>`), `
      <Comment Guid="${this.guid}">
        <Date>${this.date.toISOString()}</Date>
        <Author>${this.author}</Author>
        <Comment>${this.comment}</Comment>
        ${s ?? ""}
        ${e ?? ""}
        ${t ?? ""}
      </Comment>
    `;
  }
}
const ce = class ce {
  /**
   * Initializes a new instance of the `Topic` class representing a BCF (BIM Collaboration Format) topic.
   * It provides methods and properties to manage and serialize BCF topics.
   *
   * @remarks
   * The default creationUser is the one set in BCFTopics.config.author
   * It should not be created manually. Better use BCFTopics.create().
   *
   * @param components - The `Components` instance that provides access to other components and services.
   */
  constructor(s) {
    /**
     * A unique identifier for the topic.
     *
     * @remarks
     * The `guid` is automatically generated upon topic creation and by no means it should change.
     */
    T(this, "guid", me.create());
    T(this, "title", ce.default.title);
    T(this, "creationDate", /* @__PURE__ */ new Date());
    T(this, "creationAuthor", "");
    // Store viewpoint guids instead of the actual Viewpoint to prevent a possible memory leak
    T(this, "viewpoints", new qe());
    // Store topic guids instead of the actual Topic to prevent a possible memory leak
    T(this, "relatedTopics", new qe());
    // There is no problem to store the comment it-self as it is not referenced anywhere else
    T(this, "comments", new Ee());
    T(this, "customData", {});
    T(this, "description");
    T(this, "serverAssignedId");
    T(this, "dueDate");
    T(this, "modifiedAuthor");
    T(this, "modifiedDate");
    T(this, "index");
    T(this, "_type", ce.default.type);
    T(this, "_status", ce.default.status);
    T(this, "_priority", ce.default.priority);
    T(this, "_stage", ce.default.priority);
    T(this, "_assignedTo", ce.default.assignedTo);
    T(this, "_labels", ce.default.labels);
    T(this, "_components");
    this._components = s;
    const t = s.get(Lt);
    this.creationAuthor = t.config.author, this.relatedTopics.guard = (e) => e !== this.guid;
  }
  set type(s) {
    const t = this._components.get(Lt), { strict: e, types: i } = t.config;
    (!e || i.has(s)) && (this._type = s);
  }
  get type() {
    return this._type;
  }
  set status(s) {
    const t = this._components.get(Lt), { strict: e, statuses: i } = t.config;
    (!e || i.has(s)) && (this._status = s);
  }
  get status() {
    return this._status;
  }
  set priority(s) {
    const t = this._components.get(Lt);
    if (s) {
      const { strict: e, priorities: i } = t.config;
      if (!(e ? i.has(s) : !0))
        return;
      this._priority = s;
    } else
      this._priority = s;
  }
  get priority() {
    return this._priority;
  }
  set stage(s) {
    const t = this._components.get(Lt);
    if (s) {
      const { strict: e, stages: i } = t.config;
      if (!(e ? i.has(s) : !0))
        return;
      this._stage = s;
    } else
      this._stage = s;
  }
  get stage() {
    return this._stage;
  }
  set assignedTo(s) {
    const t = this._components.get(Lt);
    if (s) {
      const { strict: e, users: i } = t.config;
      if (!(e ? i.has(s) : !0))
        return;
      this._assignedTo = s;
    } else
      this._assignedTo = s;
  }
  get assignedTo() {
    return this._assignedTo;
  }
  set labels(s) {
    const t = this._components.get(Lt), { strict: e, labels: i } = t.config;
    if (e) {
      const n = /* @__PURE__ */ new Set();
      for (const r of s)
        (!e || i.has(r)) && n.add(r);
      this._labels = n;
    } else
      this._labels = s;
  }
  get labels() {
    return this._labels;
  }
  get _managerVersion() {
    return this._components.get(Lt).config.version;
  }
  /**
   * Sets properties of the BCF Topic based on the provided data.
   *
   * @remarks
   * This method iterates over the provided `data` object and updates the corresponding properties of the BCF Topic.
   * It skips the `guid` property as it should not be modified.
   *
   * @param data - An object containing the properties to be updated.
   * @returns The topic
   *
   * @example
   * ```typescript
   * const topic = new Topic(components);
   * topic.set({
   *   title: "New BCF Topic Title",
   *   description: "This is a new description.",
   *   status: "Resolved",
   * });
   * ```
   */
  set(s) {
    const t = s, e = this;
    for (const n in s) {
      if (n === "guid")
        continue;
      const r = t[n];
      n in this && (e[n] = r);
    }
    return this._components.get(Lt).list.set(this.guid, this), this;
  }
  /**
   * Creates a new comment associated with the current topic.
   *
   * @param text - The text content of the comment.
   * @param viewpoint - (Optional) The viewpoint associated with the comment.
   *
   * @returns The newly created comment.
   *
   * @example
   * ```typescript
   * const viewpoint = viewpoints.create(world); // Created with an instance of Viewpoints
   * const topic = topics.create(); // Created with an instance of BCFTopics
   * topic.viewpoints.add(viewpoint);
   * const comment = topic.createComment("This is a new comment", viewpoint);
   * ```
   */
  createComment(s, t) {
    const e = new En(this._components, s);
    return e.viewpoint = t, e.topic = this, this.comments.set(e.guid, e), e;
  }
  createLabelTags(s = this._managerVersion) {
    let t = "Labels";
    s === "2.1" && (t = "Labels"), s === "3" && (t = "Label");
    let e = [...this.labels].map((i) => `<${t}>${i}</${t}>`).join(`
`);
    for (const i in this.customData) {
      const n = this.customData[i];
      typeof n == "string" && (e += `
<${t}>${n}</${t}>`);
    }
    return s === "2.1" ? e : s === "3" ? e.length !== 0 ? `<Labels>
${e}
</Labels>` : "<Labels/>" : e;
  }
  createCommentTags(s = this._managerVersion) {
    const t = [...this.comments.values()].map((e) => e.serialize()).join(`
`);
    return s === "2.1" ? t : s === "3" ? t.length !== 0 ? `<Comments>
${t}
</Comments>` : "<Comments/>" : t;
  }
  createViewpointTags(s = this._managerVersion) {
    let t = "Viewpoints";
    s === "2.1" && (t = "Viewpoints"), s === "3" && (t = "ViewPoint");
    const e = this._components.get(te), n = [...this.viewpoints].map((r) => e.list.get(r)).filter((r) => r).map((r) => `<${t} Guid="${r.guid}">
          <Viewpoint>${r.guid}.bcfv</Viewpoint>
          <Snapshot>${r.guid}.jpeg</Snapshot>
        </${t}>
      `).join(`
`);
    return s === "2.1" ? n : s === "3" ? n.length !== 0 ? `<Viewpoints>
${n}
</Viewpoints>` : "<Viewpoints />" : n;
  }
  createRelatedTopicTags(s = this._managerVersion) {
    const t = [...this.relatedTopics].map(
      (e) => `<RelatedTopic Guid="${e}"></RelatedTopic>
      `
    ).join(`
`);
    return s === "2.1" ? t : s === "3" ? t.length !== 0 ? `<RelatedTopics>
${t}
</RelatedTopics>` : "<RelatedTopics />" : t;
  }
  /**
   * Serializes the BCF Topic instance into an XML string representation based on the official schema.
   *
   * @remarks
   * This method constructs an XML string based on the properties of the BCF Topic instance.
   * It includes the topic's guid, type, status, creation date, creation author, priority, index,
   * modified date, modified author, due date, assigned to, description, stage, labels, related topics,
   * comments, and viewpoints.
   *
   * @returns A string representing the XML serialization of the BCF Topic.
   *
   * @example
   * ```typescript
   * const topic = bcfTopics.create(); // Created with an instance of BCFTopics
   * const xml = topic.serialize();
   * console.log(xml);
   * ```
   */
  serialize() {
    const s = this._managerVersion;
    let t = null;
    this.serverAssignedId && (t = `ServerAssignedId="${this.serverAssignedId}"`);
    let e = null;
    this.priority && (e = `<Priority>${this.priority}</Priority>`);
    let i = null;
    this.index && s === "2.1" && (i = `<Index>${this.index}</Index>`);
    let n = null;
    this.modifiedDate && (n = `<ModifiedDate>${this.modifiedDate.toISOString()}</ModifiedDate>`);
    let r = null;
    this.modifiedAuthor && (r = `<ModifiedAuthor>${this.modifiedAuthor}</ModifiedAuthor>`);
    let o = null;
    this.dueDate && (o = `<DueDate>${this.dueDate.toISOString()}</DueDate>`);
    let a = null;
    this.assignedTo && (a = `<AssignedTo>${this.assignedTo}</AssignedTo>`);
    let l = null;
    this.description && (l = `<Description>${this.description}</Description>`);
    let h = null;
    this.stage && (h = `<Stage>${this.stage}</Stage>`);
    const d = this.createCommentTags(s), u = this.createViewpointTags(s), f = this.createLabelTags(s), E = this.createRelatedTopicTags(s);
    return `
      <?xml version="1.0" encoding="UTF-8"?>
      <Markup>
        <Topic Guid="${this.guid}" TopicType="${this.type}" TopicStatus="${this.status}" ${t ?? ""}>
          <Title>${this.title}</Title>
          <CreationDate>${this.creationDate.toISOString()}</CreationDate>
          <CreationAuthor>${this.creationAuthor}</CreationAuthor>
          ${e ?? ""}
          ${i ?? ""}
          ${n ?? ""}
          ${r ?? ""}
          ${o ?? ""}
          ${a ?? ""}
          ${l ?? ""}
          ${h ?? ""}
          ${f}
          ${E}
          ${s === "3" ? d : ""}
          ${s === "3" ? u : ""}
        </Topic>
        ${s === "2.1" ? d : ""}
        ${s === "2.1" ? u : ""}
      </Markup>
    `;
  }
};
/**
 * Default values for a BCF Topic, excluding `guid`, `creationDate`, and `creationAuthor`.
 */
T(ce, "default", {
  title: "BCF Topic",
  type: "Issue",
  status: "Active",
  labels: /* @__PURE__ */ new Set()
});
let di = ce;
const Fl = (c, s) => {
  if (s.trim() === "")
    return;
  const t = Lt.xmlParser.parse(s).Extensions;
  if (!t)
    return;
  const { Priorities: e, TopicStatuses: i, TopicTypes: n, Users: r } = t;
  if (e && e.Priority) {
    const o = Array.isArray(e.Priority) ? e.Priority : [e.Priority];
    for (const a of o)
      c.config.priorities.add(a);
  }
  if (i && i.TopicStatus) {
    const o = Array.isArray(i.TopicStatus) ? i.TopicStatus : [i.TopicStatus];
    for (const a of o)
      c.config.statuses.add(a);
  }
  if (n && n.TopicType) {
    const o = Array.isArray(n.TopicType) ? n.TopicType : [n.TopicType];
    for (const a of o)
      c.config.types.add(a);
  }
  if (r && r.User) {
    const o = Array.isArray(r.User) ? r.User : [r.User];
    for (const a of o)
      c.config.users.add(a);
  }
}, Le = class Le extends St {
  constructor() {
    super(...arguments);
    T(this, "enabled", !1);
    T(this, "config", {
      author: "jhon.doe@example.com",
      version: "2.1",
      types: /* @__PURE__ */ new Set([
        "Clash",
        "Failure",
        "Fault",
        "Inquiry",
        "Issue",
        "Remark",
        "Request"
      ]),
      statuses: /* @__PURE__ */ new Set(["Active", "In Progress", "Done", "In Review", "Closed"]),
      priorities: /* @__PURE__ */ new Set(["On hold", "Minor", "Normal", "Major", "Critical"]),
      labels: /* @__PURE__ */ new Set(),
      stages: /* @__PURE__ */ new Set(),
      users: /* @__PURE__ */ new Set(),
      includeSelectionTag: !1,
      updateExtensionsOnImport: !0,
      strict: !1,
      includeAllExtensionsOnExport: !0,
      fallbackVersionOnImport: "2.1",
      ignoreIncompleteTopicsOnImport: !1
    });
    T(this, "list", new Ee());
    T(this, "onSetup", new j());
    T(this, "isSetup", !1);
    T(this, "onBCFImported", new j());
    T(this, "onDisposed", new j());
  }
  setup(t) {
    this.isSetup || (this.config = { ...this.config, ...t }, this.isSetup = !0, this.enabled = !0, this.onSetup.trigger());
  }
  /**
   * Creates a new BCFTopic instance and adds it to the list.
   *
   * @param data - Optional partial BCFTopic object to initialize the new topic with.
   * If not provided, default values will be used.
   * @returns The newly created BCFTopic instance.
   */
  create(t) {
    const e = new di(this.components);
    return t && (e.guid = t.guid ?? e.guid, e.set(t)), this.list.set(e.guid, e), e;
  }
  /**
   * Disposes of the BCFTopics component and triggers the onDisposed event.
   *
   * @remarks
   * This method clears the list of topics and triggers the onDisposed event.
   * It also resets the onDisposed event listener.
   */
  dispose() {
    this.list.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Retrieves the unique set of topic types used across all topics.
   *
   * @returns A Set containing the unique topic types.
   */
  get usedTypes() {
    const t = [...this.list].map(([e, i]) => i.type);
    return new Set(t);
  }
  /**
   * Retrieves the unique set of topic statuses used across all topics.
   *
   * @returns A Set containing the unique topic statuses.
   */
  get usedStatuses() {
    const t = [...this.list].map(([e, i]) => i.status);
    return new Set(t);
  }
  /**
   * Retrieves the unique set of topic priorities used across all topics.
   *
   * @returns A Set containing the unique topic priorities.
   * Note: This method filters out any null or undefined priorities.
   */
  get usedPriorities() {
    const t = [...this.list].map(([e, i]) => i.priority).filter((e) => e);
    return new Set(t);
  }
  /**
   * Retrieves the unique set of topic stages used across all topics.
   *
   * @returns A Set containing the unique topic stages.
   * Note: This method filters out any null or undefined stages.
   */
  get usedStages() {
    const t = [...this.list].map(([e, i]) => i.stage).filter((e) => e);
    return new Set(t);
  }
  /**
   * Retrieves the unique set of users associated with topics.
   *
   * @returns A Set containing the unique users.
   * Note: This method collects users from the creation author, assigned to, modified author, and comment authors.
   */
  get usedUsers() {
    const t = [];
    for (const [e, i] of this.list) {
      t.push(i.creationAuthor), i.assignedTo && t.push(i.assignedTo), i.modifiedAuthor && t.push(i.modifiedAuthor);
      for (const [n, r] of i.comments)
        t.push(r.author), r.modifiedAuthor && t.push(r.modifiedAuthor);
    }
    return new Set(t);
  }
  /**
   * Retrieves the unique set of labels used across all topics.
   *
   * @returns A Set containing the unique labels.
   */
  get usedLabels() {
    const t = [];
    for (const [e, i] of this.list)
      t.push(...i.labels);
    return new Set(t);
  }
  /**
   * Updates the set of extensions (types, statuses, priorities, labels, stages, users) based on the current topics.
   * This method iterates through each topic in the list and adds its properties to the corresponding sets in the config.
   */
  updateExtensions() {
    for (const [t, e] of this.list) {
      for (const i of e.labels)
        this.config.labels.add(i);
      this.config.types.add(e.type), e.priority && this.config.priorities.add(e.priority), e.stage && this.config.stages.add(e.stage), this.config.statuses.add(e.status), this.config.users.add(e.creationAuthor), e.assignedTo && this.config.users.add(e.assignedTo), e.modifiedAuthor && this.config.users.add(e.modifiedAuthor);
      for (const [i, n] of e.comments)
        this.config.users.add(n.author), n.modifiedAuthor && this.config.users.add(n.modifiedAuthor);
    }
  }
  /**
   * Updates the references to viewpoints in the topics.
   * This function iterates through each topic and checks if the viewpoints exist in the viewpoints list.
   * If a viewpoint does not exist, it is removed from the topic's viewpoints.
   */
  updateViewpointReferences() {
    const t = this.components.get(te);
    for (const [e, i] of this.list)
      for (const n of i.viewpoints)
        t.list.has(n) || i.viewpoints.delete(n);
  }
  /**
   * Exports the given topics to a BCF (Building Collaboration Format) zip file.
   *
   * @param topics - The topics to export. Defaults to all topics in the list.
   * @returns A promise that resolves to a Blob containing the exported BCF zip file.
   */
  async export(t = this.list.values()) {
    const e = new Cr();
    e.file(
      "bcf.version",
      `<?xml version="1.0" encoding="UTF-8"?>
    <Version VersionId="${this.config.version}" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/buildingSMART/BCF-XML/release_3_0/Schemas/version.xsd"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    </Version>`
    ), e.file("bcf.extensions", this.serializeExtensions());
    const n = await (await fetch(
      "https://thatopen.github.io/engine_components/resources/favicon.ico"
    )).blob(), r = this.components.get(te);
    for (const a of t) {
      const l = e.folder(a.guid);
      l.file("markup.bcf", a.serialize());
      for (const h of a.viewpoints) {
        const d = r.list.get(h);
        d && (l.file(`${h}.jpeg`, n, {
          binary: !0
        }), l.file(`${h}.bcfv`, await d.serialize()));
      }
    }
    return await e.generateAsync({ type: "blob" });
  }
  serializeExtensions() {
    const t = [...this.config.types].map((a) => `<TopicType>${a}</TopicType>`).join(`
`), e = [...this.config.statuses].map((a) => `<TopicStatus>${a}</TopicStatus>`).join(`
`), i = [...this.config.priorities].map((a) => `<Priority>${a}</Priority>`).join(`
`), n = [...this.config.labels].map((a) => `<TopicLabel>${a}</TopicLabel>`).join(`
`), r = [...this.config.stages].map((a) => `<Stage>${a}</Stage>`).join(`
`), o = [...this.config.users].map((a) => `<User>${a}</User>`).join(`
`);
    return `
      <?xml version="1.0" encoding="UTF-8"?>
      <Extensions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="your-schema-location.xsd">
        ${t.length !== 0 ? `<TopicTypes>
${t}
</TopicTypes>` : ""}
        ${e.length !== 0 ? `<TopicStatuses>
${e}
</TopicStatuses>` : ""}
        ${i.length !== 0 ? `<Priorities>
${i}
</Priorities>` : ""}
        ${n.length !== 0 ? `<TopicLabels>
${n}
</TopicLabels>` : ""}
        ${r.length !== 0 ? `<Stages>
${r}
</Stages>` : ""}
        ${o.length !== 0 ? `<Users>
${o}
</Users>` : ""}
      </Extensions>
    `;
  }
  processMarkupComment(t) {
    const {
      Guid: e,
      Date: i,
      Author: n,
      Comment: r,
      Viewpoint: o
    } = t;
    if (!(e && i && n && (En || o)))
      return null;
    const a = this.components.get(te), l = new En(this.components, r ?? "");
    return l.guid = e, l.date = new Date(i), l.author = n, l.viewpoint = o != null && o.Guid ? a.list.get(o.Guid) : void 0, l.modifiedAuthor = t.ModifiedAuthor, l.modifiedDate = t.ModifiedDate ? new Date(t.ModifiedDate) : void 0, l;
  }
  getMarkupComments(t, e) {
    var o;
    let i;
    if (e === "2.1" && (i = t.Comment), e === "3" && (i = (o = t.Topic.Comments) == null ? void 0 : o.Comment), !i)
      return [];
    i = Array.isArray(i) ? i : [i];
    const n = i.map((a) => this.processMarkupComment(a)).filter((a) => a);
    return Array.isArray(n) ? n : [n];
  }
  getMarkupLabels(t, e) {
    var r;
    let i;
    return e === "2.1" && (i = t.Topic.Labels), e === "3" && (i = (r = t.Topic.Labels) == null ? void 0 : r.Label), i ? Array.isArray(i) ? i : [i] : [];
  }
  getMarkupViewpoints(t, e) {
    var n;
    let i;
    return e === "2.1" && (i = t.Viewpoints), e === "3" && (i = (n = t.Topic.Viewpoints) == null ? void 0 : n.ViewPoint), i ? (i = Array.isArray(i) ? i : [i], i) : [];
  }
  getMarkupRelatedTopics(t, e) {
    var r;
    let i;
    return e === "2.1" && (i = t.Topic.RelatedTopic), e === "3" && (i = (r = t.Topic.RelatedTopics) == null ? void 0 : r.RelatedTopic), i ? (Array.isArray(i) ? i : [i]).map((o) => o.Guid) : [];
  }
  /**
   * Loads BCF (Building Collaboration Format) data into the engine.
   *
   * @param world - The default world where the viewpoints are going to be created.
   * @param data - The BCF data to load.
   *
   * @returns A promise that resolves to an object containing the created viewpoints and topics.
   *
   * @throws An error if the BCF version is not supported.
   */
  async load(t, e) {
    var C;
    const {
      fallbackVersionOnImport: i,
      ignoreIncompleteTopicsOnImport: n,
      updateExtensionsOnImport: r
    } = this.config, o = new Cr();
    await o.loadAsync(t);
    const a = Object.values(o.files);
    let l = i;
    const h = a.find((R) => R.name.endsWith(".version"));
    if (h) {
      const R = await h.async("string"), g = Le.xmlParser.parse(R).Version.VersionId;
      l = String(g);
    }
    if (!(l && (l === "2.1" || l === "3")))
      throw new Error(`BCFTopics: ${l} is not supported.`);
    const d = a.find(
      (R) => R.name.endsWith(".extensions")
    );
    if (r && d) {
      const R = await d.async("string");
      Fl(this, R);
    }
    const u = [], f = this.components.get(te), E = a.filter((R) => R.name.endsWith(".bcfv"));
    for (const R of E) {
      const g = await R.async("string"), y = Le.xmlParser.parse(g).VisualizationInfo;
      if (!y) {
        console.warn("Missing VisualizationInfo in Viewpoint");
        continue;
      }
      const F = {}, {
        Guid: S,
        ClippingPlanes: L,
        Components: N,
        OrthogonalCamera: x,
        PerspectiveCamera: k
      } = y;
      if (S && (F.guid = S), N) {
        const { Selection: P, Visibility: _ } = N;
        if (P && P.Component) {
          const Q = Array.isArray(P.Component) ? P.Component : [P.Component];
          F.selectionComponents = Q.map((V) => V.IfcGuid).filter((V) => V);
        }
        if (_ && "DefaultVisibility" in _ && (F.defaultVisibility = _.DefaultVisibility), _ && _.Exceptions && "Component" in _.Exceptions) {
          const { Component: Q } = _.Exceptions, V = Array.isArray(Q) ? Q : [Q];
          F.exceptionComponents = V.map((et) => et.IfcGuid).filter((et) => et);
        }
        let v;
        l === "2.1" && (v = N.ViewSetupHints), l === "3" && (v = (C = N.Visibility) == null ? void 0 : C.ViewSetupHints), v && ("OpeningsVisible" in v && (F.openingsVisible = v.OpeningsVisible), "SpacesVisible" in v && (F.spacesVisible = v.SpacesVisible), "SpaceBoundariesVisible" in v && (F.spaceBoundariesVisible = v.SpaceBoundariesVisible));
      }
      if (x || k) {
        const P = y.PerspectiveCamera ?? y.OrthogonalCamera, { CameraViewPoint: _, CameraDirection: v } = P, Q = new M.Vector3(
          Number(_.X),
          Number(_.Z),
          Number(-_.Y)
        ), V = new M.Vector3(
          Number(v.X),
          Number(v.Z),
          Number(-v.Y)
        ), et = {
          position: { x: Q.x, y: Q.y, z: Q.z },
          direction: { x: V.x, y: V.y, z: V.z },
          aspectRatio: "AspectRatio" in P ? P.AspectRatio : 1
          // Temporal simplification
        };
        "ViewToWorldScale" in P && (F.camera = {
          ...et,
          viewToWorldScale: P.ViewToWorldScale
        }), "FieldOfView" in P && (F.camera = {
          ...et,
          fov: P.FieldOfView
        });
      }
      const w = new Kr(this.components, e, {
        data: F,
        setCamera: !1
      });
      if (N) {
        const { Coloring: P } = N;
        if (P && P.Color) {
          const _ = Array.isArray(P.Color) ? P.Color : [P.Color];
          for (const v of _) {
            const { Color: Q, Component: V } = v, H = (Array.isArray(V) ? V : [V]).map((nt) => nt.IfcGuid);
            w.componentColors.set(Q, H);
          }
        }
      }
      if (u.push(w), L) {
        const P = this.components.get(ln), _ = Array.isArray(L.ClippingPlane) ? L.ClippingPlane : [L.ClippingPlane];
        for (const v of _) {
          const { Location: Q, Direction: V } = v;
          if (!(Q && V))
            continue;
          const et = new M.Vector3(
            Q.X,
            Q.Z,
            -Q.Y
          ), H = new M.Vector3(
            V.X,
            -V.Z,
            V.Y
          ), nt = P.createFromNormalAndCoplanarPoint(
            e,
            H,
            et
          );
          nt.visible = !1, nt.enabled = !1, w.clippingPlanes.add(nt);
        }
      }
    }
    const p = {}, I = [], m = a.filter((R) => R.name.endsWith(".bcf"));
    for (const R of m) {
      const g = await R.async("string"), y = Le.xmlParser.parse(g).Markup, F = y.Topic, {
        Guid: S,
        TopicType: L,
        TopicStatus: N,
        Title: x,
        CreationDate: k,
        CreationAuthor: w
      } = F;
      if (n && !(S && L && N && x && k && w))
        continue;
      const P = new di(this.components);
      P.guid = S ?? P.guid;
      const _ = this.getMarkupRelatedTopics(y, l);
      p[P.guid] = new Set(_), P.type = L ?? P.type, P.status = N ?? P.status, P.title = x ?? P.title, P.creationDate = k ? new Date(k) : P.creationDate, P.creationAuthor = w ?? P.creationAuthor, P.serverAssignedId = F.ServerAssignedId, P.priority = F.Priority, P.index = F.Index, P.modifiedDate = F.ModifiedDate ? new Date(F.ModifiedDate) : void 0, P.modifiedAuthor = F.ModifiedAuthor, P.dueDate = F.DueDate ? new Date(F.DueDate) : void 0, P.assignedTo = F.AssignedTo, P.description = F.Description, P.stage = F.Stage;
      const v = this.getMarkupLabels(y, l);
      for (const et of v)
        P.labels.add(et);
      const Q = this.getMarkupComments(y, l);
      for (const et of Q)
        P.comments.set(et.guid, et);
      const V = this.getMarkupViewpoints(y, l);
      for (const et of V) {
        if (!(et && et.Guid))
          continue;
        const H = f.list.get(et.Guid);
        H && P.viewpoints.add(H.guid);
      }
      this.list.set(P.guid, P), I.push(P);
    }
    for (const R in p) {
      const g = this.list.get(R);
      if (!g)
        continue;
      const y = p[R];
      for (const F of y)
        g.relatedTopics.add(F);
    }
    return this.onBCFImported.trigger(I), { viewpoints: u, topics: I };
  }
};
T(Le, "uuid", "de977976-e4f6-4e4f-a01a-204727839802"), T(Le, "xmlParser", new wl.XMLParser({
  allowBooleanAttributes: !0,
  attributeNamePrefix: "",
  ignoreAttributes: !1,
  ignoreDeclaration: !0,
  ignorePiTags: !0,
  numberParseOptions: { leadingZeros: !0, hex: !0 },
  parseAttributeValue: !0,
  preserveOrder: !1,
  processEntities: !1,
  removeNSPrefix: !0,
  trimValues: !0
}));
let Lt = Le;
const Jt = class Jt extends St {
  constructor(t) {
    super(t);
    /** {@link Component.enabled} */
    T(this, "enabled", !0);
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    T(this, "_absoluteMin");
    T(this, "_absoluteMax");
    T(this, "_meshes", []);
    this.components.add(Jt.uuid, this), this._absoluteMin = Jt.newBound(!0), this._absoluteMax = Jt.newBound(!1);
  }
  /**
   * A static method to calculate the dimensions of a given bounding box.
   *
   * @param bbox - The bounding box to calculate the dimensions for.
   * @returns An object containing the width, height, depth, and center of the bounding box.
   */
  static getDimensions(t) {
    const { min: e, max: i } = t, n = Math.abs(i.x - e.x), r = Math.abs(i.y - e.y), o = Math.abs(i.z - e.z), a = new M.Vector3();
    return a.subVectors(i, e).divideScalar(2).add(e), { width: n, height: r, depth: o, center: a };
  }
  /**
   * A static method to create a new bounding box boundary.
   *
   * @param positive - A boolean indicating whether to create a boundary for positive or negative values.
   * @returns A new THREE.Vector3 representing the boundary.
   *
   * @remarks
   * This method is used to create a new boundary for calculating bounding boxes.
   * It sets the x, y, and z components of the returned vector to positive or negative infinity,
   * depending on the value of the `positive` parameter.
   *
   * @example
   * ```typescript
   * const positiveBound = BoundingBoxer.newBound(true);
   * console.log(positiveBound); // Output: Vector3 { x: Infinity, y: Infinity, z: Infinity }
   *
   * const negativeBound = BoundingBoxer.newBound(false);
   * console.log(negativeBound); // Output: Vector3 { x: -Infinity, y: -Infinity, z: -Infinity }
   * ```
   */
  static newBound(t) {
    const e = t ? 1 : -1;
    return new M.Vector3(
      e * Number.MAX_VALUE,
      e * Number.MAX_VALUE,
      e * Number.MAX_VALUE
    );
  }
  /**
   * A static method to calculate the bounding box of a set of points.
   *
   * @param points - An array of THREE.Vector3 representing the points.
   * @param min - An optional THREE.Vector3 representing the minimum bounds. If not provided, it will be calculated.
   * @param max - An optional THREE.Vector3 representing the maximum bounds. If not provided, it will be calculated.
   * @returns A THREE.Box3 representing the bounding box of the given points.
   *
   * @remarks
   * This method calculates the bounding box of a set of points by iterating through each point and updating the minimum and maximum bounds accordingly.
   * If the `min` or `max` parameters are provided, they will be used as the initial bounds. Otherwise, the initial bounds will be set to positive and negative infinity.
   *
   * @example
   * ```typescript
   * const points = [
   *   new THREE.Vector3(1, 2, 3),
   *   new THREE.Vector3(4, 5, 6),
   *   new THREE.Vector3(7, 8, 9),
   * ];
   *
   * const bbox = BoundingBoxer.getBounds(points);
   * console.log(bbox); // Output: Box3 { min: Vector3 { x: 1, y: 2, z: 3 }, max: Vector3 { x: 7, y: 8, z: 9 } }
   * ```
   */
  static getBounds(t, e, i) {
    const n = i || this.newBound(!1), r = e || this.newBound(!0);
    for (const o of t)
      o.x < r.x && (r.x = o.x), o.y < r.y && (r.y = o.y), o.z < r.z && (r.z = o.z), o.x > n.x && (n.x = o.x), o.y > n.y && (n.y = o.y), o.z > n.z && (n.z = o.z);
    return new M.Box3(e, i);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    const t = this.components.get(Fe);
    for (const e of this._meshes)
      t.destroy(e);
    this._meshes = [], this.onDisposed.trigger(Jt.uuid), this.onDisposed.reset();
  }
  /**
   * Returns the bounding box of the calculated fragments.
   *
   * @returns A new THREE.Box3 instance representing the bounding box.
   *
   * @remarks
   * This method clones the internal minimum and maximum vectors and returns a new THREE.Box3 instance.
   * The returned box represents the bounding box of the calculated fragments.
   *
   * @example
   * ```typescript
   * const boundingBox = boundingBoxer.get();
   * console.log(boundingBox); // Output: Box3 { min: Vector3 { x: -10, y: -10, z: -10 }, max: Vector3 { x: 10, y: 10, z: 10 } }
   * ```
   */
  get() {
    const t = this._absoluteMin.clone(), e = this._absoluteMax.clone();
    return new M.Box3(t, e);
  }
  /**
   * Calculates and returns a sphere that encompasses the entire bounding box.
   *
   * @returns A new THREE.Sphere instance representing the calculated sphere.
   *
   * @remarks
   * This method calculates the center and radius of a sphere that encompasses the entire bounding box.
   * The center is calculated as the midpoint between the minimum and maximum bounds of the bounding box.
   * The radius is calculated as the distance from the center to the minimum bound.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * const boundingSphere = boundingBoxer.getSphere();
   * console.log(boundingSphere); // Output: Sphere { center: Vector3 { x: 0, y: 0, z: 0 }, radius: 10 }
   * ```
   */
  getSphere() {
    const t = this._absoluteMin.clone(), e = this._absoluteMax.clone(), i = Math.abs((e.x - t.x) / 2), n = Math.abs((e.y - t.y) / 2), r = Math.abs((e.z - t.z) / 2), o = new M.Vector3(t.x + i, t.y + n, t.z + r), a = o.distanceTo(t);
    return new M.Sphere(o, a);
  }
  /**
   * Returns a THREE.Mesh instance representing the bounding box.
   *
   * @returns A new THREE.Mesh instance representing the bounding box.
   *
   * @remarks
   * This method calculates the dimensions of the bounding box using the `getDimensions` method.
   * It then creates a new THREE.BoxGeometry with the calculated dimensions.
   * A new THREE.Mesh is created using the box geometry, and it is added to the `_meshes` array.
   * The position of the mesh is set to the center of the bounding box.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * const boundingBoxMesh = boundingBoxer.getMesh();
   * scene.add(boundingBoxMesh);
   * ```
   */
  getMesh() {
    const t = new M.Box3(this._absoluteMin, this._absoluteMax), e = Jt.getDimensions(t), { width: i, height: n, depth: r, center: o } = e, a = new M.BoxGeometry(i, n, r), l = new M.Mesh(a);
    return this._meshes.push(l), l.position.copy(o), l;
  }
  /**
   * Resets the internal minimum and maximum vectors to positive and negative infinity, respectively.
   * This method is used to prepare the BoundingBoxer for a new set of fragments.
   *
   * @remarks
   * This method is called when a new set of fragments is added to the BoundingBoxer.
   * It ensures that the bounding box calculations are accurate and up-to-date.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * // ...
   * boundingBoxer.reset();
   * ```
   */
  reset() {
    this._absoluteMin = Jt.newBound(!0), this._absoluteMax = Jt.newBound(!1);
  }
  /**
   * Adds a FragmentsGroup to the BoundingBoxer.
   *
   * @param group - The FragmentsGroup to add.
   *
   * @remarks
   * This method iterates through each fragment in the provided FragmentsGroup,
   * and calls the `addMesh` method for each fragment's mesh.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * ```
   */
  add(t) {
    for (const e of t.items)
      this.addMesh(e.mesh);
  }
  /**
   * Adds a mesh to the BoundingBoxer and calculates the bounding box.
   *
   * @param mesh - The mesh to add. It can be an instance of THREE.InstancedMesh, THREE.Mesh, or FRAGS.CurveMesh.
   * @param itemIDs - An optional iterable of numbers representing the item IDs.
   *
   * @remarks
   * This method calculates the bounding box of the provided mesh and updates the internal minimum and maximum vectors.
   * If the mesh is an instance of THREE.InstancedMesh, it calculates the bounding box for each instance.
   * If the mesh is an instance of FRAGS.FragmentMesh and itemIDs are provided, it calculates the bounding box for the specified item IDs.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.addMesh(mesh);
   * ```
   */
  addMesh(t, e) {
    if (!t.geometry.index)
      return;
    const i = Jt.getFragmentBounds(t);
    t.updateMatrixWorld();
    const n = t.matrixWorld, r = new M.Matrix4(), o = t instanceof M.InstancedMesh, a = /* @__PURE__ */ new Set();
    if (t instanceof ye.FragmentMesh) {
      e || (e = t.fragment.ids);
      for (const l of e) {
        const h = t.fragment.getInstancesIDs(l);
        if (h)
          for (const d of h)
            a.add(d);
      }
    } else
      a.add(0);
    for (const l of a) {
      const h = i.min.clone(), d = i.max.clone();
      o && (t.getMatrixAt(l, r), h.applyMatrix4(r), d.applyMatrix4(r)), h.applyMatrix4(n), d.applyMatrix4(n), h.x < this._absoluteMin.x && (this._absoluteMin.x = h.x), h.y < this._absoluteMin.y && (this._absoluteMin.y = h.y), h.z < this._absoluteMin.z && (this._absoluteMin.z = h.z), h.x > this._absoluteMax.x && (this._absoluteMax.x = h.x), h.y > this._absoluteMax.y && (this._absoluteMax.y = h.y), h.z > this._absoluteMax.z && (this._absoluteMax.z = h.z), d.x > this._absoluteMax.x && (this._absoluteMax.x = d.x), d.y > this._absoluteMax.y && (this._absoluteMax.y = d.y), d.z > this._absoluteMax.z && (this._absoluteMax.z = d.z), d.x < this._absoluteMin.x && (this._absoluteMin.x = d.x), d.y < this._absoluteMin.y && (this._absoluteMin.y = d.y), d.z < this._absoluteMin.z && (this._absoluteMin.z = d.z);
    }
  }
  /**
   * Uses a FragmentIdMap to add its meshes to the bb calculation.
   *
   * This method iterates through the provided `fragmentIdMap`, retrieves the corresponding fragment from the `FragmentsManager`,
   * and then calls the `addMesh` method for each fragment's mesh, passing the expression IDs as the second parameter.
   *
   * @param fragmentIdMap - A mapping of fragment IDs to their corresponding expression IDs.
   *
   * @remarks
   * This method is used to add a mapping of fragment IDs to their corresponding expression IDs.
   * It ensures that the bounding box calculations are accurate and up-to-date by updating the internal minimum and maximum vectors.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * const fragmentIdMap: FRAGS.FragmentIdMap = {
   *   '5991fa75-2eef-4825-90b3-85177f51a9c9': [123, 245, 389],
   *   '3469077e-39bf-4fc9-b3e6-4a1d78ad52b0': [454, 587, 612],
   * };
   * boundingBoxer.addFragmentIdMap(fragmentIdMap);
   * ```
   */
  addFragmentIdMap(t) {
    const e = this.components.get(_t);
    for (const i in t) {
      const n = e.list.get(i);
      if (!n)
        continue;
      const r = t[i];
      this.addMesh(n.mesh, r);
    }
  }
  static getFragmentBounds(t) {
    const e = t.geometry.attributes.position, i = Number.MAX_VALUE, n = -i, r = new M.Vector3(i, i, i), o = new M.Vector3(n, n, n);
    if (!t.geometry.index)
      throw new Error("Geometry must be indexed!");
    const a = Array.from(t.geometry.index.array);
    for (let l = 0; l < a.length; l++) {
      if (l % 3 === 0 && a[l] === 0 && a[l + 1] === 0 && a[l + 2] === 0) {
        l += 2;
        continue;
      }
      const h = a[l], d = e.getX(h), u = e.getY(h), f = e.getZ(h);
      d < r.x && (r.x = d), u < r.y && (r.y = u), f < r.z && (r.z = f), d > o.x && (o.x = d), u > o.y && (o.y = u), f > o.z && (o.z = f);
    }
    return new M.Box3(r, o);
  }
};
T(Jt, "uuid", "d1444724-dba6-4cdd-a0c7-68ee1450d166");
let mn = Jt;
const gi = class gi extends St {
  constructor(t) {
    super(t);
    /** {@link Component.enabled} */
    T(this, "enabled", !0);
    /**
     * A map representing the classification systems.
     * The key is the system name, and the value is an object representing the classes within the system.
     */
    T(this, "list", {});
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    T(this, "onFragmentsDisposed", (t) => {
      const { groupID: e, fragmentIDs: i } = t;
      for (const n in this.list) {
        const r = this.list[n], o = Object.keys(r);
        if (o.includes(e))
          delete r[e], Object.values(r).length === 0 && delete this.list[n];
        else
          for (const a of o) {
            const l = r[a];
            for (const h of i)
              delete l.map[h];
            Object.values(l).length === 0 && delete r[a];
          }
      }
    });
    t.add(gi.uuid, this), t.get(_t).onFragmentsDisposed.add(this.onFragmentsDisposed);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.list = {}, this.components.get(_t).onFragmentsDisposed.remove(this.onFragmentsDisposed), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Removes a fragment from the classification based on its unique identifier (guid).
   * This method iterates through all classification systems and classes, and deletes the fragment with the specified guid from the respective group.
   *
   * @param guid - The unique identifier of the fragment to be removed.
   */
  remove(t) {
    for (const e in this.list) {
      const i = this.list[e];
      for (const n in i) {
        const r = i[n];
        delete r.map[t];
      }
    }
  }
  /**
   * Finds and returns fragments based on the provided filter criteria.
   * If no filter is provided, it returns all fragments.
   *
   * @param filter - An optional object containing filter criteria.
   * The keys of the object represent the classification system names,
   * and the values are arrays of class names to match.
   *
   * @returns A map of fragment GUIDs to their respective express IDs,
   * where the express IDs are filtered based on the provided filter criteria.
   *
   * @throws Will throw an error if the fragments map is malformed.
   */
  find(t) {
    const e = this.components.get(_t);
    if (!t) {
      const o = {};
      for (const [a, l] of e.list)
        o[a] = new Set(l.ids);
      return o;
    }
    const i = Object.keys(t).length, n = {};
    for (const o in t) {
      const a = t[o];
      if (!this.list[o]) {
        console.warn(`Classification ${o} does not exist.`);
        continue;
      }
      for (const l of a) {
        const h = this.list[o][l];
        if (h)
          for (const d in h.map) {
            n[d] || (n[d] = /* @__PURE__ */ new Map());
            for (const u of h.map[d]) {
              const f = n[d].get(u);
              f === void 0 ? n[d].set(u, 1) : n[d].set(u, f + 1);
            }
          }
      }
    }
    const r = {};
    for (const o in n) {
      const a = n[o];
      for (const [l, h] of a) {
        if (h === void 0)
          throw new Error("Malformed fragments map!");
        h === i && (r[o] || (r[o] = /* @__PURE__ */ new Set()), r[o].add(l));
      }
    }
    return r;
  }
  /**
   * Classifies fragments based on their modelID.
   *
   * @param modelID - The unique identifier of the model to classify fragments by.
   * @param group - The FragmentsGroup containing the fragments to be classified.
   *
   * @remarks
   * This method iterates through the fragments in the provided group,
   * and classifies them based on their modelID.
   * The classification is stored in the `list.models` property,
   * with the modelID as the key and a map of fragment IDs to their respective express IDs as the value.
   *
   */
  byModel(t, e) {
    this.list.models || (this.list.models = {});
    const i = this.list.models;
    i[t] || (i[t] = { map: {}, id: null, name: t });
    const n = i[t];
    for (const [r, o] of e.data) {
      const a = o[0];
      for (const l of a) {
        const h = e.keyFragments.get(l);
        h && (n.map[h] || (n.map[h] = /* @__PURE__ */ new Set()), n.map[h].add(r));
      }
    }
  }
  /**
   * Classifies fragments based on their PredefinedType property.
   *
   * @param group - The FragmentsGroup containing the fragments to be classified.
   *
   * @remarks
   * This method iterates through the properties of the fragments in the provided group,
   * and classifies them based on their PredefinedType property.
   * The classification is stored in the `list.predefinedTypes` property,
   * with the PredefinedType as the key and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found.
   */
  async byPredefinedType(t) {
    var n;
    this.list.predefinedTypes || (this.list.predefinedTypes = {});
    const e = this.list.predefinedTypes, i = t.getAllPropertiesIDs();
    for (const r of i) {
      const o = await t.getProperties(r);
      if (!o)
        continue;
      const a = String((n = o.PredefinedType) == null ? void 0 : n.value).toUpperCase();
      e[a] || (e[a] = {
        map: {},
        id: null,
        name: a
      });
      const l = e[a];
      for (const [h, d] of t.data) {
        const u = d[0];
        for (const f of u) {
          const E = t.keyFragments.get(f);
          if (!E)
            throw new Error("Fragment ID not found!");
          l.map[E] || (l.map[E] = /* @__PURE__ */ new Set()), l.map[E].add(o.expressID);
        }
      }
    }
  }
  /**
   * Classifies fragments based on their entity type.
   *
   * @param group - The FragmentsGroup containing the fragments to be classified.
   *
   * @remarks
   * This method iterates through the relations of the fragments in the provided group,
   * and classifies them based on their entity type.
   * The classification is stored in the `list.entities` property,
   * with the entity type as the key and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found.
   */
  byEntity(t) {
    this.list.entities || (this.list.entities = {});
    for (const [e, i] of t.data) {
      const r = i[1][1], o = zr[r];
      this.saveItem(t, "entities", o, e);
    }
  }
  /**
   * Classifies fragments based on a specific IFC relationship.
   *
   * @param group - The FragmentsGroup containing the fragments to be classified.
   * @param ifcRel - The IFC relationship number to classify fragments by.
   * @param systemName - The name of the classification system to store the classification.
   *
   * @remarks
   * This method iterates through the relations of the fragments in the provided group,
   * and classifies them based on the specified IFC relationship.
   * The classification is stored in the `list` property under the specified system name,
   * with the relationship name as the class name and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found or if the IFC relationship is not valid.
   */
  async byIfcRel(t, e, i) {
    Ke.isRel(e) && await Ke.getRelationMap(
      t,
      e,
      async (n, r) => {
        const { name: o } = await Ke.getEntityName(
          t,
          n
        );
        for (const a of r)
          this.saveItem(
            t,
            i,
            o ?? "NO REL NAME",
            a
          );
      }
    );
  }
  /**
   * Classifies fragments based on their spatial structure in the IFC model.
   *
   * @param model - The FragmentsGroup containing the fragments to be classified.
   * @param config - The configuration for the classifier. It includes "useProperties", which is true by default
   * (if false, the classification will use the expressIDs instead of the names), and "isolate", which will make
   * the classifier just pick the WEBIFC categories provided.
   *
   * @remarks
   * This method iterates through the relations of the fragments in the provided group,
   * and classifies them based on their spatial structure in the IFC model.
   * The classification is stored in the `list` property under the system name "spatialStructures",
   * with the relationship name as the class name and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found or if the model relations do not exist.
   */
  async bySpatialStructure(t, e = {}) {
    var l, h;
    const i = this.components.get(xe), n = i.relationMaps[t.uuid];
    if (!n)
      throw new Error(
        `Classifier: model relations of ${t.name || t.uuid} have to exists to group by spatial structure.`
      );
    const r = "spatialStructures", a = e.useProperties === void 0 || e.useProperties;
    for (const [d] of n) {
      if (e.isolate) {
        const p = t.data.get(d);
        if (!p)
          continue;
        const I = p[1][1];
        if (I === void 0 || !e.isolate.has(I))
          continue;
      }
      const u = i.getEntityRelations(
        t,
        d,
        "Decomposes"
      );
      if (u)
        for (const p of u) {
          let I = p.toString();
          if (a) {
            const m = await t.getProperties(p);
            if (!m)
              continue;
            I = (l = m.Name) == null ? void 0 : l.value;
          }
          this.saveItem(t, r, I, d, p);
        }
      const f = i.getEntityRelations(
        t,
        d,
        "ContainsElements"
      );
      if (!f)
        continue;
      let E = d.toString();
      if (a) {
        const p = await t.getProperties(d);
        if (!p)
          continue;
        E = (h = p.Name) == null ? void 0 : h.value;
      }
      for (const p of f) {
        this.saveItem(t, r, E, p, d);
        const I = i.getEntityRelations(
          t,
          Number(p),
          "IsDecomposedBy"
        );
        if (I)
          for (const m of I)
            this.saveItem(t, r, E, m, d);
      }
    }
  }
  /**
   * Sets the color of the specified fragments.
   *
   * @param items - A map of fragment IDs to their respective express IDs.
   * @param color - The color to set for the fragments.
   * @param override - A boolean indicating whether to override the existing color of the fragments.
   *
   * @remarks
   * This method iterates through the provided fragment IDs, retrieves the corresponding fragments,
   * and sets their color using the `setColor` method of the FragmentsGroup class.
   *
   * @throws Will throw an error if the fragment with the specified ID is not found.
   */
  setColor(t, e, i = !1) {
    const n = this.components.get(_t);
    for (const r in t) {
      const o = n.list.get(r);
      if (!o)
        continue;
      const a = t[r];
      o.setColor(e, a, i);
    }
  }
  /**
   * Resets the color of the specified fragments to their original color.
   *
   * @param items - A map of fragment IDs to their respective express IDs.
   *
   * @remarks
   * This method iterates through the provided fragment IDs, retrieves the corresponding fragments,
   * and resets their color using the `resetColor` method of the FragmentsGroup class.
   *
   * @throws Will throw an error if the fragment with the specified ID is not found.
   */
  resetColor(t) {
    const e = this.components.get(_t);
    for (const i in t) {
      const n = e.list.get(i);
      if (!n)
        continue;
      const r = t[i];
      n.resetColor(r);
    }
  }
  saveItem(t, e, i, n, r = null) {
    this.list[e] || (this.list[e] = {});
    const o = t.data.get(n);
    if (o)
      for (const a of o[0]) {
        const l = t.keyFragments.get(a);
        if (l) {
          const h = this.list[e];
          h[i] || (h[i] = { map: {}, id: r, name: i }), h[i].map[l] || (h[i].map[l] = /* @__PURE__ */ new Set()), h[i].map[l].add(n);
        }
      }
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
T(gi, "uuid", "e25a7f3c-46c4-4a14-9d3d-5115f24ebeb7");
let bs = gi;
const Ci = class Ci extends St {
  constructor(t) {
    super(t);
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    /** {@link Component.enabled} */
    T(this, "enabled", !0);
    /**
     * The height of the explosion animation.
     * This property determines the vertical distance by which fragments are moved during the explosion.
     * Default value is 10.
     */
    T(this, "height", 10);
    /**
     * The group name used for the explosion animation.
     * This property specifies the group of fragments that will be affected by the explosion.
     * Default value is "storeys".
     */
    T(this, "groupName", "spatialStructures");
    /**
     * A set of strings representing the exploded items.
     * This set is used to keep track of which items have been exploded.
     */
    T(this, "list", /* @__PURE__ */ new Set());
    t.add(Ci.uuid, this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.list.clear(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Sets the explosion state of the fragments.
   *
   * @param active - A boolean indicating whether to activate or deactivate the explosion.
   *
   * @remarks
   * This method applies a vertical transformation to the fragments based on the `active` parameter.
   * If `active` is true, the fragments are moved upwards by a distance determined by the `height` property.
   * If `active` is false, the fragments are moved back to their original position.
   *
   * The method also keeps track of the exploded items using the `list` set.
   *
   * @throws Will throw an error if the `Classifier` or `FragmentsManager` components are not found in the `components` system.
   */
  set(t) {
    if (!this.enabled)
      return;
    const e = this.components.get(bs), i = this.components.get(_t), n = t ? 1 : -1;
    let r = 0;
    const o = e.list[this.groupName], a = new M.Matrix4();
    for (const l in o) {
      a.elements[13] = r * n * this.height;
      for (const h in o[l].map) {
        const d = i.list.get(h), u = l + h, f = this.list.has(u);
        if (!d || t && f || !t && !f)
          continue;
        t ? this.list.add(u) : this.list.delete(u);
        const E = o[l].map[h];
        d.applyTransform(E, a), d.mesh.computeBoundingSphere(), d.mesh.computeBoundingBox();
      }
      r++;
    }
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
T(Ci, "uuid", "d260618b-ce88-4c7d-826c-6debb91de3e2");
let wr = Ci;
const Ti = class Ti extends St {
  constructor(t) {
    super(t);
    /** {@link Component.enabled} */
    T(this, "enabled", !0);
    this.components.add(Ti.uuid, this);
  }
  /**
   * Sets the visibility of fragments within the 3D scene.
   * If no `items` parameter is provided, all fragments will be set to the specified visibility.
   * If `items` is provided, only the specified fragments will be affected.
   *
   * @param visible - The visibility state to set for the fragments.
   * @param items - An optional map of fragment IDs and their corresponding sub-fragment IDs to be affected.
   * If not provided, all fragments will be affected.
   *
   * @returns {void}
   */
  set(t, e) {
    const i = this.components.get(_t);
    if (!e) {
      for (const [n, r] of i.list)
        r && (r.setVisibility(t), this.updateCulledVisibility(r));
      return;
    }
    for (const n in e) {
      const r = e[n], o = i.list.get(n);
      o && (o.setVisibility(t, r), this.updateCulledVisibility(o));
    }
  }
  /**
   * Isolates fragments within the 3D scene by hiding all other fragments and showing only the specified ones.
   * It calls the `set` method twice: first to hide all fragments, and then to show only the specified ones.
   *
   * @param items - A map of fragment IDs and their corresponding sub-fragment IDs to be isolated.
   * If not provided, all fragments will be isolated.
   *
   * @returns {void}
   */
  isolate(t) {
    this.set(!1), this.set(!0, t);
  }
  updateCulledVisibility(t) {
    const e = this.components.get(cn);
    for (const [i, n] of e.list) {
      const r = n.colorMeshes.get(t.id);
      r && (r.count = t.mesh.count);
    }
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
T(Ti, "uuid", "dd9ccf2d-8a21-4821-b7f6-2949add16a29");
let In = Ti;
class Sl extends wn {
  constructor() {
    super(...arguments);
    /**
     * Minimum number of geometries to be streamed.
     * Defaults to 10 geometries.
     */
    T(this, "minGeometrySize", 10);
    /**
     * Minimum amount of assets to be streamed.
     * Defaults to 1000 assets.
     */
    T(this, "minAssetsSize", 1e3);
  }
}
const _i = class _i extends St {
  constructor(t) {
    super(t);
    /**
     * Event triggered when geometry is streamed.
     * Contains the streamed geometry data and its buffer.
     */
    T(this, "onGeometryStreamed", new j());
    /**
     * Event triggered when assets are streamed.
     * Contains the streamed assets.
     */
    T(this, "onAssetStreamed", new j());
    /**
     * Event triggered to indicate the progress of the streaming process.
     * Contains the progress percentage.
     */
    T(this, "onProgress", new j());
    /**
     * Event triggered when the IFC file is loaded.
     * Contains the loaded IFC file data.
     */
    T(this, "onIfcLoaded", new j());
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    /**
     * Settings for the IfcGeometryTiler.
     */
    T(this, "settings", new Sl());
    /** {@link Component.enabled} */
    T(this, "enabled", !0);
    /**
     * The WebIFC API instance used for IFC file processing.
     */
    T(this, "webIfc", new X.IfcAPI());
    T(this, "_spatialTree", new kr());
    T(this, "_metaData", new Yr());
    T(this, "_visitedGeometries", /* @__PURE__ */ new Map());
    T(this, "_streamSerializer", new ye.StreamSerializer());
    T(this, "_geometries", /* @__PURE__ */ new Map());
    T(this, "_geometryCount", 0);
    T(this, "_civil", new Vr());
    T(this, "_groupSerializer", new ye.Serializer());
    T(this, "_assets", []);
    T(this, "_meshesWithHoles", /* @__PURE__ */ new Set());
    this.components.add(_i.uuid, this), this.settings.excludedCategories.add(X.IFCOPENINGELEMENT);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.onIfcLoaded.reset(), this.onGeometryStreamed.reset(), this.onAssetStreamed.reset(), this.webIfc = null, this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * This method streams the IFC file from a given buffer.
   *
   * @param data - The Uint8Array containing the IFC file data.
   * @returns A Promise that resolves when the streaming process is complete.
   *
   * @remarks
   * This method cleans up any resources after the streaming process is complete.
   *
   * @example
   * ```typescript
   * const ifcData = await fetch('path/to/ifc/file.ifc');
   * const rawBuffer = await response.arrayBuffer();
   * const ifcBuffer = new Uint8Array(rawBuffer);
   * await ifcGeometryTiler.streamFromBuffer(ifcBuffer);
   * ```
   */
  async streamFromBuffer(t) {
    await this.readIfcFile(t), await this.streamAllGeometries(), this.cleanUp();
  }
  /**
   * This method streams the IFC file from a given callback.
   *
   * @param loadCallback - The callback function that will be used to load the IFC file.
   * @returns A Promise that resolves when the streaming process is complete.
   *
   * @remarks
   * This method cleans up any resources after the streaming process is complete.
   *
   */
  async streamFromCallBack(t) {
    await this.streamIfcFile(t), await this.streamAllGeometries(), this.cleanUp();
  }
  async readIfcFile(t) {
    const { path: e, absolute: i, logLevel: n } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, i), await this.webIfc.Init(), n && this.webIfc.SetLogLevel(n), this.webIfc.OpenModel(t, this.settings.webIfc);
  }
  async streamIfcFile(t) {
    const { path: e, absolute: i, logLevel: n } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, i), await this.webIfc.Init(), n && this.webIfc.SetLogLevel(n), this.webIfc.OpenModelFromCallback(t, this.settings.webIfc);
  }
  async streamAllGeometries() {
    const { minGeometrySize: t, minAssetsSize: e } = this.settings;
    this._spatialTree.setUp(this.webIfc);
    const i = this.webIfc.GetIfcEntityList(0), n = [[]], r = new ye.FragmentsGroup();
    r.ifcMetadata = {
      name: "",
      description: "",
      ...this._metaData.getNameInfo(this.webIfc),
      ...this._metaData.getDescriptionInfo(this.webIfc),
      schema: this.webIfc.GetModelSchema(0) || "IFC2X3",
      maxExpressID: this.webIfc.GetMaxExpressID(0)
    };
    let o = 0, a = 0;
    for (const p of i) {
      if (!this.webIfc.IsIfcElement(p) && p !== X.IFCSPACE || this.settings.excludedCategories.has(p))
        continue;
      const I = this.webIfc.GetLineIDsWithType(0, p), m = I.size();
      for (let C = 0; C < m; C++) {
        o > t && (o = 0, a++, n.push([]));
        const R = I.get(C);
        n[a].push(R);
        const g = this.webIfc.GetLine(0, R);
        if (g.GlobalId) {
          const F = (g == null ? void 0 : g.GlobalId.value) || (g == null ? void 0 : g.GlobalId);
          r.globalToExpressIDs.set(F, R);
        }
        const y = this._spatialTree.itemsByFloor[R] || 0;
        r.data.set(R, [[], [y, p]]), o++;
      }
    }
    this._spatialTree.cleanUp();
    let l = 0.01, h = 0;
    for (const p of n) {
      h++, this.webIfc.StreamMeshes(0, p, (m) => {
        this.getMesh(this.webIfc, m, r);
      }), this._geometryCount > t && await this.streamGeometries(), this._assets.length > e && await this.streamAssets();
      const I = h / n.length;
      I > l && (l += 0.01, l = Math.max(l, I), this.onProgress.trigger(Math.round(l * 100) / 100));
    }
    this._geometryCount && await this.streamGeometries(), this._assets.length && await this.streamAssets();
    const { opaque: d, transparent: u } = r.geometryIDs;
    for (const [p, { index: I, uuid: m }] of this._visitedGeometries)
      r.keyFragments.set(I, m), (p > 1 ? d : u).set(p, I);
    Gr.get(r, this.webIfc);
    const f = this.webIfc.GetCoordinationMatrix(0);
    r.coordinationMatrix.fromArray(f), r.civilData = this._civil.read(this.webIfc);
    const E = this._groupSerializer.export(r);
    this.onIfcLoaded.trigger(E), r.dispose(!0);
  }
  cleanUp() {
    try {
      this.webIfc.Dispose();
    } catch {
    }
    this.webIfc = null, this.webIfc = new X.IfcAPI(), this._visitedGeometries.clear(), this._geometries.clear(), this._assets = [], this._meshesWithHoles.clear();
  }
  getMesh(t, e, i) {
    const n = e.geometries.size(), r = e.expressID, o = { id: r, geometries: [] };
    for (let a = 0; a < n; a++) {
      const l = e.geometries.get(a), h = l.geometryExpressID, d = l.color.w === 1 ? 1 : -1, u = h * d;
      if (!this._visitedGeometries.has(u)) {
        this._visitedGeometries.has(h) || this.getGeometry(t, h);
        const y = this._visitedGeometries.size, F = M.MathUtils.generateUUID();
        this._visitedGeometries.set(u, { uuid: F, index: y });
      }
      const f = this._visitedGeometries.get(u);
      if (f === void 0)
        throw new Error("Error getting geometry data for streaming!");
      const E = i.data.get(r);
      if (!E)
        throw new Error("Data not found!");
      E[0].push(f.index);
      const { x: p, y: I, z: m, w: C } = l.color, R = [p, I, m, C], g = l.flatTransformation;
      o.geometries.push({ color: R, geometryID: h, transformation: g });
    }
    this._assets.push(o);
  }
  getGeometry(t, e) {
    const i = t.GetGeometry(0, e), n = t.GetIndexArray(
      i.GetIndexData(),
      i.GetIndexDataSize()
    ), r = t.GetVertexArray(
      i.GetVertexData(),
      i.GetVertexDataSize()
    ), o = new Float32Array(r.length / 2), a = new Float32Array(r.length / 2);
    for (let f = 0; f < r.length; f += 6)
      o[f / 2] = r[f], o[f / 2 + 1] = r[f + 1], o[f / 2 + 2] = r[f + 2], a[f / 2] = r[f + 3], a[f / 2 + 1] = r[f + 4], a[f / 2 + 2] = r[f + 5];
    const l = ba(o), h = new Float32Array(l.transformation.elements), d = [l.center.x, l.center.y, l.center.z];
    let u = !1;
    for (let f = 0; f < o.length - 2; f += 3) {
      const E = o[f], p = o[f + 1], I = o[f + 2], m = a[f], C = a[f + 1], R = a[f + 2];
      if (Pa(d, [E, p, I], [m, C, R])) {
        u = !0;
        break;
      }
    }
    this._geometries.set(e, {
      position: o,
      normal: a,
      index: n,
      boundingBox: h,
      hasHoles: u
    }), i.delete(), this._geometryCount++;
  }
  async streamAssets() {
    await this.onAssetStreamed.trigger(this._assets), this._assets = null, this._assets = [];
  }
  async streamGeometries() {
    let t = this._streamSerializer.export(this._geometries), e = {};
    for (const [i, { boundingBox: n, hasHoles: r }] of this._geometries)
      e[i] = { boundingBox: n, hasHoles: r };
    this.onGeometryStreamed.trigger({ data: e, buffer: t }), e = null, t = null, this._geometries.clear(), this._geometryCount = 0;
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
T(_i, "uuid", "d9999a00-e1f5-4d3f-8cfe-c56e08609764");
let Fr = _i;
class Ol extends wn {
  constructor() {
    super(...arguments);
    /**
     * Amount of properties to be streamed.
     * Defaults to 100 properties.
     */
    T(this, "propertiesSize", 100);
  }
}
class Nl extends St {
  constructor() {
    super(...arguments);
    /**
     * An event that is triggered when properties are streamed from the IFC file.
     * The event provides the type of the IFC entity and the corresponding data.
     */
    T(this, "onPropertiesStreamed", new oi());
    /**
     * An event that is triggered to indicate the progress of the streaming process.
     * The event provides a number between 0 and 1 representing the progress percentage.
     */
    T(this, "onProgress", new oi());
    /**
     * An event that is triggered when indices are streamed from the IFC file.
     * The event provides a map of indices, where the key is the entity type and the value is another map of indices.
     */
    T(this, "onIndicesStreamed", new oi());
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    /** {@link Component.enabled} */
    T(this, "enabled", !0);
    /**
     * An instance of the PropertiesStreamingSettings class, which holds the settings for the streaming process.
     */
    T(this, "settings", new Ol());
    /**
     * An instance of the IfcAPI class from the Web-IFC library, which provides methods for reading and processing IFC data.
     */
    T(this, "webIfc", new X.IfcAPI());
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    this.onIndicesStreamed.reset(), this.onPropertiesStreamed.reset(), this.webIfc = null, this.onDisposed.reset();
  }
  /**
   * This method converts properties from an IFC file to tiles given its data as a Uint8Array.
   *
   * @param data - The Uint8Array containing the IFC file data.
   * @returns A Promise that resolves when the streaming process is complete.
   */
  async streamFromBuffer(t) {
    await this.readIfcFile(t), await this.streamAllProperties(), this.cleanUp();
  }
  /**
   * This method converts properties from an IFC file to tiles using a given callback function to read the file.
   *
   * @param loadCallback - A callback function that loads the IFC file data.
   * @returns A Promise that resolves when the streaming process is complete.
   */
  async streamFromCallBack(t) {
    await this.streamIfcFile(t), await this.streamAllProperties(), this.cleanUp();
  }
  async readIfcFile(t) {
    const { path: e, absolute: i, logLevel: n } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, i), await this.webIfc.Init(), n && this.webIfc.SetLogLevel(n), this.webIfc.OpenModel(t, this.settings.webIfc);
  }
  async streamIfcFile(t) {
    const { path: e, absolute: i, logLevel: n } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, i), await this.webIfc.Init(), n && this.webIfc.SetLogLevel(n), this.webIfc.OpenModelFromCallback(t, this.settings.webIfc);
  }
  async streamAllProperties() {
    const { propertiesSize: t } = this.settings, e = new Set(this.webIfc.GetIfcEntityList(0)), i = /* @__PURE__ */ new Set([
      X.IFCPROJECT,
      X.IFCSITE,
      X.IFCBUILDING,
      X.IFCBUILDINGSTOREY,
      X.IFCSPACE
    ]);
    for (const l of i)
      e.add(l);
    let n = 0.01, r = 0;
    for (const l of e) {
      if (r++, Hr.has(l))
        continue;
      const h = i.has(l), d = this.webIfc.GetLineIDsWithType(0, l), u = d.size();
      let f = 0;
      for (let p = 0; p < u - t; p += t) {
        const I = {};
        for (let m = 0; m < t; m++) {
          f++;
          const C = d.get(p + m);
          try {
            const R = this.webIfc.GetLine(0, C, h);
            I[R.expressID] = R;
          } catch {
            console.log(`Could not get property: ${C}`);
          }
        }
        await this.onPropertiesStreamed.trigger({ type: l, data: I });
      }
      if (f !== u) {
        const p = {};
        for (let I = f; I < u; I++) {
          const m = d.get(I);
          try {
            const C = this.webIfc.GetLine(0, m, h);
            p[C.expressID] = C;
          } catch {
            console.log(`Could not get property: ${m}`);
          }
        }
        await this.onPropertiesStreamed.trigger({ type: l, data: p });
      }
      r / e.size > n && (n = Math.round(n * 100) / 100, await this.onProgress.trigger(n), n += 0.01);
    }
    await this.onProgress.trigger(1);
    const a = await this.components.get(xe).processFromWebIfc(this.webIfc, 0);
    await this.onIndicesStreamed.trigger(a);
  }
  cleanUp() {
    this.webIfc.Dispose(), this.webIfc = null, this.webIfc = new X.IfcAPI();
  }
}
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
T(Nl, "uuid", "88d2c89c-ce32-47d7-8cb6-d51e4b311a0b");
class Kr {
  constructor(s, t, e) {
    T(this, "title");
    T(this, "guid", me.create());
    /**
     * ClippingPlanes can be used to define a subsection of a building model that is related to the topic.
     * Each clipping plane is defined by Location and Direction.
     * The Direction vector points in the invisible direction meaning the half-space that is clipped.
     * @experimental
     */
    T(this, "clippingPlanes", new qe());
    T(this, "camera", {
      aspectRatio: 0,
      fov: 0,
      direction: { x: 0, y: 0, z: 80 },
      position: { x: 0, y: 0, z: 0 }
    });
    /**
     * A list of components GUIDs to hide when defaultVisibility = true or to show when defaultVisibility = false
     */
    T(this, "exceptionComponents", new qe());
    /**
     * A list of components GUIDs that should be selected (highlighted) when displaying a viewpoint.
     */
    T(this, "selectionComponents", new qe());
    /**
     * A map of colors and components GUIDs that should be colorized when displaying a viewpoint.
     * For this to work, call viewpoint.colorize()
     */
    T(this, "componentColors", new Ee());
    /**
     * Boolean flags to allow fine control over the visibility of spaces.
     * A typical use of these flags is when DefaultVisibility=true but spaces should remain hidden.
     * @default false
     */
    T(this, "spacesVisible", !1);
    /**
     * Boolean flags to allow fine control over the visibility of space boundaries.
     * A typical use of these flags is when DefaultVisibility=true but space boundaries should remain hidden.
     * @default false
     */
    T(this, "spaceBoundariesVisible", !1);
    /**
     * Boolean flags to allow fine control over the visibility of openings.
     * A typical use of these flags is when DefaultVisibility=true but openings should remain hidden.
     * @default false
     */
    T(this, "openingsVisible", !1);
    /**
     * When true, all components should be visible unless listed in the exceptions
     * When false all components should be invisible unless listed in the exceptions
     */
    T(this, "defaultVisibility", !0);
    T(this, "_components");
    /**
     * Represents the world in which the viewpoints are created and managed.
     */
    T(this, "world");
    const i = { setCamera: !0, ...e }, { data: n, setCamera: r } = i;
    this._components = s, this.world = t, n && (this.guid = n.guid ?? this.guid, this.set(n)), r && this.updateCamera();
  }
  get _selectionModelIdMap() {
    const s = this._components.get(_t), t = {};
    for (const [e, i] of s.groups) {
      e in t || (t[e] = /* @__PURE__ */ new Set());
      for (const n of this.selectionComponents) {
        const r = i.globalToExpressIDs.get(n);
        r && t[e].add(r);
      }
    }
    return t;
  }
  get _exceptionModelIdMap() {
    const s = this._components.get(_t), t = {};
    for (const [e, i] of s.groups) {
      e in t || (t[e] = /* @__PURE__ */ new Set());
      for (const n of this.exceptionComponents) {
        const r = i.globalToExpressIDs.get(n);
        r && t[e].add(r);
      }
    }
    return t;
  }
  /**
   * A list of components that should be selected (highlighted) when displaying a viewpoint.
   * @returns The fragmentIdMap for components marked as selections.
   */
  get selection() {
    return this._components.get(_t).modelIdToFragmentIdMap(
      this._selectionModelIdMap
    );
  }
  /**
   * A list of components to hide when defaultVisibility = true or to show when defaultVisibility = false
   * @returns The fragmentIdMap for components marked as exceptions.
   */
  get exception() {
    return this._components.get(_t).modelIdToFragmentIdMap(
      this._exceptionModelIdMap
    );
  }
  /**
   * Retrieves the projection type of the viewpoint's camera.
   *
   * @returns A string representing the projection type of the viewpoint's camera.
   *          It can be either 'Perspective' or 'Orthographic'.
   */
  get projection() {
    return "fov" in this.camera ? "Perspective" : "Orthographic";
  }
  /**
   * Retrieves the position vector of the viewpoint's camera.
   *
   * @remarks
   * The position vector represents the camera's position in the world coordinate system.
   * The function applies the base coordinate system transformation to the position vector.
   *
   * @returns A THREE.Vector3 representing the position of the viewpoint's camera.
   */
  get position() {
    const s = this._components.get(_t), { position: t } = this.camera, { x: e, y: i, z: n } = t, r = new M.Vector3(e, i, n);
    return s.applyBaseCoordinateSystem(r, new M.Matrix4()), r;
  }
  /**
   * Retrieves the direction vector of the viewpoint's camera.
   *
   * @remarks
   * The direction vector represents the direction in which the camera is pointing.
   * It is calculated by extracting the x, y, and z components from the camera's direction property.
   *
   * @returns A THREE.Vector3 representing the direction of the viewpoint's camera.
   */
  get direction() {
    const { direction: s } = this.camera, { x: t, y: e, z: i } = s;
    return new M.Vector3(t, e, i);
  }
  get _managerVersion() {
    return this._components.get(Lt).config.version;
  }
  /**
   * Retrieves the list of BCF topics associated with the current viewpoint.
   *
   * @remarks
   * This function retrieves the BCFTopics manager from the components,
   * then filters the list of topics to find those associated with the current viewpoint.
   *
   * @returns An array of BCF topics associated with the current viewpoint.
   */
  get topics() {
    return [...this._components.get(Lt).list.values()].filter(
      (i) => i.viewpoints.has(this.guid)
    );
  }
  /**
   * Adds components to the viewpoint based on the provided fragment ID map.
   *
   * @param fragmentIdMap - A map containing fragment IDs as keys and arrays of express IDs as values.
   */
  addComponentsFromMap(s) {
    const e = this._components.get(_t).fragmentIdMapToGuids(s);
    this.selectionComponents.add(...e), this._components.get(te).list.set(this.guid, this);
  }
  /**
   * Replace the properties of the viewpoint with the provided data.
   *
   * @remarks The guid will be ommited as it shouldn't change after it has been initially set.
   * @remarks The existing selection and exception components will be fully replaced in case new ones are provided.
   *
   * @param data - An object containing the properties to be set.
   *               The properties not included in the object will remain unchanged.
   *
   * @returns The viewpoint instance with the updated properties.
   */
  set(s) {
    const t = s, e = this;
    for (const n in s) {
      if (n === "guid")
        continue;
      const r = t[n];
      if (n === "selectionComponents") {
        this.selectionComponents.clear(), this.selectionComponents.add(...r);
        continue;
      }
      if (n === "exceptionComponents") {
        this.exceptionComponents.clear(), this.exceptionComponents.add(...r);
        continue;
      }
      n in this && (e[n] = r);
    }
    return this._components.get(te).list.set(this.guid, this), this;
  }
  /**
   * Sets the viewpoint of the camera in the world.
   *
   * @remarks
   * This function calculates the target position based on the viewpoint information.
   * It sets the visibility of the viewpoint components and then applies the viewpoint using the camera's controls.
   *
   * @param transition - Indicates whether the camera movement should have a transition effect.
   *                      Default value is `true`.
   *
   * @throws An error if the world's camera does not have camera controls.
   *
   * @returns A Promise that resolves when the camera has been set.
   */
  async go(s = !0) {
    const { camera: t } = this.world;
    if (!t.hasCameraControls())
      throw new Error(
        "Viewpoint: the world's camera need controls to set the viewpoint."
      );
    t instanceof nc && t.projection.set(this.projection);
    const e = this.position, i = this.direction;
    let n = {
      x: e.x + i.x * 80,
      y: e.y + i.y * 80,
      z: e.z + i.z * 80
    };
    const r = this.selection;
    if (Object.keys(r).length === 0) {
      const h = this._components.get(ts).get(this.world).castRayFromVector(e, this.direction);
      h && (n = h.point);
    } else {
      const a = this._components.get(mn);
      a.reset(), a.addFragmentIdMap(r), n = a.getSphere().center, a.reset();
    }
    const o = this._components.get(In);
    o.set(this.defaultVisibility), o.set(!this.defaultVisibility, this.exception), o.set(!0, r), await t.controls.setLookAt(
      e.x,
      e.y,
      e.z,
      n.x,
      n.y,
      n.z,
      s
    );
  }
  /**
   * Updates the camera settings of the viewpoint based on the current world's camera and renderer.
   *
   * @remarks
   * This function retrieves the camera's position, direction, and aspect ratio from the world's camera and renderer.
   * It then calculates the camera's perspective or orthographic settings based on the camera type.
   * Finally, it updates the viewpoint's camera settings and updates the viewpoint to the Viewpoints manager.
   *
   * @throws An error if the world's camera does not have camera controls.
   * @throws An error if the world's renderer is not available.
   */
  updateCamera() {
    const { camera: s, renderer: t } = this.world;
    if (!t)
      throw new Error("Viewpoint: the world needs to have a renderer!");
    if (!s.hasCameraControls())
      throw new Error("Viewpoint: world's camera need camera controls!");
    const e = new M.Vector3();
    s.controls.getPosition(e);
    const i = s.three, n = new M.Vector3(0, 0, -1).applyEuler(
      i.rotation
    ), { width: r, height: o } = t.getSize();
    let a = r / o;
    Number.isNaN(a) && (a = 1);
    const l = this._components.get(_t);
    e.applyMatrix4(l.baseCoordinationMatrix.clone().invert());
    const h = {
      aspectRatio: a,
      position: { x: e.x, y: e.y, z: e.z },
      direction: { x: n.x, y: n.y, z: n.z }
    };
    i instanceof M.PerspectiveCamera ? this.camera = {
      ...h,
      fov: i.fov
    } : i instanceof M.OrthographicCamera && (this.camera = {
      ...h,
      viewToWorldScale: i.top - i.bottom
    }), this._components.get(te).list.set(this.guid, this);
  }
  /**
   * Applies color to the components in the viewpoint based on their GUIDs.
   *
   * This function iterates through the `componentColors` map, retrieves the fragment IDs
   * corresponding to each color, and then uses the `Classifier` to apply the color to those fragments.
   *
   * @remarks
   * The color is applied using the `Classifier.setColor` method, which sets the color of the specified fragments.
   * The color is provided as a hexadecimal string, prefixed with a '#'.
   */
  colorize() {
    const s = this._components.get(te), t = this._components.get(_t), e = this._components.get(bs);
    for (const [i, n] of this.componentColors) {
      const r = t.guidToFragmentIdMap(n), o = new M.Color(`#${i}`);
      e.setColor(
        r,
        o,
        s.config.overwriteColors
      );
    }
  }
  /**
   * Resets the colors of all components in the viewpoint to their original color.
   * This method iterates through the `componentColors` map, retrieves the fragment IDs
   * corresponding to each color, and then uses the `Classifier` to reset the color of those fragments.
   */
  resetColors() {
    const s = this._components.get(_t), t = this._components.get(bs);
    for (const [e, i] of this.componentColors) {
      const n = s.guidToFragmentIdMap(i);
      t.resetColor(n);
    }
  }
  async createComponentTags(s) {
    var n, r;
    const t = this._components.get(_t), e = this._components.get(Lt);
    let i = "";
    if (e.config.includeSelectionTag) {
      const o = s === "selection" ? this._selectionModelIdMap : this._exceptionModelIdMap;
      for (const a in o) {
        const l = t.groups.get(a);
        if (!l)
          continue;
        const h = o[a];
        for (const d of h) {
          const u = await l.getProperties(d);
          if (!u)
            continue;
          const f = (n = u.GlobalId) == null ? void 0 : n.value;
          if (!f)
            continue;
          const E = (r = u.Tag) == null ? void 0 : r.value;
          let p = null;
          E && (p = `AuthoringToolId="${E}"`), i += `
<Component IfcGuid="${f}" ${p ?? ""} />`;
        }
      }
    } else
      i = [...this.selectionComponents].map((o) => `<Component IfcGuid="${o}" />`).join(`
`);
    return i;
  }
  /**
   * Serializes the viewpoint into a buildingSMART compliant XML string for export.
   *
   * @param version - The version of the BCF Manager to use for serialization.
   *                   If not provided, the current version of the manager will be used.
   *
   * @returns A Promise that resolves to an XML string representing the viewpoint.
   *          The XML string follows the BCF VisualizationInfo schema.
   *
   * @throws An error if the world's camera does not have camera controls.
   * @throws An error if the world's renderer is not available.
   */
  async serialize(s = this._managerVersion) {
    const t = this._components.get(_t), e = this.position;
    e.applyMatrix4(t.baseCoordinationMatrix.clone().invert());
    const i = this.direction;
    i.normalize();
    const n = new M.Matrix4().makeRotationX(Math.PI / 2), r = i.clone().applyMatrix4(n);
    r.normalize();
    const o = `<CameraViewPoint>
      <X>${e.x}</X>
      <Y>${-e.z}</Y>
      <Z>${e.y}</Z>
    </CameraViewPoint>`, a = `<CameraDirection>
      <X>${i.x}</X>
      <Y>${-i.z}</Y>
      <Z>${i.y}</Z>
    </CameraDirection>`, l = `<CameraUpVector>
      <X>${r.x}</X>
      <Y>${-r.z}</Y>
      <Z>${r.y}</Z>
    </CameraUpVector>`, h = `<AspectRatio>${this.camera.aspectRatio}</AspectRatio>`;
    let d = "";
    "viewToWorld" in this.camera ? d = `<OrthogonalCamera>
        ${o}
        ${a}
        ${l}
        ${h}
        <ViewToWorldScale>${this.camera.viewToWorld}</ViewToWorldScale>
      </OrthogonalCamera>` : "fov" in this.camera && (d = `<PerspectiveCamera>
        ${o}
        ${a}
        ${l}
        ${h}
        <FieldOfView>${this.camera.fov}</FieldOfView>
      </PerspectiveCamera>`);
    const u = `<ViewSetupHints SpacesVisible="${this.spacesVisible ?? !1}" SpaceBoundariesVisible="${this.spaceBoundariesVisible ?? !1}" OpeningsVisible="${this.openingsVisible ?? !1}" />`, f = (await this.createComponentTags("selection")).trim(), E = (await this.createComponentTags("exception")).trim();
    return `<?xml version="1.0" encoding="UTF-8"?>
    <VisualizationInfo Guid="${this.guid}">
      <Components>
        ${s === "2.1" ? u : ""}
        ${f.length !== 0 ? `<Selection>${f}</Selection>` : ""}
        <Visibility DefaultVisibility="${this.defaultVisibility}">
          ${s === "3" ? u : ""}
          ${E.length !== 0 ? `<Exceptions>${E}</Exceptions>` : ""}
        </Visibility>
      </Components>
      ${d}
    </VisualizationInfo>`;
  }
}
const Ai = class Ai extends St {
  constructor(t) {
    super(t);
    T(this, "enabled", !0);
    /**
     * A DataMap that stores Viewpoint instances, indexed by their unique identifiers (guid).
     * This map is used to manage and retrieve Viewpoint instances within the Viewpoints component.
     */
    T(this, "list", new Ee());
    T(this, "isSetup", !1);
    T(this, "onSetup", new j());
    T(this, "config", { overwriteColors: !1 });
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    t.add(Ai.uuid, this);
  }
  /**
   * Creates a new Viewpoint instance and adds it to the list.
   *
   * @param world - The world in which the Viewpoint will be created.
   * @param data - Optional partial data for the Viewpoint. If not provided, default data will be used.
   *
   * @returns The newly created Viewpoint instance.
   */
  create(t, e) {
    const i = new Kr(this.components, t, { data: e });
    return e || this.list.set(i.guid, i), i;
  }
  setup() {
  }
  /**
   * Disposes of the Viewpoints component and its associated resources.
   *
   * This method is responsible for cleaning up any resources held by the Viewpoints component,
   * such as disposing of the DataMap of Viewpoint instances and triggering and resetting the
   * onDisposed event.
   */
  dispose() {
    this.list.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
};
T(Ai, "uuid", "ee867824-a796-408d-8aa0-4e5962a83c66");
let te = Ai;
class bl {
  constructor(s) {
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    /** {@link Updateable.onAfterUpdate} */
    T(this, "onAfterUpdate", new j());
    /** {@link Updateable.onBeforeUpdate} */
    T(this, "onBeforeUpdate", new j());
    /** {@link Resizeable.onResize} */
    T(this, "onResize", new j());
    /**
     * The front offset of the minimap.
     * It determines how much the minimap's view is offset from the camera's view.
     * By pushing the map to the front, what the user sees on screen corresponds with what they see on the map
     */
    T(this, "frontOffset", 0);
    /**
     * The override material for the minimap.
     * It is used to render the depth information of the world onto the minimap.
     */
    T(this, "overrideMaterial", new M.MeshDepthMaterial());
    /**
     * The background color of the minimap.
     * It is used to set the background color of the minimap's renderer.
     */
    T(this, "backgroundColor", new M.Color(395274));
    /**
     * The WebGL renderer for the minimap.
     * It is used to render the minimap onto the screen.
     */
    T(this, "renderer");
    /**
     * A flag indicating whether the minimap is enabled.
     * If disabled, the minimap will not update or render.
     */
    T(this, "enabled", !0);
    /**
     * The world in which the minimap is displayed.
     * It provides access to the 3D scene, camera, and other relevant world elements.
     */
    T(this, "world");
    T(this, "_lockRotation", !0);
    T(this, "_camera");
    T(this, "_plane");
    T(this, "_size", new M.Vector2(320, 160));
    T(this, "_tempVector1", new M.Vector3());
    T(this, "_tempVector2", new M.Vector3());
    T(this, "_tempTarget", new M.Vector3());
    T(this, "down", new M.Vector3(0, -1, 0));
    T(this, "updatePlanes", () => {
      if (!this.world.renderer)
        throw new Error("The given world must have a renderer!");
      const s = [], t = this.world.renderer.three;
      for (const e of t.clippingPlanes)
        s.push(e);
      s.push(this._plane), this.renderer.clippingPlanes = s;
    });
    if (this.world = s, !this.world.renderer)
      throw new Error("The given world must have a renderer!");
    this.renderer = new M.WebGLRenderer(), this.renderer.setSize(this._size.x, this._size.y);
    const t = 1, e = this._size.x / this._size.y;
    this._camera = new M.OrthographicCamera(
      t * e / -2,
      t * e / 2,
      t / 2,
      t / -2
    ), this.world.renderer.onClippingPlanesUpdated.add(this.updatePlanes), this._camera.position.set(0, 200, 0), this._camera.zoom = 0.1, this._camera.rotation.x = -Math.PI / 2, this._plane = new M.Plane(this.down, 200), this.updatePlanes();
  }
  /**
   * Gets or sets whether the minimap rotation is locked.
   * When rotation is locked, the minimap will always face the same direction as the camera.
   */
  get lockRotation() {
    return this._lockRotation;
  }
  /**
   * Sets whether the minimap rotation is locked.
   * When rotation is locked, the minimap will always face the same direction as the camera.
   * @param active - If `true`, rotation is locked. If `false`, rotation is not locked.
   */
  set lockRotation(s) {
    this._lockRotation = s, s && (this._camera.rotation.z = 0);
  }
  /**
   * Gets the current zoom level of the minimap.
   * The zoom level determines how much of the world is visible on the minimap.
   * @returns The current zoom level of the minimap.
   */
  get zoom() {
    return this._camera.zoom;
  }
  /**
   * Sets the zoom level of the minimap.
   * The zoom level determines how much of the world is visible on the minimap.
   * @param value - The new zoom level of the minimap.
   */
  set zoom(s) {
    this._camera.zoom = s, this._camera.updateProjectionMatrix();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = !1, this.onBeforeUpdate.reset(), this.onAfterUpdate.reset(), this.onResize.reset(), this.overrideMaterial.dispose(), this.renderer.forceContextLoss(), this.renderer.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /** Returns the camera used by the MiniMap */
  get() {
    return this._camera;
  }
  /** {@link Updateable.update} */
  update() {
    if (!this.enabled)
      return;
    this.onBeforeUpdate.trigger();
    const s = this.world.scene.three, t = this.world.camera;
    if (!t.hasCameraControls())
      throw new Error("The given world must use camera controls!");
    if (!(s instanceof M.Scene))
      throw new Error("The given world must have a THREE.Scene as a root!");
    const e = t.controls;
    if (e.getPosition(this._tempVector1), this._camera.position.x = this._tempVector1.x, this._camera.position.z = this._tempVector1.z, this.frontOffset !== 0 && (e.getTarget(this._tempVector2), this._tempVector2.sub(this._tempVector1), this._tempVector2.normalize().multiplyScalar(this.frontOffset), this._camera.position.x += this._tempVector2.x, this._camera.position.z += this._tempVector2.z), !this._lockRotation) {
      e.getTarget(this._tempTarget);
      const n = Math.atan2(
        this._tempTarget.x - this._tempVector1.x,
        this._tempTarget.z - this._tempVector1.z
      );
      this._camera.rotation.z = n + Math.PI;
    }
    this._plane.set(this.down, this._tempVector1.y);
    const i = s.background;
    s.background = this.backgroundColor, this.renderer.render(s, this._camera), s.background = i, this.onAfterUpdate.trigger();
  }
  /** {@link Resizeable.getSize} */
  getSize() {
    return this._size;
  }
  /** {@link Resizeable.resize} */
  resize(s = this._size) {
    this._size.copy(s), this.renderer.setSize(s.x, s.y);
    const t = s.x / s.y, e = 1;
    this._camera.left = e * t / -2, this._camera.right = e * t / 2, this._camera.top = e / 2, this._camera.bottom = -e / 2, this._camera.updateProjectionMatrix(), this.onResize.trigger(s);
  }
}
const Ri = class Ri extends St {
  constructor(t) {
    super(t);
    /** {@link Updateable.onAfterUpdate} */
    T(this, "onAfterUpdate", new j());
    /** {@link Updateable.onBeforeUpdate} */
    T(this, "onBeforeUpdate", new j());
    /** {@link Disposable.onDisposed} */
    T(this, "onDisposed", new j());
    /** {@link Component.enabled} */
    T(this, "enabled", !0);
    /**
     * A collection of {@link MiniMap} instances, each associated with a unique world ID.
     */
    T(this, "list", /* @__PURE__ */ new Map());
    this.components.add(Ri.uuid, this);
  }
  /**
   * Creates a new {@link MiniMap} instance associated with the given world.
   * If a {@link MiniMap} instance already exists for the given world, an error will be thrown.
   *
   * @param world - The {@link World} for which to create a {@link MiniMap} instance.
   * @returns The newly created {@link MiniMap} instance.
   * @throws Will throw an error if a {@link MiniMap} instance already exists for the given world.
   */
  create(t) {
    if (this.list.has(t.uuid))
      throw new Error("This world already has a minimap!");
    const e = new bl(t);
    return this.list.set(t.uuid, e), e;
  }
  /**
   * Deletes a {@link MiniMap} instance associated with the given world ID.
   * If a {@link MiniMap} instance does not exist for the given ID, nothing happens.
   *
   * @param id - The unique identifier of the world for which to delete the {@link MiniMap} instance.
   * @returns {void}
   */
  delete(t) {
    const e = this.list.get(t);
    e && e.dispose(), this.list.delete(t);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger();
  }
  /** {@link Updateable.update} */
  update() {
    for (const [t, e] of this.list)
      e.update();
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
T(Ri, "uuid", "39ad6aad-84c8-4adf-a1e0-7f25313a9e7f");
let Sr = Ri;
const yi = class yi extends St {
  constructor(t) {
    super(t);
    /** {@link Component.enabled} */
    T(this, "enabled", !0);
    t.add(yi.uuid, this);
  }
  /**
   * Utility method to calculate the distance from a point to a line segment.
   *
   * @param point - The point from which to calculate the distance.
   * @param lineStart - The start point of the line segment.
   * @param lineEnd - The end point of the line segment.
   * @param clamp - If true, the distance will be clamped to the line segment's length.
   * @returns The distance from the point to the line segment.
   */
  static distanceFromPointToLine(t, e, i, n = !1) {
    const r = new M.Line3(), o = new M.Vector3();
    return r.set(e, i), r.closestPointToPoint(t, n, o), o.distanceTo(t);
  }
  /**
   * Method to get the face of a mesh that contains a given triangle index.
   * It also returns the edges of the found face and their indices.
   *
   * @param mesh - The mesh to get the face from. It must be indexed.
   * @param triangleIndex - The index of the triangle within the mesh.
   * @param instance - The instance of the mesh (optional).
   * @returns An object containing the edges of the found face and their indices, or null if no face was found.
   */
  getFace(t, e, i) {
    if (!t.geometry.index)
      throw new Error("Geometry must be indexed!");
    const n = /* @__PURE__ */ new Map(), r = t.geometry.index.array, { plane: o } = this.getFaceData(
      e,
      i,
      t
    ), a = [];
    for (let u = 0; u < r.length / 3; u++) {
      const { plane: f, edges: E } = this.getFaceData(u, i, t);
      if (f.equals(o)) {
        a.push({ index: u, edges: E });
        for (const { id: p, points: I, distance: m } of E)
          n.set(p, { points: I, distance: m });
      }
    }
    let l = 0;
    const h = /* @__PURE__ */ new Map(), d = /* @__PURE__ */ new Map();
    for (const { index: u, edges: f } of a) {
      const E = /* @__PURE__ */ new Map();
      for (const { id: y } of f)
        if (h.has(y)) {
          const F = h.get(y);
          E.set(y, F);
        }
      const p = f.map((y) => y.id);
      if (!E.size) {
        const y = l++;
        for (const { id: F } of f)
          h.set(F, y);
        d.set(y, {
          edges: new Set(p),
          indices: /* @__PURE__ */ new Set([u])
        });
        continue;
      }
      let I = null;
      const m = /* @__PURE__ */ new Set(), C = new Set(p);
      for (const [y, F] of E) {
        I === null ? I = F : F !== I && m.add(F), h.delete(y);
        const { edges: S } = d.get(F);
        S.delete(y), C.delete(y);
      }
      if (I === null)
        throw new Error("Error computing face!");
      const R = d.get(I), { indices: g } = R;
      g.add(u);
      for (const y of C) {
        h.set(y, I);
        const { edges: F } = R;
        F.add(y);
      }
      for (const y of m) {
        const F = d.get(y), { edges: S, indices: L } = F, N = d.get(I), { edges: x, indices: k } = N;
        for (const w of S)
          x.add(w), h.set(w, I);
        for (const w of L)
          k.add(w);
        d.delete(y);
      }
    }
    for (const [u, { indices: f, edges: E }] of d)
      if (f.has(e)) {
        const p = [];
        for (const I of E) {
          const m = n.get(I);
          p.push(m);
        }
        return { edges: p, indices: f };
      }
    return null;
  }
  /**
   * Method to get the vertices and normal of a mesh face at a given index.
   * It also applies instance transformation if provided.
   *
   * @param mesh - The mesh to get the face from. It must be indexed.
   * @param faceIndex - The index of the face within the mesh.
   * @param instance - The instance of the mesh (optional).
   * @returns An object containing the vertices and normal of the face.
   * @throws Will throw an error if the geometry is not indexed.
   */
  getVerticesAndNormal(t, e, i) {
    if (!t.geometry.index)
      throw new Error("Geometry must be indexed!");
    const n = t.geometry.index.array, r = t.geometry.attributes.position.array, o = t.geometry.attributes.normal.array, a = n[e * 3] * 3, l = n[e * 3 + 1] * 3, h = n[e * 3 + 2] * 3, d = new M.Vector3(r[a], r[a + 1], r[a + 2]), u = new M.Vector3(r[l], r[l + 1], r[l + 2]), f = new M.Vector3(r[h], r[h + 1], r[h + 2]), E = new M.Vector3(o[a], o[a + 1], o[a + 2]), p = new M.Vector3(o[l], o[l + 1], o[l + 2]), I = new M.Vector3(o[h], o[h + 1], o[h + 2]), m = (E.x + p.x + I.x) / 3, C = (E.y + p.y + I.y) / 3, R = (E.z + p.z + I.z) / 3, g = new M.Vector3(m, C, R);
    if (i !== void 0 && t instanceof M.InstancedMesh) {
      const y = new M.Matrix4();
      t.getMatrixAt(i, y);
      const F = new M.Matrix4();
      F.extractRotation(y), g.applyMatrix4(F), d.applyMatrix4(y), u.applyMatrix4(y), f.applyMatrix4(y);
    }
    return { p1: d, p2: u, p3: f, faceNormal: g };
  }
  /**
   * Method to round the vector's components to a specified number of decimal places.
   * This is used to ensure numerical precision in edge detection.
   *
   * @param vector - The vector to round.
   * @returns The vector with rounded components.
   */
  round(t) {
    t.x = Math.trunc(t.x * 1e3) / 1e3, t.y = Math.trunc(t.y * 1e3) / 1e3, t.z = Math.trunc(t.z * 1e3) / 1e3;
  }
  /**
   * Calculates the volume of a set of fragments.
   *
   * @param frags - A map of fragment IDs to their corresponding item IDs.
   * @returns The total volume of the fragments and the bounding sphere.
   *
   * @remarks
   * This method creates a set of instanced meshes from the given fragments and item IDs.
   * It then calculates the volume of each mesh and returns the total volume and its bounding sphere.
   *
   * @throws Will throw an error if the geometry of the meshes is not indexed.
   * @throws Will throw an error if the fragment manager is not available.
   */
  getVolumeFromFragments(t) {
    const e = this.components.get(_t), i = new M.Matrix4(), n = [];
    for (const o in t) {
      const a = e.list.get(o);
      if (!a)
        continue;
      const l = t[o];
      let h = 0;
      for (const f of l) {
        const E = a.getInstancesIDs(f);
        E && (h += E.size);
      }
      const d = new M.InstancedMesh(
        a.mesh.geometry,
        void 0,
        h
      );
      let u = 0;
      for (const f of l) {
        const E = a.getInstancesIDs(f);
        if (E)
          for (const p of E)
            a.mesh.getMatrixAt(p, i), d.setMatrixAt(u++, i);
      }
      n.push(d);
    }
    const r = this.getVolumeFromMeshes(n);
    for (const o of n)
      o.geometry = null, o.material = [], o.dispose();
    return r;
  }
  /**
   * Calculates the total volume of a set of meshes.
   *
   * @param meshes - An array of meshes or instanced meshes to calculate the volume from.
   * @returns The total volume of the meshes and the bounding sphere.
   *
   * @remarks
   * This method calculates the volume of each mesh in the provided array and returns the total volume
   * and its bounding sphere.
   *
   */
  getVolumeFromMeshes(t) {
    let e = 0;
    for (const i of t)
      e += this.getVolumeOfMesh(i);
    return e;
  }
  getFaceData(t, e, i) {
    const n = this.getVerticesAndNormal(i, t, e), { p1: r, p2: o, p3: a, faceNormal: l } = n;
    this.round(r), this.round(o), this.round(a), this.round(l);
    const h = [
      { id: `${r.x}|${r.y}|${r.z}`, value: r },
      { id: `${o.x}|${o.y}|${o.z}`, value: o },
      { id: `${a.x}|${a.y}|${a.z}`, value: a }
    ];
    h.sort((R, g) => R.id < g.id ? -1 : R.id > g.id ? 1 : 0);
    const [
      { id: d, value: u },
      { id: f, value: E },
      { id: p, value: I }
    ] = h, m = [
      {
        id: `${d}|${f}`,
        distance: u.distanceTo(E),
        points: [u, E]
      },
      {
        id: `${f}|${p}`,
        distance: E.distanceTo(I),
        points: [E, I]
      },
      {
        id: `${d}|${p}`,
        distance: u.distanceTo(I),
        points: [u, I]
      }
    ], C = new M.Plane();
    return C.setFromNormalAndCoplanarPoint(l, r), C.constant = Math.round(C.constant * 10) / 10, { plane: C, edges: m };
  }
  // https://stackoverflow.com/a/1568551
  getVolumeOfMesh(t) {
    let e = 0;
    const i = new M.Vector3(), n = new M.Vector3(), r = new M.Vector3(), { index: o } = t.geometry, a = t.geometry.attributes.position.array;
    if (!o)
      return console.warn("Geometry must be indexed to compute its volume!"), 0;
    const l = [];
    if (t instanceof M.InstancedMesh)
      for (let d = 0; d < t.count; d++) {
        const u = new M.Matrix4();
        t.getMatrixAt(d, u), l.push(u);
      }
    else
      l.push(new M.Matrix4().identity());
    const { matrixWorld: h } = t;
    for (let d = 0; d < o.array.length - 2; d += 3)
      for (const u of l) {
        const f = u.multiply(h), E = o.array[d] * 3, p = o.array[d + 1] * 3, I = o.array[d + 2] * 3;
        i.set(a[E], a[E + 1], a[E + 2]).applyMatrix4(f), n.set(a[p], a[p + 1], a[p + 2]).applyMatrix4(f), r.set(a[I], a[I + 1], a[I + 2]).applyMatrix4(f), e += this.getSignedVolumeOfTriangle(i, n, r);
      }
    return Math.abs(e);
  }
  getSignedVolumeOfTriangle(t, e, i) {
    const n = i.x * e.y * t.z, r = e.x * i.y * t.z, o = i.x * t.y * e.z, a = t.x * i.y * e.z, l = e.x * t.y * i.z, h = t.x * e.y * i.z;
    return 1 / 6 * (-n + r + o - a - l + h);
  }
};
/**
 * A unique identifier for the component.
 * This UUID is used to register the component within the Components system.
 */
T(yi, "uuid", "267ca032-672f-4cb0-afa9-d24e904f39d6");
let Or = yi;
export {
  oi as AsyncEvent,
  Lt as BCFTopics,
  An as Base,
  Ca as BaseCamera,
  Ta as BaseRenderer,
  _a as BaseScene,
  Rn as BaseWorldItem,
  mn as BoundingBoxer,
  bs as Classifier,
  ln as Clipper,
  En as Comment,
  St as Component,
  an as Components,
  ka as CullerRenderer,
  cn as Cullers,
  Ee as DataMap,
  qe as DataSet,
  Fe as Disposer,
  j as Event,
  wr as Exploder,
  tc as FirstPersonMode,
  _t as FragmentsManager,
  Hr as GeometryTypes,
  hr as Grids,
  In as Hider,
  Ul as IfcCategories,
  zr as IfcCategoryMap,
  rc as IfcElements,
  wn as IfcFragmentSettings,
  Fr as IfcGeometryTiler,
  hn as IfcJsonExporter,
  dn as IfcLoader,
  un as IfcPropertiesManager,
  Nl as IfcPropertiesTiler,
  Ke as IfcPropertiesUtils,
  xe as IfcRelationsIndexer,
  Sl as IfcStreamingSettings,
  er as MaterialsUtils,
  Or as MeasurementUtils,
  Va as MeshCullerRenderer,
  bl as MiniMap,
  Sr as MiniMaps,
  Ga as Mouse,
  ec as OrbitMode,
  nc as OrthoPerspectiveCamera,
  sc as PlanMode,
  ic as ProjectionManager,
  Ol as PropertiesStreamingSettings,
  ts as Raycasters,
  Dl as ShadowedScene,
  Ns as SimpleCamera,
  Wa as SimpleGrid,
  yn as SimplePlane,
  Ha as SimpleRaycaster,
  vl as SimpleRenderer,
  Ma as SimpleScene,
  La as SimpleWorld,
  di as Topic,
  me as UUID,
  xl as VertexPicker,
  Kr as Viewpoint,
  te as Viewpoints,
  hi as Worlds,
  Fl as extensionsImporter,
  ac as ifcRelAttrsPosition,
  cc as ifcRelClassNames,
  Pa as isPointInFrontOfPlane,
  ba as obbFromPoints,
  Br as readPixelsAsync,
  gr as relToAttributesMap
};
