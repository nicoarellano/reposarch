import * as A from "@thatopen/components";
import * as q from "web-ifc";
import * as z from "@thatopen/components-front";
import * as N from "three";
import { Object3D as jr, Vector2 as Br, Vector3 as wn, Matrix4 as Go } from "three";
var Hr = Object.defineProperty, Ur = (i, t, e) => t in i ? Hr(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e, Nt = (i, t, e) => (Ur(i, typeof t != "symbol" ? t + "" : t, e), e);
const Kt = Math.min, ft = Math.max, li = Math.round, At = (i) => ({
  x: i,
  y: i
}), Vr = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Wr = {
  start: "end",
  end: "start"
};
function qn(i, t, e) {
  return ft(i, Kt(t, e));
}
function je(i, t) {
  return typeof i == "function" ? i(t) : i;
}
function gt(i) {
  return i.split("-")[0];
}
function Ai(i) {
  return i.split("-")[1];
}
function qo(i) {
  return i === "x" ? "y" : "x";
}
function Yo(i) {
  return i === "y" ? "height" : "width";
}
function Bt(i) {
  return ["top", "bottom"].includes(gt(i)) ? "y" : "x";
}
function Xo(i) {
  return qo(Bt(i));
}
function Gr(i, t, e) {
  e === void 0 && (e = !1);
  const n = Ai(i), o = Xo(i), s = Yo(o);
  let r = o === "x" ? n === (e ? "end" : "start") ? "right" : "left" : n === "start" ? "bottom" : "top";
  return t.reference[s] > t.floating[s] && (r = ci(r)), [r, ci(r)];
}
function qr(i) {
  const t = ci(i);
  return [on(i), t, on(t)];
}
function on(i) {
  return i.replace(/start|end/g, (t) => Wr[t]);
}
function Yr(i, t, e) {
  const n = ["left", "right"], o = ["right", "left"], s = ["top", "bottom"], r = ["bottom", "top"];
  switch (i) {
    case "top":
    case "bottom":
      return e ? t ? o : n : t ? n : o;
    case "left":
    case "right":
      return t ? s : r;
    default:
      return [];
  }
}
function Xr(i, t, e, n) {
  const o = Ai(i);
  let s = Yr(gt(i), e === "start", n);
  return o && (s = s.map((r) => r + "-" + o), t && (s = s.concat(s.map(on)))), s;
}
function ci(i) {
  return i.replace(/left|right|bottom|top/g, (t) => Vr[t]);
}
function Jr(i) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...i
  };
}
function Jo(i) {
  return typeof i != "number" ? Jr(i) : {
    top: i,
    right: i,
    bottom: i,
    left: i
  };
}
function Zt(i) {
  const {
    x: t,
    y: e,
    width: n,
    height: o
  } = i;
  return {
    width: n,
    height: o,
    top: e,
    left: t,
    right: t + n,
    bottom: e + o,
    x: t,
    y: e
  };
}
function Yn(i, t, e) {
  let {
    reference: n,
    floating: o
  } = i;
  const s = Bt(t), r = Xo(t), a = Yo(r), l = gt(t), c = s === "y", h = n.x + n.width / 2 - o.width / 2, u = n.y + n.height / 2 - o.height / 2, p = n[a] / 2 - o[a] / 2;
  let d;
  switch (l) {
    case "top":
      d = {
        x: h,
        y: n.y - o.height
      };
      break;
    case "bottom":
      d = {
        x: h,
        y: n.y + n.height
      };
      break;
    case "right":
      d = {
        x: n.x + n.width,
        y: u
      };
      break;
    case "left":
      d = {
        x: n.x - o.width,
        y: u
      };
      break;
    default:
      d = {
        x: n.x,
        y: n.y
      };
  }
  switch (Ai(t)) {
    case "start":
      d[r] -= p * (e && c ? -1 : 1);
      break;
    case "end":
      d[r] += p * (e && c ? -1 : 1);
      break;
  }
  return d;
}
const Qr = async (i, t, e) => {
  const {
    placement: n = "bottom",
    strategy: o = "absolute",
    middleware: s = [],
    platform: r
  } = e, a = s.filter(Boolean), l = await (r.isRTL == null ? void 0 : r.isRTL(t));
  let c = await r.getElementRects({
    reference: i,
    floating: t,
    strategy: o
  }), {
    x: h,
    y: u
  } = Yn(c, n, l), p = n, d = {}, m = 0;
  for (let v = 0; v < a.length; v++) {
    const {
      name: w,
      fn: C
    } = a[v], {
      x,
      y: g,
      data: y,
      reset: $
    } = await C({
      x: h,
      y: u,
      initialPlacement: n,
      placement: p,
      strategy: o,
      middlewareData: d,
      rects: c,
      platform: r,
      elements: {
        reference: i,
        floating: t
      }
    });
    h = x ?? h, u = g ?? u, d = {
      ...d,
      [w]: {
        ...d[w],
        ...y
      }
    }, $ && m <= 50 && (m++, typeof $ == "object" && ($.placement && (p = $.placement), $.rects && (c = $.rects === !0 ? await r.getElementRects({
      reference: i,
      floating: t,
      strategy: o
    }) : $.rects), {
      x: h,
      y: u
    } = Yn(c, p, l)), v = -1);
  }
  return {
    x: h,
    y: u,
    placement: p,
    strategy: o,
    middlewareData: d
  };
};
async function Qo(i, t) {
  var e;
  t === void 0 && (t = {});
  const {
    x: n,
    y: o,
    platform: s,
    rects: r,
    elements: a,
    strategy: l
  } = i, {
    boundary: c = "clippingAncestors",
    rootBoundary: h = "viewport",
    elementContext: u = "floating",
    altBoundary: p = !1,
    padding: d = 0
  } = je(t, i), m = Jo(d), v = a[p ? u === "floating" ? "reference" : "floating" : u], w = Zt(await s.getClippingRect({
    element: (e = await (s.isElement == null ? void 0 : s.isElement(v))) == null || e ? v : v.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(a.floating)),
    boundary: c,
    rootBoundary: h,
    strategy: l
  })), C = u === "floating" ? {
    x: n,
    y: o,
    width: r.floating.width,
    height: r.floating.height
  } : r.reference, x = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(a.floating)), g = await (s.isElement == null ? void 0 : s.isElement(x)) ? await (s.getScale == null ? void 0 : s.getScale(x)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, y = Zt(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: C,
    offsetParent: x,
    strategy: l
  }) : C);
  return {
    top: (w.top - y.top + m.top) / g.y,
    bottom: (y.bottom - w.bottom + m.bottom) / g.y,
    left: (w.left - y.left + m.left) / g.x,
    right: (y.right - w.right + m.right) / g.x
  };
}
const Kr = function(i) {
  return i === void 0 && (i = {}), {
    name: "flip",
    options: i,
    async fn(t) {
      var e, n;
      const {
        placement: o,
        middlewareData: s,
        rects: r,
        initialPlacement: a,
        platform: l,
        elements: c
      } = t, {
        mainAxis: h = !0,
        crossAxis: u = !0,
        fallbackPlacements: p,
        fallbackStrategy: d = "bestFit",
        fallbackAxisSideDirection: m = "none",
        flipAlignment: v = !0,
        ...w
      } = je(i, t);
      if ((e = s.arrow) != null && e.alignmentOffset)
        return {};
      const C = gt(o), x = Bt(a), g = gt(a) === a, y = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), $ = p || (g || !v ? [ci(a)] : qr(a)), _ = m !== "none";
      !p && _ && $.push(...Xr(a, v, m, y));
      const E = [a, ...$], L = await Qo(t, w), D = [];
      let T = ((n = s.flip) == null ? void 0 : n.overflows) || [];
      if (h && D.push(L[C]), u) {
        const k = Gr(o, r, y);
        D.push(L[k[0]], L[k[1]]);
      }
      if (T = [...T, {
        placement: o,
        overflows: D
      }], !D.every((k) => k <= 0)) {
        var M, S;
        const k = (((M = s.flip) == null ? void 0 : M.index) || 0) + 1, tt = E[k];
        if (tt)
          return {
            data: {
              index: k,
              overflows: T
            },
            reset: {
              placement: tt
            }
          };
        let B = (S = T.filter((X) => X.overflows[0] <= 0).sort((X, et) => X.overflows[1] - et.overflows[1])[0]) == null ? void 0 : S.placement;
        if (!B)
          switch (d) {
            case "bestFit": {
              var P;
              const X = (P = T.filter((et) => {
                if (_) {
                  const dt = Bt(et.placement);
                  return dt === x || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  dt === "y";
                }
                return !0;
              }).map((et) => [et.placement, et.overflows.filter((dt) => dt > 0).reduce((dt, Fi) => dt + Fi, 0)]).sort((et, dt) => et[1] - dt[1])[0]) == null ? void 0 : P[0];
              X && (B = X);
              break;
            }
            case "initialPlacement":
              B = a;
              break;
          }
        if (o !== B)
          return {
            reset: {
              placement: B
            }
          };
      }
      return {};
    }
  };
};
function Ko(i) {
  const t = Kt(...i.map((s) => s.left)), e = Kt(...i.map((s) => s.top)), n = ft(...i.map((s) => s.right)), o = ft(...i.map((s) => s.bottom));
  return {
    x: t,
    y: e,
    width: n - t,
    height: o - e
  };
}
function Zr(i) {
  const t = i.slice().sort((o, s) => o.y - s.y), e = [];
  let n = null;
  for (let o = 0; o < t.length; o++) {
    const s = t[o];
    !n || s.y - n.y > n.height / 2 ? e.push([s]) : e[e.length - 1].push(s), n = s;
  }
  return e.map((o) => Zt(Ko(o)));
}
const ta = function(i) {
  return i === void 0 && (i = {}), {
    name: "inline",
    options: i,
    async fn(t) {
      const {
        placement: e,
        elements: n,
        rects: o,
        platform: s,
        strategy: r
      } = t, {
        padding: a = 2,
        x: l,
        y: c
      } = je(i, t), h = Array.from(await (s.getClientRects == null ? void 0 : s.getClientRects(n.reference)) || []), u = Zr(h), p = Zt(Ko(h)), d = Jo(a);
      function m() {
        if (u.length === 2 && u[0].left > u[1].right && l != null && c != null)
          return u.find((w) => l > w.left - d.left && l < w.right + d.right && c > w.top - d.top && c < w.bottom + d.bottom) || p;
        if (u.length >= 2) {
          if (Bt(e) === "y") {
            const T = u[0], M = u[u.length - 1], S = gt(e) === "top", P = T.top, k = M.bottom, tt = S ? T.left : M.left, B = S ? T.right : M.right, X = B - tt, et = k - P;
            return {
              top: P,
              bottom: k,
              left: tt,
              right: B,
              width: X,
              height: et,
              x: tt,
              y: P
            };
          }
          const w = gt(e) === "left", C = ft(...u.map((T) => T.right)), x = Kt(...u.map((T) => T.left)), g = u.filter((T) => w ? T.left === x : T.right === C), y = g[0].top, $ = g[g.length - 1].bottom, _ = x, E = C, L = E - _, D = $ - y;
          return {
            top: y,
            bottom: $,
            left: _,
            right: E,
            width: L,
            height: D,
            x: _,
            y
          };
        }
        return p;
      }
      const v = await s.getElementRects({
        reference: {
          getBoundingClientRect: m
        },
        floating: n.floating,
        strategy: r
      });
      return o.reference.x !== v.reference.x || o.reference.y !== v.reference.y || o.reference.width !== v.reference.width || o.reference.height !== v.reference.height ? {
        reset: {
          rects: v
        }
      } : {};
    }
  };
};
async function ea(i, t) {
  const {
    placement: e,
    platform: n,
    elements: o
  } = i, s = await (n.isRTL == null ? void 0 : n.isRTL(o.floating)), r = gt(e), a = Ai(e), l = Bt(e) === "y", c = ["left", "top"].includes(r) ? -1 : 1, h = s && l ? -1 : 1, u = je(t, i);
  let {
    mainAxis: p,
    crossAxis: d,
    alignmentAxis: m
  } = typeof u == "number" ? {
    mainAxis: u,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...u
  };
  return a && typeof m == "number" && (d = a === "end" ? m * -1 : m), l ? {
    x: d * h,
    y: p * c
  } : {
    x: p * c,
    y: d * h
  };
}
const Zo = function(i) {
  return {
    name: "offset",
    options: i,
    async fn(t) {
      var e, n;
      const {
        x: o,
        y: s,
        placement: r,
        middlewareData: a
      } = t, l = await ea(t, i);
      return r === ((e = a.offset) == null ? void 0 : e.placement) && (n = a.arrow) != null && n.alignmentOffset ? {} : {
        x: o + l.x,
        y: s + l.y,
        data: {
          ...l,
          placement: r
        }
      };
    }
  };
}, ia = function(i) {
  return i === void 0 && (i = {}), {
    name: "shift",
    options: i,
    async fn(t) {
      const {
        x: e,
        y: n,
        placement: o
      } = t, {
        mainAxis: s = !0,
        crossAxis: r = !1,
        limiter: a = {
          fn: (w) => {
            let {
              x: C,
              y: x
            } = w;
            return {
              x: C,
              y: x
            };
          }
        },
        ...l
      } = je(i, t), c = {
        x: e,
        y: n
      }, h = await Qo(t, l), u = Bt(gt(o)), p = qo(u);
      let d = c[p], m = c[u];
      if (s) {
        const w = p === "y" ? "top" : "left", C = p === "y" ? "bottom" : "right", x = d + h[w], g = d - h[C];
        d = qn(x, d, g);
      }
      if (r) {
        const w = u === "y" ? "top" : "left", C = u === "y" ? "bottom" : "right", x = m + h[w], g = m - h[C];
        m = qn(x, m, g);
      }
      const v = a.fn({
        ...t,
        [p]: d,
        [u]: m
      });
      return {
        ...v,
        data: {
          x: v.x - e,
          y: v.y - n
        }
      };
    }
  };
};
function Et(i) {
  return ts(i) ? (i.nodeName || "").toLowerCase() : "#document";
}
function K(i) {
  var t;
  return (i == null || (t = i.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Tt(i) {
  var t;
  return (t = (ts(i) ? i.ownerDocument : i.document) || window.document) == null ? void 0 : t.documentElement;
}
function ts(i) {
  return i instanceof Node || i instanceof K(i).Node;
}
function ut(i) {
  return i instanceof Element || i instanceof K(i).Element;
}
function ht(i) {
  return i instanceof HTMLElement || i instanceof K(i).HTMLElement;
}
function Xn(i) {
  return typeof ShadowRoot > "u" ? !1 : i instanceof ShadowRoot || i instanceof K(i).ShadowRoot;
}
function Be(i) {
  const {
    overflow: t,
    overflowX: e,
    overflowY: n,
    display: o
  } = nt(i);
  return /auto|scroll|overlay|hidden|clip/.test(t + n + e) && !["inline", "contents"].includes(o);
}
function na(i) {
  return ["table", "td", "th"].includes(Et(i));
}
function oa(i) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return i.matches(t);
    } catch {
      return !1;
    }
  });
}
function xn(i) {
  const t = $n(), e = ut(i) ? nt(i) : i;
  return e.transform !== "none" || e.perspective !== "none" || (e.containerType ? e.containerType !== "normal" : !1) || !t && (e.backdropFilter ? e.backdropFilter !== "none" : !1) || !t && (e.filter ? e.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((n) => (e.willChange || "").includes(n)) || ["paint", "layout", "strict", "content"].some((n) => (e.contain || "").includes(n));
}
function sa(i) {
  let t = te(i);
  for (; ht(t) && !Ei(t); ) {
    if (xn(t))
      return t;
    if (oa(t))
      return null;
    t = te(t);
  }
  return null;
}
function $n() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function Ei(i) {
  return ["html", "body", "#document"].includes(Et(i));
}
function nt(i) {
  return K(i).getComputedStyle(i);
}
function Si(i) {
  return ut(i) ? {
    scrollLeft: i.scrollLeft,
    scrollTop: i.scrollTop
  } : {
    scrollLeft: i.scrollX,
    scrollTop: i.scrollY
  };
}
function te(i) {
  if (Et(i) === "html")
    return i;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    i.assignedSlot || // DOM Element detected.
    i.parentNode || // ShadowRoot detected.
    Xn(i) && i.host || // Fallback.
    Tt(i)
  );
  return Xn(t) ? t.host : t;
}
function es(i) {
  const t = te(i);
  return Ei(t) ? i.ownerDocument ? i.ownerDocument.body : i.body : ht(t) && Be(t) ? t : es(t);
}
function sn(i, t, e) {
  var n;
  t === void 0 && (t = []), e === void 0 && (e = !0);
  const o = es(i), s = o === ((n = i.ownerDocument) == null ? void 0 : n.body), r = K(o);
  if (s) {
    const a = ra(r);
    return t.concat(r, r.visualViewport || [], Be(o) ? o : [], a && e ? sn(a) : []);
  }
  return t.concat(o, sn(o, [], e));
}
function ra(i) {
  return i.parent && Object.getPrototypeOf(i.parent) ? i.frameElement : null;
}
function is(i) {
  const t = nt(i);
  let e = parseFloat(t.width) || 0, n = parseFloat(t.height) || 0;
  const o = ht(i), s = o ? i.offsetWidth : e, r = o ? i.offsetHeight : n, a = li(e) !== s || li(n) !== r;
  return a && (e = s, n = r), {
    width: e,
    height: n,
    $: a
  };
}
function ns(i) {
  return ut(i) ? i : i.contextElement;
}
function Qt(i) {
  const t = ns(i);
  if (!ht(t))
    return At(1);
  const e = t.getBoundingClientRect(), {
    width: n,
    height: o,
    $: s
  } = is(t);
  let r = (s ? li(e.width) : e.width) / n, a = (s ? li(e.height) : e.height) / o;
  return (!r || !Number.isFinite(r)) && (r = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: r,
    y: a
  };
}
const aa = /* @__PURE__ */ At(0);
function os(i) {
  const t = K(i);
  return !$n() || !t.visualViewport ? aa : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function la(i, t, e) {
  return t === void 0 && (t = !1), !e || t && e !== K(i) ? !1 : t;
}
function Oe(i, t, e, n) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  const o = i.getBoundingClientRect(), s = ns(i);
  let r = At(1);
  t && (n ? ut(n) && (r = Qt(n)) : r = Qt(i));
  const a = la(s, e, n) ? os(s) : At(0);
  let l = (o.left + a.x) / r.x, c = (o.top + a.y) / r.y, h = o.width / r.x, u = o.height / r.y;
  if (s) {
    const p = K(s), d = n && ut(n) ? K(n) : n;
    let m = p, v = m.frameElement;
    for (; v && n && d !== m; ) {
      const w = Qt(v), C = v.getBoundingClientRect(), x = nt(v), g = C.left + (v.clientLeft + parseFloat(x.paddingLeft)) * w.x, y = C.top + (v.clientTop + parseFloat(x.paddingTop)) * w.y;
      l *= w.x, c *= w.y, h *= w.x, u *= w.y, l += g, c += y, m = K(v), v = m.frameElement;
    }
  }
  return Zt({
    width: h,
    height: u,
    x: l,
    y: c
  });
}
const ca = [":popover-open", ":modal"];
function ss(i) {
  return ca.some((t) => {
    try {
      return i.matches(t);
    } catch {
      return !1;
    }
  });
}
function da(i) {
  let {
    elements: t,
    rect: e,
    offsetParent: n,
    strategy: o
  } = i;
  const s = o === "fixed", r = Tt(n), a = t ? ss(t.floating) : !1;
  if (n === r || a && s)
    return e;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = At(1);
  const h = At(0), u = ht(n);
  if ((u || !u && !s) && ((Et(n) !== "body" || Be(r)) && (l = Si(n)), ht(n))) {
    const p = Oe(n);
    c = Qt(n), h.x = p.x + n.clientLeft, h.y = p.y + n.clientTop;
  }
  return {
    width: e.width * c.x,
    height: e.height * c.y,
    x: e.x * c.x - l.scrollLeft * c.x + h.x,
    y: e.y * c.y - l.scrollTop * c.y + h.y
  };
}
function ua(i) {
  return Array.from(i.getClientRects());
}
function rs(i) {
  return Oe(Tt(i)).left + Si(i).scrollLeft;
}
function ha(i) {
  const t = Tt(i), e = Si(i), n = i.ownerDocument.body, o = ft(t.scrollWidth, t.clientWidth, n.scrollWidth, n.clientWidth), s = ft(t.scrollHeight, t.clientHeight, n.scrollHeight, n.clientHeight);
  let r = -e.scrollLeft + rs(i);
  const a = -e.scrollTop;
  return nt(n).direction === "rtl" && (r += ft(t.clientWidth, n.clientWidth) - o), {
    width: o,
    height: s,
    x: r,
    y: a
  };
}
function pa(i, t) {
  const e = K(i), n = Tt(i), o = e.visualViewport;
  let s = n.clientWidth, r = n.clientHeight, a = 0, l = 0;
  if (o) {
    s = o.width, r = o.height;
    const c = $n();
    (!c || c && t === "fixed") && (a = o.offsetLeft, l = o.offsetTop);
  }
  return {
    width: s,
    height: r,
    x: a,
    y: l
  };
}
function ma(i, t) {
  const e = Oe(i, !0, t === "fixed"), n = e.top + i.clientTop, o = e.left + i.clientLeft, s = ht(i) ? Qt(i) : At(1), r = i.clientWidth * s.x, a = i.clientHeight * s.y, l = o * s.x, c = n * s.y;
  return {
    width: r,
    height: a,
    x: l,
    y: c
  };
}
function Jn(i, t, e) {
  let n;
  if (t === "viewport")
    n = pa(i, e);
  else if (t === "document")
    n = ha(Tt(i));
  else if (ut(t))
    n = ma(t, e);
  else {
    const o = os(i);
    n = {
      ...t,
      x: t.x - o.x,
      y: t.y - o.y
    };
  }
  return Zt(n);
}
function as(i, t) {
  const e = te(i);
  return e === t || !ut(e) || Ei(e) ? !1 : nt(e).position === "fixed" || as(e, t);
}
function fa(i, t) {
  const e = t.get(i);
  if (e)
    return e;
  let n = sn(i, [], !1).filter((a) => ut(a) && Et(a) !== "body"), o = null;
  const s = nt(i).position === "fixed";
  let r = s ? te(i) : i;
  for (; ut(r) && !Ei(r); ) {
    const a = nt(r), l = xn(r);
    !l && a.position === "fixed" && (o = null), (s ? !l && !o : !l && a.position === "static" && o && ["absolute", "fixed"].includes(o.position) || Be(r) && !l && as(i, r)) ? n = n.filter((c) => c !== r) : o = a, r = te(r);
  }
  return t.set(i, n), n;
}
function ba(i) {
  let {
    element: t,
    boundary: e,
    rootBoundary: n,
    strategy: o
  } = i;
  const s = [...e === "clippingAncestors" ? fa(t, this._c) : [].concat(e), n], r = s[0], a = s.reduce((l, c) => {
    const h = Jn(t, c, o);
    return l.top = ft(h.top, l.top), l.right = Kt(h.right, l.right), l.bottom = Kt(h.bottom, l.bottom), l.left = ft(h.left, l.left), l;
  }, Jn(t, r, o));
  return {
    width: a.right - a.left,
    height: a.bottom - a.top,
    x: a.left,
    y: a.top
  };
}
function ga(i) {
  const {
    width: t,
    height: e
  } = is(i);
  return {
    width: t,
    height: e
  };
}
function va(i, t, e) {
  const n = ht(t), o = Tt(t), s = e === "fixed", r = Oe(i, !0, s, t);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = At(0);
  if (n || !n && !s)
    if ((Et(t) !== "body" || Be(o)) && (a = Si(t)), n) {
      const u = Oe(t, !0, s, t);
      l.x = u.x + t.clientLeft, l.y = u.y + t.clientTop;
    } else
      o && (l.x = rs(o));
  const c = r.left + a.scrollLeft - l.x, h = r.top + a.scrollTop - l.y;
  return {
    x: c,
    y: h,
    width: r.width,
    height: r.height
  };
}
function Qn(i, t) {
  return !ht(i) || nt(i).position === "fixed" ? null : t ? t(i) : i.offsetParent;
}
function ls(i, t) {
  const e = K(i);
  if (!ht(i) || ss(i))
    return e;
  let n = Qn(i, t);
  for (; n && na(n) && nt(n).position === "static"; )
    n = Qn(n, t);
  return n && (Et(n) === "html" || Et(n) === "body" && nt(n).position === "static" && !xn(n)) ? e : n || sa(i) || e;
}
const ya = async function(i) {
  const t = this.getOffsetParent || ls, e = this.getDimensions;
  return {
    reference: va(i.reference, await t(i.floating), i.strategy),
    floating: {
      x: 0,
      y: 0,
      ...await e(i.floating)
    }
  };
};
function _a(i) {
  return nt(i).direction === "rtl";
}
const wa = {
  convertOffsetParentRelativeRectToViewportRelativeRect: da,
  getDocumentElement: Tt,
  getClippingRect: ba,
  getOffsetParent: ls,
  getElementRects: ya,
  getClientRects: ua,
  getDimensions: ga,
  getScale: Qt,
  isElement: ut,
  isRTL: _a
}, cs = ia, ds = Kr, us = ta, hs = (i, t, e) => {
  const n = /* @__PURE__ */ new Map(), o = {
    platform: wa,
    ...e
  }, s = {
    ...o.platform,
    _c: n
  };
  return Qr(i, t, {
    ...o,
    platform: s
  });
};
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ii = globalThis, Cn = ii.ShadowRoot && (ii.ShadyCSS === void 0 || ii.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, An = Symbol(), Kn = /* @__PURE__ */ new WeakMap();
let ps = class {
  constructor(i, t, e) {
    if (this._$cssResult$ = !0, e !== An)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = i, this.t = t;
  }
  get styleSheet() {
    let i = this.o;
    const t = this.t;
    if (Cn && i === void 0) {
      const e = t !== void 0 && t.length === 1;
      e && (i = Kn.get(t)), i === void 0 && ((this.o = i = new CSSStyleSheet()).replaceSync(this.cssText), e && Kn.set(t, i));
    }
    return i;
  }
  toString() {
    return this.cssText;
  }
};
const xa = (i) => new ps(typeof i == "string" ? i : i + "", void 0, An), R = (i, ...t) => {
  const e = i.length === 1 ? i[0] : t.reduce((n, o, s) => n + ((r) => {
    if (r._$cssResult$ === !0)
      return r.cssText;
    if (typeof r == "number")
      return r;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + r + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(o) + i[s + 1], i[0]);
  return new ps(e, i, An);
}, $a = (i, t) => {
  if (Cn)
    i.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet);
  else
    for (const e of t) {
      const n = document.createElement("style"), o = ii.litNonce;
      o !== void 0 && n.setAttribute("nonce", o), n.textContent = e.cssText, i.appendChild(n);
    }
}, Zn = Cn ? (i) => i : (i) => i instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const n of t.cssRules)
    e += n.cssText;
  return xa(e);
})(i) : i;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: Ca, defineProperty: Aa, getOwnPropertyDescriptor: Ea, getOwnPropertyNames: Sa, getOwnPropertySymbols: ka, getPrototypeOf: Ta } = Object, ee = globalThis, to = ee.trustedTypes, Oa = to ? to.emptyScript : "", eo = ee.reactiveElementPolyfillSupport, xe = (i, t) => i, di = { toAttribute(i, t) {
  switch (t) {
    case Boolean:
      i = i ? Oa : null;
      break;
    case Object:
    case Array:
      i = i == null ? i : JSON.stringify(i);
  }
  return i;
}, fromAttribute(i, t) {
  let e = i;
  switch (t) {
    case Boolean:
      e = i !== null;
      break;
    case Number:
      e = i === null ? null : Number(i);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(i);
      } catch {
        e = null;
      }
  }
  return e;
} }, En = (i, t) => !Ca(i, t), io = { attribute: !0, type: String, converter: di, reflect: !1, hasChanged: En };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), ee.litPropertyMetadata ?? (ee.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
class Xt extends HTMLElement {
  static addInitializer(t) {
    this._$Ei(), (this.l ?? (this.l = [])).push(t);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t, e = io) {
    if (e.state && (e.attribute = !1), this._$Ei(), this.elementProperties.set(t, e), !e.noAccessor) {
      const n = Symbol(), o = this.getPropertyDescriptor(t, n, e);
      o !== void 0 && Aa(this.prototype, t, o);
    }
  }
  static getPropertyDescriptor(t, e, n) {
    const { get: o, set: s } = Ea(this.prototype, t) ?? { get() {
      return this[e];
    }, set(r) {
      this[e] = r;
    } };
    return { get() {
      return o == null ? void 0 : o.call(this);
    }, set(r) {
      const a = o == null ? void 0 : o.call(this);
      s.call(this, r), this.requestUpdate(t, a, n);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) ?? io;
  }
  static _$Ei() {
    if (this.hasOwnProperty(xe("elementProperties")))
      return;
    const t = Ta(this);
    t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(xe("finalized")))
      return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(xe("properties"))) {
      const e = this.properties, n = [...Sa(e), ...ka(e)];
      for (const o of n)
        this.createProperty(o, e[o]);
    }
    const t = this[Symbol.metadata];
    if (t !== null) {
      const e = litPropertyMetadata.get(t);
      if (e !== void 0)
        for (const [n, o] of e)
          this.elementProperties.set(n, o);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [e, n] of this.elementProperties) {
      const o = this._$Eu(e, n);
      o !== void 0 && this._$Eh.set(o, e);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const n = new Set(t.flat(1 / 0).reverse());
      for (const o of n)
        e.unshift(Zn(o));
    } else
      t !== void 0 && e.push(Zn(t));
    return e;
  }
  static _$Eu(t, e) {
    const n = e.attribute;
    return n === !1 ? void 0 : typeof n == "string" ? n : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var t;
    this._$ES = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (t = this.constructor.l) == null || t.forEach((e) => e(this));
  }
  addController(t) {
    var e;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t), this.renderRoot !== void 0 && this.isConnected && ((e = t.hostConnected) == null || e.call(t));
  }
  removeController(t) {
    var e;
    (e = this._$EO) == null || e.delete(t);
  }
  _$E_() {
    const t = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;
    for (const n of e.keys())
      this.hasOwnProperty(n) && (t.set(n, this[n]), delete this[n]);
    t.size > 0 && (this._$Ep = t);
  }
  createRenderRoot() {
    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return $a(t, this.constructor.elementStyles), t;
  }
  connectedCallback() {
    var t;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (t = this._$EO) == null || t.forEach((e) => {
      var n;
      return (n = e.hostConnected) == null ? void 0 : n.call(e);
    });
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    var t;
    (t = this._$EO) == null || t.forEach((e) => {
      var n;
      return (n = e.hostDisconnected) == null ? void 0 : n.call(e);
    });
  }
  attributeChangedCallback(t, e, n) {
    this._$AK(t, n);
  }
  _$EC(t, e) {
    var n;
    const o = this.constructor.elementProperties.get(t), s = this.constructor._$Eu(t, o);
    if (s !== void 0 && o.reflect === !0) {
      const r = (((n = o.converter) == null ? void 0 : n.toAttribute) !== void 0 ? o.converter : di).toAttribute(e, o.type);
      this._$Em = t, r == null ? this.removeAttribute(s) : this.setAttribute(s, r), this._$Em = null;
    }
  }
  _$AK(t, e) {
    var n;
    const o = this.constructor, s = o._$Eh.get(t);
    if (s !== void 0 && this._$Em !== s) {
      const r = o.getPropertyOptions(s), a = typeof r.converter == "function" ? { fromAttribute: r.converter } : ((n = r.converter) == null ? void 0 : n.fromAttribute) !== void 0 ? r.converter : di;
      this._$Em = s, this[s] = a.fromAttribute(e, r.type), this._$Em = null;
    }
  }
  requestUpdate(t, e, n) {
    if (t !== void 0) {
      if (n ?? (n = this.constructor.getPropertyOptions(t)), !(n.hasChanged ?? En)(this[t], e))
        return;
      this.P(t, e, n);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$ET());
  }
  P(t, e, n) {
    this._$AL.has(t) || this._$AL.set(t, e), n.reflect === !0 && this._$Em !== t && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(t);
  }
  async _$ET() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (e) {
      Promise.reject(e);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var t;
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [s, r] of this._$Ep)
          this[s] = r;
        this._$Ep = void 0;
      }
      const o = this.constructor.elementProperties;
      if (o.size > 0)
        for (const [s, r] of o)
          r.wrapped !== !0 || this._$AL.has(s) || this[s] === void 0 || this.P(s, this[s], r);
    }
    let e = !1;
    const n = this._$AL;
    try {
      e = this.shouldUpdate(n), e ? (this.willUpdate(n), (t = this._$EO) == null || t.forEach((o) => {
        var s;
        return (s = o.hostUpdate) == null ? void 0 : s.call(o);
      }), this.update(n)) : this._$EU();
    } catch (o) {
      throw e = !1, this._$EU(), o;
    }
    e && this._$AE(n);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    var e;
    (e = this._$EO) == null || e.forEach((n) => {
      var o;
      return (o = n.hostUpdated) == null ? void 0 : o.call(n);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((e) => this._$EC(e, this[e]))), this._$EU();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
}
Xt.elementStyles = [], Xt.shadowRootOptions = { mode: "open" }, Xt[xe("elementProperties")] = /* @__PURE__ */ new Map(), Xt[xe("finalized")] = /* @__PURE__ */ new Map(), eo == null || eo({ ReactiveElement: Xt }), (ee.reactiveElementVersions ?? (ee.reactiveElementVersions = [])).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ui = globalThis, hi = ui.trustedTypes, no = hi ? hi.createPolicy("lit-html", { createHTML: (i) => i }) : void 0, ms = "$lit$", xt = `lit$${Math.random().toFixed(9).slice(2)}$`, fs = "?" + xt, Ia = `<${fs}>`, Ht = document, Ie = () => Ht.createComment(""), Re = (i) => i === null || typeof i != "object" && typeof i != "function", Sn = Array.isArray, Ra = (i) => Sn(i) || typeof (i == null ? void 0 : i[Symbol.iterator]) == "function", Ui = `[ 	
\f\r]`, ve = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, oo = /-->/g, so = />/g, Mt = RegExp(`>|${Ui}(?:([^\\s"'>=/]+)(${Ui}*=${Ui}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), ro = /'/g, ao = /"/g, bs = /^(?:script|style|textarea|title)$/i, Pa = (i) => (t, ...e) => ({ _$litType$: i, strings: t, values: e }), f = Pa(1), Ut = Symbol.for("lit-noChange"), j = Symbol.for("lit-nothing"), lo = /* @__PURE__ */ new WeakMap(), Dt = Ht.createTreeWalker(Ht, 129);
function gs(i, t) {
  if (!Sn(i) || !i.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return no !== void 0 ? no.createHTML(t) : t;
}
const Na = (i, t) => {
  const e = i.length - 1, n = [];
  let o, s = t === 2 ? "<svg>" : t === 3 ? "<math>" : "", r = ve;
  for (let a = 0; a < e; a++) {
    const l = i[a];
    let c, h, u = -1, p = 0;
    for (; p < l.length && (r.lastIndex = p, h = r.exec(l), h !== null); )
      p = r.lastIndex, r === ve ? h[1] === "!--" ? r = oo : h[1] !== void 0 ? r = so : h[2] !== void 0 ? (bs.test(h[2]) && (o = RegExp("</" + h[2], "g")), r = Mt) : h[3] !== void 0 && (r = Mt) : r === Mt ? h[0] === ">" ? (r = o ?? ve, u = -1) : h[1] === void 0 ? u = -2 : (u = r.lastIndex - h[2].length, c = h[1], r = h[3] === void 0 ? Mt : h[3] === '"' ? ao : ro) : r === ao || r === ro ? r = Mt : r === oo || r === so ? r = ve : (r = Mt, o = void 0);
    const d = r === Mt && i[a + 1].startsWith("/>") ? " " : "";
    s += r === ve ? l + Ia : u >= 0 ? (n.push(c), l.slice(0, u) + ms + l.slice(u) + xt + d) : l + xt + (u === -2 ? a : d);
  }
  return [gs(i, s + (i[e] || "<?>") + (t === 2 ? "</svg>" : t === 3 ? "</math>" : "")), n];
};
class Pe {
  constructor({ strings: t, _$litType$: e }, n) {
    let o;
    this.parts = [];
    let s = 0, r = 0;
    const a = t.length - 1, l = this.parts, [c, h] = Na(t, e);
    if (this.el = Pe.createElement(c, n), Dt.currentNode = this.el.content, e === 2 || e === 3) {
      const u = this.el.content.firstChild;
      u.replaceWith(...u.childNodes);
    }
    for (; (o = Dt.nextNode()) !== null && l.length < a; ) {
      if (o.nodeType === 1) {
        if (o.hasAttributes())
          for (const u of o.getAttributeNames())
            if (u.endsWith(ms)) {
              const p = h[r++], d = o.getAttribute(u).split(xt), m = /([.?@])?(.*)/.exec(p);
              l.push({ type: 1, index: s, name: m[2], strings: d, ctor: m[1] === "." ? La : m[1] === "?" ? Da : m[1] === "@" ? Fa : ki }), o.removeAttribute(u);
            } else
              u.startsWith(xt) && (l.push({ type: 6, index: s }), o.removeAttribute(u));
        if (bs.test(o.tagName)) {
          const u = o.textContent.split(xt), p = u.length - 1;
          if (p > 0) {
            o.textContent = hi ? hi.emptyScript : "";
            for (let d = 0; d < p; d++)
              o.append(u[d], Ie()), Dt.nextNode(), l.push({ type: 2, index: ++s });
            o.append(u[p], Ie());
          }
        }
      } else if (o.nodeType === 8)
        if (o.data === fs)
          l.push({ type: 2, index: s });
        else {
          let u = -1;
          for (; (u = o.data.indexOf(xt, u + 1)) !== -1; )
            l.push({ type: 7, index: s }), u += xt.length - 1;
        }
      s++;
    }
  }
  static createElement(t, e) {
    const n = Ht.createElement("template");
    return n.innerHTML = t, n;
  }
}
function ie(i, t, e = i, n) {
  var o, s;
  if (t === Ut)
    return t;
  let r = n !== void 0 ? (o = e.o) == null ? void 0 : o[n] : e.l;
  const a = Re(t) ? void 0 : t._$litDirective$;
  return (r == null ? void 0 : r.constructor) !== a && ((s = r == null ? void 0 : r._$AO) == null || s.call(r, !1), a === void 0 ? r = void 0 : (r = new a(i), r._$AT(i, e, n)), n !== void 0 ? (e.o ?? (e.o = []))[n] = r : e.l = r), r !== void 0 && (t = ie(i, r._$AS(i, t.values), r, n)), t;
}
class Ma {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    const { el: { content: e }, parts: n } = this._$AD, o = ((t == null ? void 0 : t.creationScope) ?? Ht).importNode(e, !0);
    Dt.currentNode = o;
    let s = Dt.nextNode(), r = 0, a = 0, l = n[0];
    for (; l !== void 0; ) {
      if (r === l.index) {
        let c;
        l.type === 2 ? c = new He(s, s.nextSibling, this, t) : l.type === 1 ? c = new l.ctor(s, l.name, l.strings, this, t) : l.type === 6 && (c = new za(s, this, t)), this._$AV.push(c), l = n[++a];
      }
      r !== (l == null ? void 0 : l.index) && (s = Dt.nextNode(), r++);
    }
    return Dt.currentNode = Ht, o;
  }
  p(t) {
    let e = 0;
    for (const n of this._$AV)
      n !== void 0 && (n.strings !== void 0 ? (n._$AI(t, n, e), e += n.strings.length - 2) : n._$AI(t[e])), e++;
  }
}
class He {
  get _$AU() {
    var t;
    return ((t = this._$AM) == null ? void 0 : t._$AU) ?? this.v;
  }
  constructor(t, e, n, o) {
    this.type = 2, this._$AH = j, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = n, this.options = o, this.v = (o == null ? void 0 : o.isConnected) ?? !0;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = ie(this, t, e), Re(t) ? t === j || t == null || t === "" ? (this._$AH !== j && this._$AR(), this._$AH = j) : t !== this._$AH && t !== Ut && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : Ra(t) ? this.k(t) : this._(t);
  }
  O(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.O(t));
  }
  _(t) {
    this._$AH !== j && Re(this._$AH) ? this._$AA.nextSibling.data = t : this.T(Ht.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    var e;
    const { values: n, _$litType$: o } = t, s = typeof o == "number" ? this._$AC(t) : (o.el === void 0 && (o.el = Pe.createElement(gs(o.h, o.h[0]), this.options)), o);
    if (((e = this._$AH) == null ? void 0 : e._$AD) === s)
      this._$AH.p(n);
    else {
      const r = new Ma(s, this), a = r.u(this.options);
      r.p(n), this.T(a), this._$AH = r;
    }
  }
  _$AC(t) {
    let e = lo.get(t.strings);
    return e === void 0 && lo.set(t.strings, e = new Pe(t)), e;
  }
  k(t) {
    Sn(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let n, o = 0;
    for (const s of t)
      o === e.length ? e.push(n = new He(this.O(Ie()), this.O(Ie()), this, this.options)) : n = e[o], n._$AI(s), o++;
    o < e.length && (this._$AR(n && n._$AB.nextSibling, o), e.length = o);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    var n;
    for ((n = this._$AP) == null ? void 0 : n.call(this, !1, !0, e); t && t !== this._$AB; ) {
      const o = t.nextSibling;
      t.remove(), t = o;
    }
  }
  setConnected(t) {
    var e;
    this._$AM === void 0 && (this.v = t, (e = this._$AP) == null || e.call(this, t));
  }
}
class ki {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, e, n, o, s) {
    this.type = 1, this._$AH = j, this._$AN = void 0, this.element = t, this.name = e, this._$AM = o, this.options = s, n.length > 2 || n[0] !== "" || n[1] !== "" ? (this._$AH = Array(n.length - 1).fill(new String()), this.strings = n) : this._$AH = j;
  }
  _$AI(t, e = this, n, o) {
    const s = this.strings;
    let r = !1;
    if (s === void 0)
      t = ie(this, t, e, 0), r = !Re(t) || t !== this._$AH && t !== Ut, r && (this._$AH = t);
    else {
      const a = t;
      let l, c;
      for (t = s[0], l = 0; l < s.length - 1; l++)
        c = ie(this, a[n + l], e, l), c === Ut && (c = this._$AH[l]), r || (r = !Re(c) || c !== this._$AH[l]), c === j ? t = j : t !== j && (t += (c ?? "") + s[l + 1]), this._$AH[l] = c;
    }
    r && !o && this.j(t);
  }
  j(t) {
    t === j ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
}
class La extends ki {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === j ? void 0 : t;
  }
}
class Da extends ki {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== j);
  }
}
class Fa extends ki {
  constructor(t, e, n, o, s) {
    super(t, e, n, o, s), this.type = 5;
  }
  _$AI(t, e = this) {
    if ((t = ie(this, t, e, 0) ?? j) === Ut)
      return;
    const n = this._$AH, o = t === j && n !== j || t.capture !== n.capture || t.once !== n.once || t.passive !== n.passive, s = t !== j && (n === j || o);
    o && this.element.removeEventListener(this.name, this, n), s && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var e;
    typeof this._$AH == "function" ? this._$AH.call(((e = this.options) == null ? void 0 : e.host) ?? this.element, t) : this._$AH.handleEvent(t);
  }
}
class za {
  constructor(t, e, n) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = n;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    ie(this, t);
  }
}
const co = ui.litHtmlPolyfillSupport;
co == null || co(Pe, He), (ui.litHtmlVersions ?? (ui.litHtmlVersions = [])).push("3.2.0");
const ne = (i, t, e) => {
  const n = (e == null ? void 0 : e.renderBefore) ?? t;
  let o = n._$litPart$;
  if (o === void 0) {
    const s = (e == null ? void 0 : e.renderBefore) ?? null;
    n._$litPart$ = o = new He(t.insertBefore(Ie(), s), s, void 0, e ?? {});
  }
  return o._$AI(i), o;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let I = class extends Xt {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this.o = void 0;
  }
  createRenderRoot() {
    var t;
    const e = super.createRenderRoot();
    return (t = this.renderOptions).renderBefore ?? (t.renderBefore = e.firstChild), e;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this.o = ne(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this.o) == null || t.setConnected(!0);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this.o) == null || t.setConnected(!1);
  }
  render() {
    return Ut;
  }
};
var uo;
I._$litElement$ = !0, I.finalized = !0, (uo = globalThis.litElementHydrateSupport) == null || uo.call(globalThis, { LitElement: I });
const ho = globalThis.litElementPolyfillSupport;
ho == null || ho({ LitElement: I });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.1.0");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ja = { attribute: !0, type: String, converter: di, reflect: !1, hasChanged: En }, Ba = (i = ja, t, e) => {
  const { kind: n, metadata: o } = e;
  let s = globalThis.litPropertyMetadata.get(o);
  if (s === void 0 && globalThis.litPropertyMetadata.set(o, s = /* @__PURE__ */ new Map()), s.set(e.name, i), n === "accessor") {
    const { name: r } = e;
    return { set(a) {
      const l = t.get.call(this);
      t.set.call(this, a), this.requestUpdate(r, l, i);
    }, init(a) {
      return a !== void 0 && this.P(r, void 0, i), a;
    } };
  }
  if (n === "setter") {
    const { name: r } = e;
    return function(a) {
      const l = this[r];
      t.call(this, a), this.requestUpdate(r, l, i);
    };
  }
  throw Error("Unsupported decorator location: " + n);
};
function b(i) {
  return (t, e) => typeof e == "object" ? Ba(i, t, e) : ((n, o, s) => {
    const r = o.hasOwnProperty(s);
    return o.constructor.createProperty(s, r ? { ...n, wrapped: !0 } : n), r ? Object.getOwnPropertyDescriptor(o, s) : void 0;
  })(i, t, e);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function le(i) {
  return b({ ...i, state: !0, attribute: !1 });
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Ha = (i) => i.strings === void 0;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const vs = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 }, ys = (i) => (...t) => ({ _$litDirective$: i, values: t });
class _s {
  constructor(t) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, e, n) {
    this.t = t, this._$AM = e, this.i = n;
  }
  _$AS(t, e) {
    return this.update(t, e);
  }
  update(t, e) {
    return this.render(...e);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const $e = (i, t) => {
  var e;
  const n = i._$AN;
  if (n === void 0)
    return !1;
  for (const o of n)
    (e = o._$AO) == null || e.call(o, t, !1), $e(o, t);
  return !0;
}, pi = (i) => {
  let t, e;
  do {
    if ((t = i._$AM) === void 0)
      break;
    e = t._$AN, e.delete(i), i = t;
  } while ((e == null ? void 0 : e.size) === 0);
}, ws = (i) => {
  for (let t; t = i._$AM; i = t) {
    let e = t._$AN;
    if (e === void 0)
      t._$AN = e = /* @__PURE__ */ new Set();
    else if (e.has(i))
      break;
    e.add(i), Wa(t);
  }
};
function Ua(i) {
  this._$AN !== void 0 ? (pi(this), this._$AM = i, ws(this)) : this._$AM = i;
}
function Va(i, t = !1, e = 0) {
  const n = this._$AH, o = this._$AN;
  if (o !== void 0 && o.size !== 0)
    if (t)
      if (Array.isArray(n))
        for (let s = e; s < n.length; s++)
          $e(n[s], !1), pi(n[s]);
      else
        n != null && ($e(n, !1), pi(n));
    else
      $e(this, i);
}
const Wa = (i) => {
  i.type == vs.CHILD && (i._$AP ?? (i._$AP = Va), i._$AQ ?? (i._$AQ = Ua));
};
class Ga extends _s {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(t, e, n) {
    super._$AT(t, e, n), ws(this), this.isConnected = t._$AU;
  }
  _$AO(t, e = !0) {
    var n, o;
    t !== this.isConnected && (this.isConnected = t, t ? (n = this.reconnected) == null || n.call(this) : (o = this.disconnected) == null || o.call(this)), e && ($e(this, t), pi(this));
  }
  setValue(t) {
    if (Ha(this.t))
      this.t._$AI(t, this);
    else {
      const e = [...this.t._$AH];
      e[this.i] = t, this.t._$AI(e, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const oe = () => new qa();
class qa {
}
const Vi = /* @__PURE__ */ new WeakMap(), J = ys(class extends Ga {
  render(i) {
    return j;
  }
  update(i, [t]) {
    var e;
    const n = t !== this.Y;
    return n && this.Y !== void 0 && this.rt(void 0), (n || this.lt !== this.ct) && (this.Y = t, this.ht = (e = i.options) == null ? void 0 : e.host, this.rt(this.ct = i.element)), j;
  }
  rt(i) {
    if (this.isConnected || (i = void 0), typeof this.Y == "function") {
      const t = this.ht ?? globalThis;
      let e = Vi.get(t);
      e === void 0 && (e = /* @__PURE__ */ new WeakMap(), Vi.set(t, e)), e.get(this.Y) !== void 0 && this.Y.call(this.ht, void 0), e.set(this.Y, i), i !== void 0 && this.Y.call(this.ht, i);
    } else
      this.Y.value = i;
  }
  get lt() {
    var i, t;
    return typeof this.Y == "function" ? (i = Vi.get(this.ht ?? globalThis)) == null ? void 0 : i.get(this.Y) : (t = this.Y) == null ? void 0 : t.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
/**
* (c) Iconify
*
* For the full copyright and license information, please view the license.txt
* files at https://github.com/iconify/iconify
*
* Licensed under MIT.
*
* @license MIT
* @version 2.0.0
*/
const xs = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
), mi = Object.freeze({
  rotate: 0,
  vFlip: !1,
  hFlip: !1
}), Ue = Object.freeze({
  ...xs,
  ...mi
}), rn = Object.freeze({
  ...Ue,
  body: "",
  hidden: !1
}), Ya = Object.freeze({
  width: null,
  height: null
}), $s = Object.freeze({
  // Dimensions
  ...Ya,
  // Transformations
  ...mi
});
function Xa(i, t = 0) {
  const e = i.replace(/^-?[0-9.]*/, "");
  function n(o) {
    for (; o < 0; )
      o += 4;
    return o % 4;
  }
  if (e === "") {
    const o = parseInt(i);
    return isNaN(o) ? 0 : n(o);
  } else if (e !== i) {
    let o = 0;
    switch (e) {
      case "%":
        o = 25;
        break;
      case "deg":
        o = 90;
    }
    if (o) {
      let s = parseFloat(i.slice(0, i.length - e.length));
      return isNaN(s) ? 0 : (s = s / o, s % 1 === 0 ? n(s) : 0);
    }
  }
  return t;
}
const Ja = /[\s,]+/;
function Qa(i, t) {
  t.split(Ja).forEach((e) => {
    switch (e.trim()) {
      case "horizontal":
        i.hFlip = !0;
        break;
      case "vertical":
        i.vFlip = !0;
        break;
    }
  });
}
const Cs = {
  ...$s,
  preserveAspectRatio: ""
};
function po(i) {
  const t = {
    ...Cs
  }, e = (n, o) => i.getAttribute(n) || o;
  return t.width = e("width", null), t.height = e("height", null), t.rotate = Xa(e("rotate", "")), Qa(t, e("flip", "")), t.preserveAspectRatio = e("preserveAspectRatio", e("preserveaspectratio", "")), t;
}
function Ka(i, t) {
  for (const e in Cs)
    if (i[e] !== t[e])
      return !0;
  return !1;
}
const Ce = /^[a-z0-9]+(-[a-z0-9]+)*$/, Ve = (i, t, e, n = "") => {
  const o = i.split(":");
  if (i.slice(0, 1) === "@") {
    if (o.length < 2 || o.length > 3)
      return null;
    n = o.shift().slice(1);
  }
  if (o.length > 3 || !o.length)
    return null;
  if (o.length > 1) {
    const a = o.pop(), l = o.pop(), c = {
      // Allow provider without '@': "provider:prefix:name"
      provider: o.length > 0 ? o[0] : n,
      prefix: l,
      name: a
    };
    return t && !ni(c) ? null : c;
  }
  const s = o[0], r = s.split("-");
  if (r.length > 1) {
    const a = {
      provider: n,
      prefix: r.shift(),
      name: r.join("-")
    };
    return t && !ni(a) ? null : a;
  }
  if (e && n === "") {
    const a = {
      provider: n,
      prefix: "",
      name: s
    };
    return t && !ni(a, e) ? null : a;
  }
  return null;
}, ni = (i, t) => i ? !!((i.provider === "" || i.provider.match(Ce)) && (t && i.prefix === "" || i.prefix.match(Ce)) && i.name.match(Ce)) : !1;
function Za(i, t) {
  const e = {};
  !i.hFlip != !t.hFlip && (e.hFlip = !0), !i.vFlip != !t.vFlip && (e.vFlip = !0);
  const n = ((i.rotate || 0) + (t.rotate || 0)) % 4;
  return n && (e.rotate = n), e;
}
function mo(i, t) {
  const e = Za(i, t);
  for (const n in rn)
    n in mi ? n in i && !(n in e) && (e[n] = mi[n]) : n in t ? e[n] = t[n] : n in i && (e[n] = i[n]);
  return e;
}
function tl(i, t) {
  const e = i.icons, n = i.aliases || /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ Object.create(null);
  function s(r) {
    if (e[r])
      return o[r] = [];
    if (!(r in o)) {
      o[r] = null;
      const a = n[r] && n[r].parent, l = a && s(a);
      l && (o[r] = [a].concat(l));
    }
    return o[r];
  }
  return Object.keys(e).concat(Object.keys(n)).forEach(s), o;
}
function el(i, t, e) {
  const n = i.icons, o = i.aliases || /* @__PURE__ */ Object.create(null);
  let s = {};
  function r(a) {
    s = mo(
      n[a] || o[a],
      s
    );
  }
  return r(t), e.forEach(r), mo(i, s);
}
function As(i, t) {
  const e = [];
  if (typeof i != "object" || typeof i.icons != "object")
    return e;
  i.not_found instanceof Array && i.not_found.forEach((o) => {
    t(o, null), e.push(o);
  });
  const n = tl(i);
  for (const o in n) {
    const s = n[o];
    s && (t(o, el(i, o, s)), e.push(o));
  }
  return e;
}
const il = {
  provider: "",
  aliases: {},
  not_found: {},
  ...xs
};
function Wi(i, t) {
  for (const e in t)
    if (e in i && typeof i[e] != typeof t[e])
      return !1;
  return !0;
}
function Es(i) {
  if (typeof i != "object" || i === null)
    return null;
  const t = i;
  if (typeof t.prefix != "string" || !i.icons || typeof i.icons != "object" || !Wi(i, il))
    return null;
  const e = t.icons;
  for (const o in e) {
    const s = e[o];
    if (!o.match(Ce) || typeof s.body != "string" || !Wi(
      s,
      rn
    ))
      return null;
  }
  const n = t.aliases || /* @__PURE__ */ Object.create(null);
  for (const o in n) {
    const s = n[o], r = s.parent;
    if (!o.match(Ce) || typeof r != "string" || !e[r] && !n[r] || !Wi(
      s,
      rn
    ))
      return null;
  }
  return t;
}
const fi = /* @__PURE__ */ Object.create(null);
function nl(i, t) {
  return {
    provider: i,
    prefix: t,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function St(i, t) {
  const e = fi[i] || (fi[i] = /* @__PURE__ */ Object.create(null));
  return e[t] || (e[t] = nl(i, t));
}
function kn(i, t) {
  return Es(t) ? As(t, (e, n) => {
    n ? i.icons[e] = n : i.missing.add(e);
  }) : [];
}
function ol(i, t, e) {
  try {
    if (typeof e.body == "string")
      return i.icons[t] = { ...e }, !0;
  } catch {
  }
  return !1;
}
function sl(i, t) {
  let e = [];
  return (typeof i == "string" ? [i] : Object.keys(fi)).forEach((n) => {
    (typeof n == "string" && typeof t == "string" ? [t] : Object.keys(fi[n] || {})).forEach((o) => {
      const s = St(n, o);
      e = e.concat(
        Object.keys(s.icons).map(
          (r) => (n !== "" ? "@" + n + ":" : "") + o + ":" + r
        )
      );
    });
  }), e;
}
let Ne = !1;
function Ss(i) {
  return typeof i == "boolean" && (Ne = i), Ne;
}
function Me(i) {
  const t = typeof i == "string" ? Ve(i, !0, Ne) : i;
  if (t) {
    const e = St(t.provider, t.prefix), n = t.name;
    return e.icons[n] || (e.missing.has(n) ? null : void 0);
  }
}
function ks(i, t) {
  const e = Ve(i, !0, Ne);
  if (!e)
    return !1;
  const n = St(e.provider, e.prefix);
  return ol(n, e.name, t);
}
function fo(i, t) {
  if (typeof i != "object")
    return !1;
  if (typeof t != "string" && (t = i.provider || ""), Ne && !t && !i.prefix) {
    let o = !1;
    return Es(i) && (i.prefix = "", As(i, (s, r) => {
      r && ks(s, r) && (o = !0);
    })), o;
  }
  const e = i.prefix;
  if (!ni({
    provider: t,
    prefix: e,
    name: "a"
  }))
    return !1;
  const n = St(t, e);
  return !!kn(n, i);
}
function bo(i) {
  return !!Me(i);
}
function rl(i) {
  const t = Me(i);
  return t ? {
    ...Ue,
    ...t
  } : null;
}
function al(i) {
  const t = {
    loaded: [],
    missing: [],
    pending: []
  }, e = /* @__PURE__ */ Object.create(null);
  i.sort((o, s) => o.provider !== s.provider ? o.provider.localeCompare(s.provider) : o.prefix !== s.prefix ? o.prefix.localeCompare(s.prefix) : o.name.localeCompare(s.name));
  let n = {
    provider: "",
    prefix: "",
    name: ""
  };
  return i.forEach((o) => {
    if (n.name === o.name && n.prefix === o.prefix && n.provider === o.provider)
      return;
    n = o;
    const s = o.provider, r = o.prefix, a = o.name, l = e[s] || (e[s] = /* @__PURE__ */ Object.create(null)), c = l[r] || (l[r] = St(s, r));
    let h;
    a in c.icons ? h = t.loaded : r === "" || c.missing.has(a) ? h = t.missing : h = t.pending;
    const u = {
      provider: s,
      prefix: r,
      name: a
    };
    h.push(u);
  }), t;
}
function Ts(i, t) {
  i.forEach((e) => {
    const n = e.loaderCallbacks;
    n && (e.loaderCallbacks = n.filter((o) => o.id !== t));
  });
}
function ll(i) {
  i.pendingCallbacksFlag || (i.pendingCallbacksFlag = !0, setTimeout(() => {
    i.pendingCallbacksFlag = !1;
    const t = i.loaderCallbacks ? i.loaderCallbacks.slice(0) : [];
    if (!t.length)
      return;
    let e = !1;
    const n = i.provider, o = i.prefix;
    t.forEach((s) => {
      const r = s.icons, a = r.pending.length;
      r.pending = r.pending.filter((l) => {
        if (l.prefix !== o)
          return !0;
        const c = l.name;
        if (i.icons[c])
          r.loaded.push({
            provider: n,
            prefix: o,
            name: c
          });
        else if (i.missing.has(c))
          r.missing.push({
            provider: n,
            prefix: o,
            name: c
          });
        else
          return e = !0, !0;
        return !1;
      }), r.pending.length !== a && (e || Ts([i], s.id), s.callback(
        r.loaded.slice(0),
        r.missing.slice(0),
        r.pending.slice(0),
        s.abort
      ));
    });
  }));
}
let cl = 0;
function dl(i, t, e) {
  const n = cl++, o = Ts.bind(null, e, n);
  if (!t.pending.length)
    return o;
  const s = {
    id: n,
    icons: t,
    callback: i,
    abort: o
  };
  return e.forEach((r) => {
    (r.loaderCallbacks || (r.loaderCallbacks = [])).push(s);
  }), o;
}
const an = /* @__PURE__ */ Object.create(null);
function go(i, t) {
  an[i] = t;
}
function ln(i) {
  return an[i] || an[""];
}
function ul(i, t = !0, e = !1) {
  const n = [];
  return i.forEach((o) => {
    const s = typeof o == "string" ? Ve(o, t, e) : o;
    s && n.push(s);
  }), n;
}
var hl = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: !1,
  dataAfterTimeout: !1
};
function pl(i, t, e, n) {
  const o = i.resources.length, s = i.random ? Math.floor(Math.random() * o) : i.index;
  let r;
  if (i.random) {
    let _ = i.resources.slice(0);
    for (r = []; _.length > 1; ) {
      const E = Math.floor(Math.random() * _.length);
      r.push(_[E]), _ = _.slice(0, E).concat(_.slice(E + 1));
    }
    r = r.concat(_);
  } else
    r = i.resources.slice(s).concat(i.resources.slice(0, s));
  const a = Date.now();
  let l = "pending", c = 0, h, u = null, p = [], d = [];
  typeof n == "function" && d.push(n);
  function m() {
    u && (clearTimeout(u), u = null);
  }
  function v() {
    l === "pending" && (l = "aborted"), m(), p.forEach((_) => {
      _.status === "pending" && (_.status = "aborted");
    }), p = [];
  }
  function w(_, E) {
    E && (d = []), typeof _ == "function" && d.push(_);
  }
  function C() {
    return {
      startTime: a,
      payload: t,
      status: l,
      queriesSent: c,
      queriesPending: p.length,
      subscribe: w,
      abort: v
    };
  }
  function x() {
    l = "failed", d.forEach((_) => {
      _(void 0, h);
    });
  }
  function g() {
    p.forEach((_) => {
      _.status === "pending" && (_.status = "aborted");
    }), p = [];
  }
  function y(_, E, L) {
    const D = E !== "success";
    switch (p = p.filter((T) => T !== _), l) {
      case "pending":
        break;
      case "failed":
        if (D || !i.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (E === "abort") {
      h = L, x();
      return;
    }
    if (D) {
      h = L, p.length || (r.length ? $() : x());
      return;
    }
    if (m(), g(), !i.random) {
      const T = i.resources.indexOf(_.resource);
      T !== -1 && T !== i.index && (i.index = T);
    }
    l = "completed", d.forEach((T) => {
      T(L);
    });
  }
  function $() {
    if (l !== "pending")
      return;
    m();
    const _ = r.shift();
    if (_ === void 0) {
      if (p.length) {
        u = setTimeout(() => {
          m(), l === "pending" && (g(), x());
        }, i.timeout);
        return;
      }
      x();
      return;
    }
    const E = {
      status: "pending",
      resource: _,
      callback: (L, D) => {
        y(E, L, D);
      }
    };
    p.push(E), c++, u = setTimeout($, i.rotate), e(_, t, E.callback);
  }
  return setTimeout($), C;
}
function Os(i) {
  const t = {
    ...hl,
    ...i
  };
  let e = [];
  function n() {
    e = e.filter((r) => r().status === "pending");
  }
  function o(r, a, l) {
    const c = pl(
      t,
      r,
      a,
      (h, u) => {
        n(), l && l(h, u);
      }
    );
    return e.push(c), c;
  }
  function s(r) {
    return e.find((a) => r(a)) || null;
  }
  return {
    query: o,
    find: s,
    setIndex: (r) => {
      t.index = r;
    },
    getIndex: () => t.index,
    cleanup: n
  };
}
function Tn(i) {
  let t;
  if (typeof i.resources == "string")
    t = [i.resources];
  else if (t = i.resources, !(t instanceof Array) || !t.length)
    return null;
  return {
    // API hosts
    resources: t,
    // Root path
    path: i.path || "/",
    // URL length limit
    maxURL: i.maxURL || 500,
    // Timeout before next host is used.
    rotate: i.rotate || 750,
    // Timeout before failing query.
    timeout: i.timeout || 5e3,
    // Randomise default API end point.
    random: i.random === !0,
    // Start index
    index: i.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: i.dataAfterTimeout !== !1
  };
}
const Ti = /* @__PURE__ */ Object.create(null), Ze = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
], cn = [];
for (; Ze.length > 0; )
  Ze.length === 1 || Math.random() > 0.5 ? cn.push(Ze.shift()) : cn.push(Ze.pop());
Ti[""] = Tn({
  resources: ["https://api.iconify.design"].concat(cn)
});
function vo(i, t) {
  const e = Tn(t);
  return e === null ? !1 : (Ti[i] = e, !0);
}
function Oi(i) {
  return Ti[i];
}
function ml() {
  return Object.keys(Ti);
}
function yo() {
}
const Gi = /* @__PURE__ */ Object.create(null);
function fl(i) {
  if (!Gi[i]) {
    const t = Oi(i);
    if (!t)
      return;
    const e = Os(t), n = {
      config: t,
      redundancy: e
    };
    Gi[i] = n;
  }
  return Gi[i];
}
function Is(i, t, e) {
  let n, o;
  if (typeof i == "string") {
    const s = ln(i);
    if (!s)
      return e(void 0, 424), yo;
    o = s.send;
    const r = fl(i);
    r && (n = r.redundancy);
  } else {
    const s = Tn(i);
    if (s) {
      n = Os(s);
      const r = i.resources ? i.resources[0] : "", a = ln(r);
      a && (o = a.send);
    }
  }
  return !n || !o ? (e(void 0, 424), yo) : n.query(t, o, e)().abort;
}
const _o = "iconify2", Le = "iconify", Rs = Le + "-count", wo = Le + "-version", Ps = 36e5, bl = 168, gl = 50;
function dn(i, t) {
  try {
    return i.getItem(t);
  } catch {
  }
}
function On(i, t, e) {
  try {
    return i.setItem(t, e), !0;
  } catch {
  }
}
function xo(i, t) {
  try {
    i.removeItem(t);
  } catch {
  }
}
function un(i, t) {
  return On(i, Rs, t.toString());
}
function hn(i) {
  return parseInt(dn(i, Rs)) || 0;
}
const zt = {
  local: !0,
  session: !0
}, Ns = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
let In = !1;
function vl(i) {
  In = i;
}
let ti = typeof window > "u" ? {} : window;
function Ms(i) {
  const t = i + "Storage";
  try {
    if (ti && ti[t] && typeof ti[t].length == "number")
      return ti[t];
  } catch {
  }
  zt[i] = !1;
}
function Ls(i, t) {
  const e = Ms(i);
  if (!e)
    return;
  const n = dn(e, wo);
  if (n !== _o) {
    if (n) {
      const a = hn(e);
      for (let l = 0; l < a; l++)
        xo(e, Le + l.toString());
    }
    On(e, wo, _o), un(e, 0);
    return;
  }
  const o = Math.floor(Date.now() / Ps) - bl, s = (a) => {
    const l = Le + a.toString(), c = dn(e, l);
    if (typeof c == "string") {
      try {
        const h = JSON.parse(c);
        if (typeof h == "object" && typeof h.cached == "number" && h.cached > o && typeof h.provider == "string" && typeof h.data == "object" && typeof h.data.prefix == "string" && // Valid item: run callback
        t(h, a))
          return !0;
      } catch {
      }
      xo(e, l);
    }
  };
  let r = hn(e);
  for (let a = r - 1; a >= 0; a--)
    s(a) || (a === r - 1 ? (r--, un(e, r)) : Ns[i].add(a));
}
function Ds() {
  if (!In) {
    vl(!0);
    for (const i in zt)
      Ls(i, (t) => {
        const e = t.data, n = t.provider, o = e.prefix, s = St(
          n,
          o
        );
        if (!kn(s, e).length)
          return !1;
        const r = e.lastModified || -1;
        return s.lastModifiedCached = s.lastModifiedCached ? Math.min(s.lastModifiedCached, r) : r, !0;
      });
  }
}
function yl(i, t) {
  const e = i.lastModifiedCached;
  if (
    // Matches or newer
    e && e >= t
  )
    return e === t;
  if (i.lastModifiedCached = t, e)
    for (const n in zt)
      Ls(n, (o) => {
        const s = o.data;
        return o.provider !== i.provider || s.prefix !== i.prefix || s.lastModified === t;
      });
  return !0;
}
function _l(i, t) {
  In || Ds();
  function e(n) {
    let o;
    if (!zt[n] || !(o = Ms(n)))
      return;
    const s = Ns[n];
    let r;
    if (s.size)
      s.delete(r = Array.from(s).shift());
    else if (r = hn(o), r >= gl || !un(o, r + 1))
      return;
    const a = {
      cached: Math.floor(Date.now() / Ps),
      provider: i.provider,
      data: t
    };
    return On(
      o,
      Le + r.toString(),
      JSON.stringify(a)
    );
  }
  t.lastModified && !yl(i, t.lastModified) || Object.keys(t.icons).length && (t.not_found && (t = Object.assign({}, t), delete t.not_found), e("local") || e("session"));
}
function $o() {
}
function wl(i) {
  i.iconsLoaderFlag || (i.iconsLoaderFlag = !0, setTimeout(() => {
    i.iconsLoaderFlag = !1, ll(i);
  }));
}
function xl(i, t) {
  i.iconsToLoad ? i.iconsToLoad = i.iconsToLoad.concat(t).sort() : i.iconsToLoad = t, i.iconsQueueFlag || (i.iconsQueueFlag = !0, setTimeout(() => {
    i.iconsQueueFlag = !1;
    const { provider: e, prefix: n } = i, o = i.iconsToLoad;
    delete i.iconsToLoad;
    let s;
    !o || !(s = ln(e)) || s.prepare(e, n, o).forEach((r) => {
      Is(e, r, (a) => {
        if (typeof a != "object")
          r.icons.forEach((l) => {
            i.missing.add(l);
          });
        else
          try {
            const l = kn(
              i,
              a
            );
            if (!l.length)
              return;
            const c = i.pendingIcons;
            c && l.forEach((h) => {
              c.delete(h);
            }), _l(i, a);
          } catch (l) {
            console.error(l);
          }
        wl(i);
      });
    });
  }));
}
const Rn = (i, t) => {
  const e = ul(i, !0, Ss()), n = al(e);
  if (!n.pending.length) {
    let l = !0;
    return t && setTimeout(() => {
      l && t(
        n.loaded,
        n.missing,
        n.pending,
        $o
      );
    }), () => {
      l = !1;
    };
  }
  const o = /* @__PURE__ */ Object.create(null), s = [];
  let r, a;
  return n.pending.forEach((l) => {
    const { provider: c, prefix: h } = l;
    if (h === a && c === r)
      return;
    r = c, a = h, s.push(St(c, h));
    const u = o[c] || (o[c] = /* @__PURE__ */ Object.create(null));
    u[h] || (u[h] = []);
  }), n.pending.forEach((l) => {
    const { provider: c, prefix: h, name: u } = l, p = St(c, h), d = p.pendingIcons || (p.pendingIcons = /* @__PURE__ */ new Set());
    d.has(u) || (d.add(u), o[c][h].push(u));
  }), s.forEach((l) => {
    const { provider: c, prefix: h } = l;
    o[c][h].length && xl(l, o[c][h]);
  }), t ? dl(t, n, s) : $o;
}, $l = (i) => new Promise((t, e) => {
  const n = typeof i == "string" ? Ve(i, !0) : i;
  if (!n) {
    e(i);
    return;
  }
  Rn([n || i], (o) => {
    if (o.length && n) {
      const s = Me(n);
      if (s) {
        t({
          ...Ue,
          ...s
        });
        return;
      }
    }
    e(i);
  });
});
function Cl(i) {
  try {
    const t = typeof i == "string" ? JSON.parse(i) : i;
    if (typeof t.body == "string")
      return {
        ...t
      };
  } catch {
  }
}
function Al(i, t) {
  const e = typeof i == "string" ? Ve(i, !0, !0) : null;
  if (!e) {
    const s = Cl(i);
    return {
      value: i,
      data: s
    };
  }
  const n = Me(e);
  if (n !== void 0 || !e.prefix)
    return {
      value: i,
      name: e,
      data: n
      // could be 'null' -> icon is missing
    };
  const o = Rn([e], () => t(i, e, Me(e)));
  return {
    value: i,
    name: e,
    loading: o
  };
}
function qi(i) {
  return i.hasAttribute("inline");
}
let Fs = !1;
try {
  Fs = navigator.vendor.indexOf("Apple") === 0;
} catch {
}
function El(i, t) {
  switch (t) {
    case "svg":
    case "bg":
    case "mask":
      return t;
  }
  return t !== "style" && (Fs || i.indexOf("<a") === -1) ? "svg" : i.indexOf("currentColor") === -1 ? "bg" : "mask";
}
const Sl = /(-?[0-9.]*[0-9]+[0-9.]*)/g, kl = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function pn(i, t, e) {
  if (t === 1)
    return i;
  if (e = e || 100, typeof i == "number")
    return Math.ceil(i * t * e) / e;
  if (typeof i != "string")
    return i;
  const n = i.split(Sl);
  if (n === null || !n.length)
    return i;
  const o = [];
  let s = n.shift(), r = kl.test(s);
  for (; ; ) {
    if (r) {
      const a = parseFloat(s);
      isNaN(a) ? o.push(s) : o.push(Math.ceil(a * t * e) / e);
    } else
      o.push(s);
    if (s = n.shift(), s === void 0)
      return o.join("");
    r = !r;
  }
}
function Tl(i, t = "defs") {
  let e = "";
  const n = i.indexOf("<" + t);
  for (; n >= 0; ) {
    const o = i.indexOf(">", n), s = i.indexOf("</" + t);
    if (o === -1 || s === -1)
      break;
    const r = i.indexOf(">", s);
    if (r === -1)
      break;
    e += i.slice(o + 1, s).trim(), i = i.slice(0, n).trim() + i.slice(r + 1);
  }
  return {
    defs: e,
    content: i
  };
}
function Ol(i, t) {
  return i ? "<defs>" + i + "</defs>" + t : t;
}
function Il(i, t, e) {
  const n = Tl(i);
  return Ol(n.defs, t + n.content + e);
}
const Rl = (i) => i === "unset" || i === "undefined" || i === "none";
function zs(i, t) {
  const e = {
    ...Ue,
    ...i
  }, n = {
    ...$s,
    ...t
  }, o = {
    left: e.left,
    top: e.top,
    width: e.width,
    height: e.height
  };
  let s = e.body;
  [e, n].forEach((v) => {
    const w = [], C = v.hFlip, x = v.vFlip;
    let g = v.rotate;
    C ? x ? g += 2 : (w.push(
      "translate(" + (o.width + o.left).toString() + " " + (0 - o.top).toString() + ")"
    ), w.push("scale(-1 1)"), o.top = o.left = 0) : x && (w.push(
      "translate(" + (0 - o.left).toString() + " " + (o.height + o.top).toString() + ")"
    ), w.push("scale(1 -1)"), o.top = o.left = 0);
    let y;
    switch (g < 0 && (g -= Math.floor(g / 4) * 4), g = g % 4, g) {
      case 1:
        y = o.height / 2 + o.top, w.unshift(
          "rotate(90 " + y.toString() + " " + y.toString() + ")"
        );
        break;
      case 2:
        w.unshift(
          "rotate(180 " + (o.width / 2 + o.left).toString() + " " + (o.height / 2 + o.top).toString() + ")"
        );
        break;
      case 3:
        y = o.width / 2 + o.left, w.unshift(
          "rotate(-90 " + y.toString() + " " + y.toString() + ")"
        );
        break;
    }
    g % 2 === 1 && (o.left !== o.top && (y = o.left, o.left = o.top, o.top = y), o.width !== o.height && (y = o.width, o.width = o.height, o.height = y)), w.length && (s = Il(
      s,
      '<g transform="' + w.join(" ") + '">',
      "</g>"
    ));
  });
  const r = n.width, a = n.height, l = o.width, c = o.height;
  let h, u;
  r === null ? (u = a === null ? "1em" : a === "auto" ? c : a, h = pn(u, l / c)) : (h = r === "auto" ? l : r, u = a === null ? pn(h, c / l) : a === "auto" ? c : a);
  const p = {}, d = (v, w) => {
    Rl(w) || (p[v] = w.toString());
  };
  d("width", h), d("height", u);
  const m = [o.left, o.top, l, c];
  return p.viewBox = m.join(" "), {
    attributes: p,
    viewBox: m,
    body: s
  };
}
function Pn(i, t) {
  let e = i.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const n in t)
    e += " " + n + '="' + t[n] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + e + ">" + i + "</svg>";
}
function Pl(i) {
  return i.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function Nl(i) {
  return "data:image/svg+xml," + Pl(i);
}
function js(i) {
  return 'url("' + Nl(i) + '")';
}
const Ml = () => {
  let i;
  try {
    if (i = fetch, typeof i == "function")
      return i;
  } catch {
  }
};
let bi = Ml();
function Ll(i) {
  bi = i;
}
function Dl() {
  return bi;
}
function Fl(i, t) {
  const e = Oi(i);
  if (!e)
    return 0;
  let n;
  if (!e.maxURL)
    n = 0;
  else {
    let o = 0;
    e.resources.forEach((r) => {
      o = Math.max(o, r.length);
    });
    const s = t + ".json?icons=";
    n = e.maxURL - o - e.path.length - s.length;
  }
  return n;
}
function zl(i) {
  return i === 404;
}
const jl = (i, t, e) => {
  const n = [], o = Fl(i, t), s = "icons";
  let r = {
    type: s,
    provider: i,
    prefix: t,
    icons: []
  }, a = 0;
  return e.forEach((l, c) => {
    a += l.length + 1, a >= o && c > 0 && (n.push(r), r = {
      type: s,
      provider: i,
      prefix: t,
      icons: []
    }, a = l.length), r.icons.push(l);
  }), n.push(r), n;
};
function Bl(i) {
  if (typeof i == "string") {
    const t = Oi(i);
    if (t)
      return t.path;
  }
  return "/";
}
const Hl = (i, t, e) => {
  if (!bi) {
    e("abort", 424);
    return;
  }
  let n = Bl(t.provider);
  switch (t.type) {
    case "icons": {
      const s = t.prefix, r = t.icons.join(","), a = new URLSearchParams({
        icons: r
      });
      n += s + ".json?" + a.toString();
      break;
    }
    case "custom": {
      const s = t.uri;
      n += s.slice(0, 1) === "/" ? s.slice(1) : s;
      break;
    }
    default:
      e("abort", 400);
      return;
  }
  let o = 503;
  bi(i + n).then((s) => {
    const r = s.status;
    if (r !== 200) {
      setTimeout(() => {
        e(zl(r) ? "abort" : "next", r);
      });
      return;
    }
    return o = 501, s.json();
  }).then((s) => {
    if (typeof s != "object" || s === null) {
      setTimeout(() => {
        s === 404 ? e("abort", s) : e("next", o);
      });
      return;
    }
    setTimeout(() => {
      e("success", s);
    });
  }).catch(() => {
    e("next", o);
  });
}, Ul = {
  prepare: jl,
  send: Hl
};
function Co(i, t) {
  switch (i) {
    case "local":
    case "session":
      zt[i] = t;
      break;
    case "all":
      for (const e in zt)
        zt[e] = t;
      break;
  }
}
const Yi = "data-style";
let Bs = "";
function Vl(i) {
  Bs = i;
}
function Ao(i, t) {
  let e = Array.from(i.childNodes).find((n) => n.hasAttribute && n.hasAttribute(Yi));
  e || (e = document.createElement("style"), e.setAttribute(Yi, Yi), i.appendChild(e)), e.textContent = ":host{display:inline-block;vertical-align:" + (t ? "-0.125em" : "0") + "}span,svg{display:block}" + Bs;
}
function Hs() {
  go("", Ul), Ss(!0);
  let i;
  try {
    i = window;
  } catch {
  }
  if (i) {
    if (Ds(), i.IconifyPreload !== void 0) {
      const t = i.IconifyPreload, e = "Invalid IconifyPreload syntax.";
      typeof t == "object" && t !== null && (t instanceof Array ? t : [t]).forEach((n) => {
        try {
          (typeof n != "object" || n === null || n instanceof Array || // Check for 'icons' and 'prefix'
          typeof n.icons != "object" || typeof n.prefix != "string" || // Add icon set
          !fo(n)) && console.error(e);
        } catch {
          console.error(e);
        }
      });
    }
    if (i.IconifyProviders !== void 0) {
      const t = i.IconifyProviders;
      if (typeof t == "object" && t !== null)
        for (const e in t) {
          const n = "IconifyProviders[" + e + "] is invalid.";
          try {
            const o = t[e];
            if (typeof o != "object" || !o || o.resources === void 0)
              continue;
            vo(e, o) || console.error(n);
          } catch {
            console.error(n);
          }
        }
    }
  }
  return {
    enableCache: (t) => Co(t, !0),
    disableCache: (t) => Co(t, !1),
    iconLoaded: bo,
    iconExists: bo,
    getIcon: rl,
    listIcons: sl,
    addIcon: ks,
    addCollection: fo,
    calculateSize: pn,
    buildIcon: zs,
    iconToHTML: Pn,
    svgToURL: js,
    loadIcons: Rn,
    loadIcon: $l,
    addAPIProvider: vo,
    appendCustomStyle: Vl,
    _api: {
      getAPIConfig: Oi,
      setAPIModule: go,
      sendAPIQuery: Is,
      setFetch: Ll,
      getFetch: Dl,
      listAPIProviders: ml
    }
  };
}
const mn = {
  "background-color": "currentColor"
}, Us = {
  "background-color": "transparent"
}, Eo = {
  image: "var(--svg)",
  repeat: "no-repeat",
  size: "100% 100%"
}, So = {
  "-webkit-mask": mn,
  mask: mn,
  background: Us
};
for (const i in So) {
  const t = So[i];
  for (const e in Eo)
    t[i + "-" + e] = Eo[e];
}
function ko(i) {
  return i ? i + (i.match(/^[-0-9.]+$/) ? "px" : "") : "inherit";
}
function Wl(i, t, e) {
  const n = document.createElement("span");
  let o = i.body;
  o.indexOf("<a") !== -1 && (o += "<!-- " + Date.now() + " -->");
  const s = i.attributes, r = Pn(o, {
    ...s,
    width: t.width + "",
    height: t.height + ""
  }), a = js(r), l = n.style, c = {
    "--svg": a,
    width: ko(s.width),
    height: ko(s.height),
    ...e ? mn : Us
  };
  for (const h in c)
    l.setProperty(h, c[h]);
  return n;
}
let Ae;
function Gl() {
  try {
    Ae = window.trustedTypes.createPolicy("iconify", {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      createHTML: (i) => i
    });
  } catch {
    Ae = null;
  }
}
function ql(i) {
  return Ae === void 0 && Gl(), Ae ? Ae.createHTML(i) : i;
}
function Yl(i) {
  const t = document.createElement("span"), e = i.attributes;
  let n = "";
  e.width || (n = "width: inherit;"), e.height || (n += "height: inherit;"), n && (e.style = n);
  const o = Pn(i.body, e);
  return t.innerHTML = ql(o), t.firstChild;
}
function fn(i) {
  return Array.from(i.childNodes).find((t) => {
    const e = t.tagName && t.tagName.toUpperCase();
    return e === "SPAN" || e === "SVG";
  });
}
function To(i, t) {
  const e = t.icon.data, n = t.customisations, o = zs(e, n);
  n.preserveAspectRatio && (o.attributes.preserveAspectRatio = n.preserveAspectRatio);
  const s = t.renderedMode;
  let r;
  switch (s) {
    case "svg":
      r = Yl(o);
      break;
    default:
      r = Wl(o, {
        ...Ue,
        ...e
      }, s === "mask");
  }
  const a = fn(i);
  a ? r.tagName === "SPAN" && a.tagName === r.tagName ? a.setAttribute("style", r.getAttribute("style")) : i.replaceChild(r, a) : i.appendChild(r);
}
function Oo(i, t, e) {
  const n = e && (e.rendered ? e : e.lastRender);
  return {
    rendered: !1,
    inline: t,
    icon: i,
    lastRender: n
  };
}
function Xl(i = "iconify-icon") {
  let t, e;
  try {
    t = window.customElements, e = window.HTMLElement;
  } catch {
    return;
  }
  if (!t || !e)
    return;
  const n = t.get(i);
  if (n)
    return n;
  const o = [
    // Icon
    "icon",
    // Mode
    "mode",
    "inline",
    "observe",
    // Customisations
    "width",
    "height",
    "rotate",
    "flip"
  ], s = class extends e {
    /**
     * Constructor
     */
    constructor() {
      super(), Nt(this, "_shadowRoot"), Nt(this, "_initialised", !1), Nt(this, "_state"), Nt(this, "_checkQueued", !1), Nt(this, "_connected", !1), Nt(this, "_observer", null), Nt(this, "_visible", !0);
      const a = this._shadowRoot = this.attachShadow({
        mode: "open"
      }), l = qi(this);
      Ao(a, l), this._state = Oo({
        value: ""
      }, l), this._queueCheck();
    }
    /**
     * Connected to DOM
     */
    connectedCallback() {
      this._connected = !0, this.startObserver();
    }
    /**
     * Disconnected from DOM
     */
    disconnectedCallback() {
      this._connected = !1, this.stopObserver();
    }
    /**
     * Observed attributes
     */
    static get observedAttributes() {
      return o.slice(0);
    }
    /**
     * Observed properties that are different from attributes
     *
     * Experimental! Need to test with various frameworks that support it
     */
    /*
    static get properties() {
        return {
            inline: {
                type: Boolean,
                reflect: true,
            },
            // Not listing other attributes because they are strings or combination
            // of string and another type. Cannot have multiple types
        };
    }
    */
    /**
     * Attribute has changed
     */
    attributeChangedCallback(a) {
      switch (a) {
        case "inline": {
          const l = qi(this), c = this._state;
          l !== c.inline && (c.inline = l, Ao(this._shadowRoot, l));
          break;
        }
        case "observer": {
          this.observer ? this.startObserver() : this.stopObserver();
          break;
        }
        default:
          this._queueCheck();
      }
    }
    /**
     * Get/set icon
     */
    get icon() {
      const a = this.getAttribute("icon");
      if (a && a.slice(0, 1) === "{")
        try {
          return JSON.parse(a);
        } catch {
        }
      return a;
    }
    set icon(a) {
      typeof a == "object" && (a = JSON.stringify(a)), this.setAttribute("icon", a);
    }
    /**
     * Get/set inline
     */
    get inline() {
      return qi(this);
    }
    set inline(a) {
      a ? this.setAttribute("inline", "true") : this.removeAttribute("inline");
    }
    /**
     * Get/set observer
     */
    get observer() {
      return this.hasAttribute("observer");
    }
    set observer(a) {
      a ? this.setAttribute("observer", "true") : this.removeAttribute("observer");
    }
    /**
     * Restart animation
     */
    restartAnimation() {
      const a = this._state;
      if (a.rendered) {
        const l = this._shadowRoot;
        if (a.renderedMode === "svg")
          try {
            l.lastChild.setCurrentTime(0);
            return;
          } catch {
          }
        To(l, a);
      }
    }
    /**
     * Get status
     */
    get status() {
      const a = this._state;
      return a.rendered ? "rendered" : a.icon.data === null ? "failed" : "loading";
    }
    /**
     * Queue attributes re-check
     */
    _queueCheck() {
      this._checkQueued || (this._checkQueued = !0, setTimeout(() => {
        this._check();
      }));
    }
    /**
     * Check for changes
     */
    _check() {
      if (!this._checkQueued)
        return;
      this._checkQueued = !1;
      const a = this._state, l = this.getAttribute("icon");
      if (l !== a.icon.value) {
        this._iconChanged(l);
        return;
      }
      if (!a.rendered || !this._visible)
        return;
      const c = this.getAttribute("mode"), h = po(this);
      (a.attrMode !== c || Ka(a.customisations, h) || !fn(this._shadowRoot)) && this._renderIcon(a.icon, h, c);
    }
    /**
     * Icon value has changed
     */
    _iconChanged(a) {
      const l = Al(a, (c, h, u) => {
        const p = this._state;
        if (p.rendered || this.getAttribute("icon") !== c)
          return;
        const d = {
          value: c,
          name: h,
          data: u
        };
        d.data ? this._gotIconData(d) : p.icon = d;
      });
      l.data ? this._gotIconData(l) : this._state = Oo(l, this._state.inline, this._state);
    }
    /**
     * Force render icon on state change
     */
    _forceRender() {
      if (!this._visible) {
        const a = fn(this._shadowRoot);
        a && this._shadowRoot.removeChild(a);
        return;
      }
      this._queueCheck();
    }
    /**
     * Got new icon data, icon is ready to (re)render
     */
    _gotIconData(a) {
      this._checkQueued = !1, this._renderIcon(a, po(this), this.getAttribute("mode"));
    }
    /**
     * Re-render based on icon data
     */
    _renderIcon(a, l, c) {
      const h = El(a.data.body, c), u = this._state.inline;
      To(this._shadowRoot, this._state = {
        rendered: !0,
        icon: a,
        inline: u,
        customisations: l,
        attrMode: c,
        renderedMode: h
      });
    }
    /**
     * Start observer
     */
    startObserver() {
      if (!this._observer)
        try {
          this._observer = new IntersectionObserver((a) => {
            const l = a.some((c) => c.isIntersecting);
            l !== this._visible && (this._visible = l, this._forceRender());
          }), this._observer.observe(this);
        } catch {
          if (this._observer) {
            try {
              this._observer.disconnect();
            } catch {
            }
            this._observer = null;
          }
        }
    }
    /**
     * Stop observer
     */
    stopObserver() {
      this._observer && (this._observer.disconnect(), this._observer = null, this._visible = !0, this._connected && this._forceRender());
    }
  };
  o.forEach((a) => {
    a in s.prototype || Object.defineProperty(s.prototype, a, {
      get: function() {
        return this.getAttribute(a);
      },
      set: function(l) {
        l !== null ? this.setAttribute(a, l) : this.removeAttribute(a);
      }
    });
  });
  const r = Hs();
  for (const a in r)
    s[a] = s.prototype[a] = r[a];
  return t.define(i, s), s;
}
Xl() || Hs();
const Jl = R`
  ::-webkit-scrollbar {
    width: 0.4rem;
    height: 0.4rem;
    overflow: hidden;
  }

  ::-webkit-scrollbar-thumb {
    border-radius: 0.25rem;
    background-color: var(
      --bim-scrollbar--c,
      color-mix(in lab, var(--bim-ui_main-base), white 15%)
    );
  }

  ::-webkit-scrollbar-track {
    background-color: var(--bim-scrollbar--bgc, var(--bim-ui_bg-base));
  }
`, Ql = R`
  :root {
    /* Grayscale Colors */
    --bim-ui_gray-0: hsl(210 10% 5%);
    --bim-ui_gray-1: hsl(210 10% 10%);
    --bim-ui_gray-2: hsl(210 10% 20%);
    --bim-ui_gray-3: hsl(210 10% 30%);
    --bim-ui_gray-4: hsl(210 10% 40%);
    --bim-ui_gray-6: hsl(210 10% 60%);
    --bim-ui_gray-7: hsl(210 10% 70%);
    --bim-ui_gray-8: hsl(210 10% 80%);
    --bim-ui_gray-9: hsl(210 10% 90%);
    --bim-ui_gray-10: hsl(210 10% 95%);

    /* Brand Colors */
    --bim-ui_main-base: #6528d7;
    --bim-ui_accent-base: #bcf124;

    /* Brand Colors Contrasts */
    --bim-ui_main-contrast: var(--bim-ui_gray-10);
    --bim-ui_accent-contrast: var(--bim-ui_gray-0);

    /* Sizes */
    --bim-ui_size-4xs: 0.375rem;
    --bim-ui_size-3xs: 0.5rem;
    --bim-ui_size-2xs: 0.625rem;
    --bim-ui_size-xs: 0.75rem;
    --bim-ui_size-sm: 0.875rem;
    --bim-ui_size-base: 1rem;
    --bim-ui_size-lg: 1.125rem;
    --bim-ui_size-xl: 1.25rem;
    --bim-ui_size-2xl: 1.375rem;
    --bim-ui_size-3xl: 1.5rem;
    --bim-ui_size-4xl: 1.625rem;
    --bim-ui_size-5xl: 1.75rem;
    --bim-ui_size-6xl: 1.875rem;
    --bim-ui_size-7xl: 2rem;
    --bim-ui_size-8xl: 2.125rem;
    --bim-ui_size-9xl: 2.25rem;
  }

  /* Background Colors */
  @media (prefers-color-scheme: dark) {
    :root {
      --bim-ui_bg-base: var(--bim-ui_gray-0);
      --bim-ui_bg-contrast-10: var(--bim-ui_gray-1);
      --bim-ui_bg-contrast-20: var(--bim-ui_gray-2);
      --bim-ui_bg-contrast-30: var(--bim-ui_gray-3);
      --bim-ui_bg-contrast-40: var(--bim-ui_gray-4);
      --bim-ui_bg-contrast-60: var(--bim-ui_gray-6);
      --bim-ui_bg-contrast-80: var(--bim-ui_gray-8);
      --bim-ui_bg-contrast-100: var(--bim-ui_gray-10);
    }
  }

  @media (prefers-color-scheme: light) {
    :root {
      --bim-ui_bg-base: var(--bim-ui_gray-10);
      --bim-ui_bg-contrast-10: var(--bim-ui_gray-9);
      --bim-ui_bg-contrast-20: var(--bim-ui_gray-8);
      --bim-ui_bg-contrast-30: var(--bim-ui_gray-7);
      --bim-ui_bg-contrast-40: var(--bim-ui_gray-6);
      --bim-ui_bg-contrast-60: var(--bim-ui_gray-4);
      --bim-ui_bg-contrast-80: var(--bim-ui_gray-2);
      --bim-ui_bg-contrast-100: var(--bim-ui_gray-0);
      --bim-ui_accent-base: #6528d7;
    }
  }

  html.bim-ui-dark {
    --bim-ui_bg-base: var(--bim-ui_gray-0);
    --bim-ui_bg-contrast-10: var(--bim-ui_gray-1);
    --bim-ui_bg-contrast-20: var(--bim-ui_gray-2);
    --bim-ui_bg-contrast-30: var(--bim-ui_gray-3);
    --bim-ui_bg-contrast-40: var(--bim-ui_gray-4);
    --bim-ui_bg-contrast-60: var(--bim-ui_gray-6);
    --bim-ui_bg-contrast-80: var(--bim-ui_gray-8);
    --bim-ui_bg-contrast-100: var(--bim-ui_gray-10);
  }

  html.bim-ui-light {
    --bim-ui_bg-base: var(--bim-ui_gray-10);
    --bim-ui_bg-contrast-10: var(--bim-ui_gray-9);
    --bim-ui_bg-contrast-20: var(--bim-ui_gray-8);
    --bim-ui_bg-contrast-30: var(--bim-ui_gray-7);
    --bim-ui_bg-contrast-40: var(--bim-ui_gray-6);
    --bim-ui_bg-contrast-60: var(--bim-ui_gray-4);
    --bim-ui_bg-contrast-80: var(--bim-ui_gray-2);
    --bim-ui_bg-contrast-100: var(--bim-ui_gray-0);
    --bim-ui_accent-base: #6528d7;
  }

  [data-context-dialog]::backdrop {
    background-color: transparent;
  }
`, Ot = {
  scrollbar: Jl,
  globalStyles: Ql
}, Vs = class O {
  static set config(t) {
    this._config = { ...O._config, ...t };
  }
  static get config() {
    return O._config;
  }
  static addGlobalStyles() {
    let t = document.querySelector("style[id='bim-ui']");
    if (t)
      return;
    t = document.createElement("style"), t.id = "bim-ui", t.textContent = Ot.globalStyles.cssText;
    const e = document.head.firstChild;
    e ? document.head.insertBefore(t, e) : document.head.append(t);
  }
  static defineCustomElement(t, e) {
    customElements.get(t) || customElements.define(t, e);
  }
  /**
   * @deprecated Use `Manager.init()` instead.
   */
  static registerComponents() {
    O.init();
  }
  /**
   * Initializes the BIM UI library by defining custom elements.
   * It ensures that all necessary styles and custom elements are registered for use in BIM UI components.
   *
   * @example
   * ```typescript
   * import { Manager } from "@thatopen/ui";
   * Manager.init();
   * ```
   */
  static init() {
    O.addGlobalStyles(), O.defineCustomElement("bim-button", ic), O.defineCustomElement("bim-checkbox", ce), O.defineCustomElement("bim-color-input", Wt), O.defineCustomElement("bim-context-menu", bn), O.defineCustomElement("bim-dropdown", vt), O.defineCustomElement("bim-grid", Mn), O.defineCustomElement("bim-icon", uc), O.defineCustomElement("bim-input", Ge), O.defineCustomElement("bim-label", ue), O.defineCustomElement("bim-number-input", Z), O.defineCustomElement("bim-option", W), O.defineCustomElement("bim-panel", Gt), O.defineCustomElement("bim-panel-section", he), O.defineCustomElement("bim-selector", pe), O.defineCustomElement("bim-table", rt), O.defineCustomElement("bim-tabs", Yt), O.defineCustomElement("bim-tab", it), O.defineCustomElement("bim-table-cell", sr), O.defineCustomElement("bim-table-children", ar), O.defineCustomElement("bim-table-group", cr), O.defineCustomElement("bim-table-row", qt), O.defineCustomElement("bim-text-input", pt), O.defineCustomElement("bim-toolbar", Li), O.defineCustomElement("bim-toolbar-group", Ni), O.defineCustomElement(
      "bim-toolbar-section",
      be
    ), O.defineCustomElement("bim-viewport", _r);
  }
  static newRandomId() {
    const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let e = "";
    for (let n = 0; n < 10; n++) {
      const o = Math.floor(Math.random() * t.length);
      e += t.charAt(o);
    }
    return e;
  }
};
Vs._config = {
  sectionLabelOnVerticalToolbar: !1
  // draggableToolbars: true,
  // draggablePanels: true,
};
let Ee = Vs;
class Y extends I {
  constructor() {
    super(...arguments), this._lazyLoadObserver = null, this._visibleElements = [], this.ELEMENTS_BEFORE_OBSERVER = 20, this.useObserver = !1, this.elements = /* @__PURE__ */ new Set(), this.observe = (t) => {
      if (!this.useObserver)
        return;
      for (const n of t)
        this.elements.add(n);
      const e = t.slice(this.ELEMENTS_BEFORE_OBSERVER);
      for (const n of e)
        n.remove();
      this.observeLastElement();
    };
  }
  set visibleElements(t) {
    this._visibleElements = this.useObserver ? t : [], this.requestUpdate();
  }
  get visibleElements() {
    return this._visibleElements;
  }
  getLazyObserver() {
    if (!this.useObserver)
      return null;
    if (this._lazyLoadObserver)
      return this._lazyLoadObserver;
    const t = new IntersectionObserver(
      (e) => {
        const n = e[0];
        if (!n.isIntersecting)
          return;
        const o = n.target;
        t.unobserve(o);
        const s = this.ELEMENTS_BEFORE_OBSERVER + this.visibleElements.length, r = [...this.elements][s];
        r && (this.visibleElements = [...this.visibleElements, r], t.observe(r));
      },
      { threshold: 0.5 }
    );
    return t;
  }
  observeLastElement() {
    const t = this.getLazyObserver();
    if (!t)
      return;
    const e = this.ELEMENTS_BEFORE_OBSERVER + this.visibleElements.length - 1, n = [...this.elements][e];
    n && t.observe(n);
  }
  resetVisibleElements() {
    const t = this.getLazyObserver();
    if (t) {
      for (const e of this.elements)
        t.unobserve(e);
      this.visibleElements = [], this.observeLastElement();
    }
  }
  /**
   * Creates a new UI component instance based on the provided template and initial state.
   *
   * @template T - The type of the UI component element.
   * @template S - The type of the component state.
   *
   * @param template - The component template function (stateless or stateful).
   * @param initialState - The initial state of the component (optional for stateless components).
   * @returns The created UI component element or an array containing the element and a function to update its state.
   */
  static create(t, e) {
    const n = document.createDocumentFragment();
    if (t.length === 0)
      return ne(t(), n), n.firstElementChild;
    if (!e)
      throw new Error(
        "UIComponent: Initial state is required for statefull components."
      );
    let o = e;
    const s = t, r = (l) => (o = { ...o, ...l }, ne(s(o), n), o);
    r(e);
    const a = () => o;
    return [n.firstElementChild, r, a];
  }
}
var Kl = Object.defineProperty, Zl = Object.getOwnPropertyDescriptor, Ws = (i, t, e, n) => {
  for (var o = Zl(t, e), s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = r(t, e, o) || o);
  return o && Kl(t, e, o), o;
}, V;
const Nn = (V = class extends I {
  constructor() {
    super(...arguments), this._previousContainer = null, this._visible = !1;
  }
  get placement() {
    return this._placement;
  }
  set placement(i) {
    this._placement = i, this.updatePosition();
  }
  static removeMenus() {
    for (const i of V.menus)
      i instanceof V && (i.visible = !1);
    V.dialog.close(), V.dialog.remove();
  }
  get visible() {
    return this._visible;
  }
  set visible(i) {
    var t;
    this._visible = i, i ? (V.dialog.parentElement || document.body.append(V.dialog), this._previousContainer = this.parentElement, V.dialog.style.top = `${window.scrollY || document.documentElement.scrollTop}px`, V.dialog.append(this), V.dialog.showModal(), this.updatePosition(), this.dispatchEvent(new Event("visible"))) : ((t = this._previousContainer) == null || t.append(this), this._previousContainer = null, this.dispatchEvent(new Event("hidden")));
  }
  /**
   * Asynchronously updates the position of the context menu relative to a target element.
   * If no target element is provided, it attempts to use the parent node as the target.
   * The position is calculated using the `computePosition` function from `@floating-ui/dom`,
   * which considers various adjustments like offset, inline positioning, flipping, and shifting
   * to ensure the context menu is properly placed relative to the target element.
   *
   * @param [target] - The target element relative to which the context menu should be positioned.
   *                                 If not provided, the parent node is used as the target.
   * @returns A promise that resolves once the position has been updated. This method
   *                          does not explicitly return a value but updates the context menu's style
   *                          properties to position it on the screen.
   */
  async updatePosition() {
    if (!(this.visible && this._previousContainer))
      return;
    const i = this.placement ?? "right", t = await hs(this._previousContainer, this, {
      placement: i,
      middleware: [Zo(10), us(), ds(), cs({ padding: 5 })]
    }), { x: e, y: n } = t;
    this.style.left = `${e}px`, this.style.top = `${n}px`;
  }
  connectedCallback() {
    super.connectedCallback(), V.menus.push(this);
  }
  render() {
    return f` <slot></slot> `;
  }
}, V.styles = [
  Ot.scrollbar,
  R`
      :host {
        pointer-events: auto;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 999;
        overflow: auto;
        max-height: 20rem;
        min-width: 3rem;
        flex-direction: column;
        box-shadow: 1px 2px 8px 2px rgba(0, 0, 0, 0.15);
        padding: 0.5rem;
        border-radius: var(--bim-ui_size-4xs);
        display: flex;
        background-color: var(
          --bim-context-menu--bgc,
          var(--bim-ui_bg-contrast-20)
        );
      }

      :host(:not([visible])) {
        display: none;
      }
    `
], V.dialog = Y.create(() => f` <dialog
      @click=${(i) => {
  i.target === V.dialog && V.removeMenus();
}}
      @cancel=${() => V.removeMenus()}
      data-context-dialog
      style="
      width: 0;
      height: 0;
      position: relative;
      padding: 0;
      border: none;
      outline: none;
      margin: none;
      overflow: visible;
      background-color: transparent;
    "
    ></dialog>`), V.menus = [], V);
Ws([
  b({ type: String, reflect: !0 })
], Nn.prototype, "placement");
Ws([
  b({ type: Boolean, reflect: !0 })
], Nn.prototype, "visible");
let bn = Nn;
var tc = Object.defineProperty, ec = Object.getOwnPropertyDescriptor, lt = (i, t, e, n) => {
  for (var o = n > 1 ? void 0 : n ? ec(t, e) : t, s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = (n ? r(t, e, o) : r(o)) || o);
  return n && o && tc(t, e, o), o;
}, ye;
const ot = (ye = class extends I {
  constructor() {
    super(), this.labelHidden = !1, this.active = !1, this.disabled = !1, this.vertical = !1, this.tooltipVisible = !1, this._stateBeforeLoading = {
      disabled: !1,
      icon: ""
    }, this._loading = !1, this._parent = oe(), this._tooltip = oe(), this._mouseLeave = !1, this.onClick = (i) => {
      i.stopPropagation(), this.disabled || this.dispatchEvent(new Event("click"));
    }, this.showContextMenu = () => {
      const i = this._contextMenu;
      if (i) {
        const t = this.getAttribute("data-context-group");
        t && i.setAttribute("data-context-group", t), this.closeNestedContexts();
        const e = Ee.newRandomId();
        for (const n of i.children)
          n instanceof ye && n.setAttribute("data-context-group", e);
        i.visible = !0;
      }
    }, this.mouseLeave = !0;
  }
  set loading(i) {
    if (this._loading = i, i)
      this._stateBeforeLoading = {
        disabled: this.disabled,
        icon: this.icon
      }, this.disabled = i, this.icon = "eos-icons:loading";
    else {
      const { disabled: t, icon: e } = this._stateBeforeLoading;
      this.disabled = t, this.icon = e;
    }
  }
  get loading() {
    return this._loading;
  }
  set mouseLeave(i) {
    this._mouseLeave = i, i && (this.tooltipVisible = !1, clearTimeout(this.timeoutID));
  }
  get mouseLeave() {
    return this._mouseLeave;
  }
  computeTooltipPosition() {
    const { value: i } = this._parent, { value: t } = this._tooltip;
    i && t && hs(i, t, {
      placement: "bottom",
      middleware: [Zo(10), us(), ds(), cs({ padding: 5 })]
    }).then((e) => {
      const { x: n, y: o } = e;
      Object.assign(t.style, {
        left: `${n}px`,
        top: `${o}px`
      });
    });
  }
  onMouseEnter() {
    if (!(this.tooltipTitle || this.tooltipText))
      return;
    this.mouseLeave = !1;
    const i = this.tooltipTime ?? 700;
    this.timeoutID = setTimeout(() => {
      this.mouseLeave || (this.computeTooltipPosition(), this.tooltipVisible = !0);
    }, i);
  }
  closeNestedContexts() {
    const i = this.getAttribute("data-context-group");
    if (i)
      for (const t of bn.dialog.children) {
        const e = t.getAttribute("data-context-group");
        if (t instanceof bn && e === i) {
          t.visible = !1, t.removeAttribute("data-context-group");
          for (const n of t.children)
            n instanceof ye && (n.closeNestedContexts(), n.removeAttribute("data-context-group"));
        }
      }
  }
  click() {
    this.disabled || super.click();
  }
  get _contextMenu() {
    return this.querySelector("bim-context-menu");
  }
  connectedCallback() {
    super.connectedCallback(), this.addEventListener("click", this.showContextMenu);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.removeEventListener("click", this.showContextMenu);
  }
  render() {
    const i = f`
      <div ${J(this._tooltip)} class="tooltip">
        ${this.tooltipTitle ? f`<p style="text-wrap: nowrap;">
              <strong>${this.tooltipTitle}</strong>
            </p>` : null}
        ${this.tooltipText ? f`<p style="width: 9rem;">${this.tooltipText}</p>` : null}
      </div>
    `, t = f`<svg
      xmlns="http://www.w3.org/2000/svg"
      height="1.125rem"
      viewBox="0 0 24 24"
      width="1.125rem"
      style="fill: var(--bim-label--c)"
    >
      <path d="M0 0h24v24H0V0z" fill="none" />
      <path d="M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" />
    </svg>`;
    return f`
      <div ${J(this._parent)} class="parent" @click=${this.onClick}>
        ${this.label || this.icon ? f`
              <div
                class="button"
                @mouseenter=${this.onMouseEnter}
                @mouseleave=${() => this.mouseLeave = !0}
              >
                <bim-label
                  .icon=${this.icon}
                  .vertical=${this.vertical}
                  .labelHidden=${this.labelHidden}
                  >${this.label}${this.label && this._contextMenu ? t : null}</bim-label
                >
              </div>
            ` : null}
        ${this.tooltipTitle || this.tooltipText ? i : null}
      </div>
      <slot></slot>
    `;
  }
}, ye.styles = R`
    :host {
      --bim-label--c: var(--bim-ui_bg-contrast-100, white);
      display: block;
      flex: 1;
      pointer-events: none;
      background-color: var(--bim-button--bgc, var(--bim-ui_bg-contrast-20));
      border-radius: var(--bim-ui_size-4xs);
      transition: all 0.15s;
    }

    :host(:not([disabled]):hover) {
      cursor: pointer;
    }

    bim-label {
      pointer-events: none;
    }

    .parent {
      --bim-icon--c: var(--bim-label--c);
      position: relative;
      display: flex;
      height: 100%;
      user-select: none;
      row-gap: 0.125rem;
      min-height: var(--bim-ui_size-5xl);
      min-width: var(--bim-ui_size-5xl);
    }

    .button,
    .children {
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
    }

    .children {
      padding: 0 0.375rem;
      position: absolute;
      height: 100%;
      right: 0;
    }

    :host(:not([label-hidden])[icon][vertical]) .parent {
      min-height: 2.5rem;
    }

    .button {
      flex-grow: 1;
    }

    :host(:not([label-hidden])[label]) .button {
      justify-content: var(--bim-button--jc, center);
    }

    :host(:hover),
    :host([active]) {
      --bim-label--c: var(--bim-ui_main-contrast);
      background-color: var(--bim-ui_main-base);
    }

    :host(:not([label]):not([icon])) .children {
      flex: 1;
    }

    :host([vertical]) .parent {
      justify-content: center;
    }

    :host(:not([label-hidden])[label]) .button {
      padding: 0 0.5rem;
    }

    :host([disabled]) {
      --bim-label--c: var(--bim-ui_bg-contrast-80) !important;
      background-color: gray !important;
    }

    ::slotted(bim-button) {
      --bim-icon--fz: var(--bim-ui_size-base);
      --bim-button--bdrs: var(--bim-ui_size-4xs);
      --bim-button--olw: 0;
      --bim-button--olc: transparent;
    }

    .tooltip {
      position: absolute;
      padding: 0.75rem;
      z-index: 99;
      display: flex;
      flex-flow: column;
      row-gap: 0.375rem;
      box-shadow: 0 0 10px 3px rgba(0 0 0 / 20%);
      outline: 1px solid var(--bim-ui_bg-contrast-40);
      font-size: var(--bim-ui_size-xs);
      border-radius: var(--bim-ui_size-4xs);
      background-color: var(--bim-ui_bg-contrast-20);
      color: var(--bim-ui_bg-contrast-100);
    }

    .tooltip p {
      margin: 0;
      padding: 0;
    }

    :host(:not([tooltip-visible])) .tooltip {
      display: none;
    }
  `, ye);
lt([
  b({ type: String, reflect: !0 })
], ot.prototype, "label", 2);
lt([
  b({ type: Boolean, attribute: "label-hidden", reflect: !0 })
], ot.prototype, "labelHidden", 2);
lt([
  b({ type: Boolean, reflect: !0 })
], ot.prototype, "active", 2);
lt([
  b({ type: Boolean, reflect: !0, attribute: "disabled" })
], ot.prototype, "disabled", 2);
lt([
  b({ type: String, reflect: !0 })
], ot.prototype, "icon", 2);
lt([
  b({ type: Boolean, reflect: !0 })
], ot.prototype, "vertical", 2);
lt([
  b({ type: Number, attribute: "tooltip-time", reflect: !0 })
], ot.prototype, "tooltipTime", 2);
lt([
  b({ type: Boolean, attribute: "tooltip-visible", reflect: !0 })
], ot.prototype, "tooltipVisible", 2);
lt([
  b({ type: String, attribute: "tooltip-title", reflect: !0 })
], ot.prototype, "tooltipTitle", 2);
lt([
  b({ type: String, attribute: "tooltip-text", reflect: !0 })
], ot.prototype, "tooltipText", 2);
lt([
  b({ type: Boolean, reflect: !0 })
], ot.prototype, "loading", 1);
let ic = ot;
var nc = Object.defineProperty, We = (i, t, e, n) => {
  for (var o = void 0, s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = r(t, e, o) || o);
  return o && nc(t, e, o), o;
};
const Gs = class extends I {
  constructor() {
    super(...arguments), this.checked = !1, this.inverted = !1, this.onValueChange = new Event("change");
  }
  /**
   * A getter that returns the current checked state of the checkbox. This is useful for retrieving the checkbox's value in form submissions or JavaScript interactions as it provides a consistent `value` property as many other components.
   * @type {boolean}
   * @default false
   * @example <script>console.log(document.querySelector('bim-checkbox').value);<\/script>
   * @example
   * const checkbox = document.createElement('bim-checkbox');
   * document.body.appendChild(checkbox);
   * console.log(checkbox.value); // false initially
   */
  get value() {
    return this.checked;
  }
  onChange(t) {
    t.stopPropagation(), this.checked = t.target.checked, this.dispatchEvent(this.onValueChange);
  }
  render() {
    return f`
      <div class="parent">
        ${this.label ? f`<bim-label .icon="${this.icon}">${this.label}</bim-label> ` : null}
        <input
          type="checkbox"
          aria-label=${this.label || this.name || "Checkbox Input"}
          @change="${this.onChange}"
          .checked="${this.checked}"
        />
      </div>
    `;
  }
};
Gs.styles = R`
    :host {
      display: block;
    }

    .parent {
      display: flex;
      justify-content: space-between;
      height: 1.75rem;
      column-gap: 0.25rem;
      width: 100%;
      align-items: center;
      transition: all 0.15s;
    }

    :host([inverted]) .parent {
      flex-direction: row-reverse;
      justify-content: start;
    }

    input {
      height: 1rem;
      width: 1rem;
      cursor: pointer;
      border: none;
      outline: none;
      accent-color: var(--bim-checkbox--c, var(--bim-ui_main-base));
      transition: all 0.15s;
    }

    input:focus {
      outline: var(--bim-checkbox--olw, 2px) solid
        var(--bim-checkbox--olc, var(--bim-ui_accent-base));
    }
  `;
let ce = Gs;
We([
  b({ type: String, reflect: !0 })
], ce.prototype, "icon");
We([
  b({ type: String, reflect: !0 })
], ce.prototype, "name");
We([
  b({ type: String, reflect: !0 })
], ce.prototype, "label");
We([
  b({ type: Boolean, reflect: !0 })
], ce.prototype, "checked");
We([
  b({ type: Boolean, reflect: !0 })
], ce.prototype, "inverted");
var oc = Object.defineProperty, de = (i, t, e, n) => {
  for (var o = void 0, s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = r(t, e, o) || o);
  return o && oc(t, e, o), o;
};
const qs = class extends I {
  constructor() {
    super(...arguments), this.vertical = !1, this.color = "#bcf124", this._colorInput = oe(), this._textInput = oe(), this.onValueChange = new Event("input"), this.onOpacityInput = (t) => {
      const e = t.target;
      this.opacity = e.value, this.dispatchEvent(this.onValueChange);
    };
  }
  /**
   * Represents both the color and opacity values combined into a single object. This is an instance property, not an HTMLElement attribute.
   * @type {Object}
   * @example
   * const colorInput = document.createElement('bim-color-input');
   * colorInput.value = { color: '#ff0000', opacity: 0.5 };
   */
  set value(t) {
    const { color: e, opacity: n } = t;
    this.color = e, n && (this.opacity = n);
  }
  get value() {
    const t = {
      color: this.color
    };
    return this.opacity && (t.opacity = this.opacity), t;
  }
  onColorInput(t) {
    t.stopPropagation();
    const { value: e } = this._colorInput;
    e && (this.color = e.value, this.dispatchEvent(this.onValueChange));
  }
  onTextInput(t) {
    t.stopPropagation();
    const { value: e } = this._textInput;
    if (!e)
      return;
    const { value: n } = e;
    let o = n.replace(/[^a-fA-F0-9]/g, "");
    o.startsWith("#") || (o = `#${o}`), e.value = o.slice(0, 7), e.value.length === 7 && (this.color = e.value, this.dispatchEvent(this.onValueChange));
  }
  /**
   * Focuses on the color input by programmatically triggering a click event on the underlying color input element.
   * If the color input element is not available, the function does nothing.
   */
  focus() {
    const { value: t } = this._colorInput;
    t && t.click();
  }
  render() {
    return f`
      <div class="parent">
        <bim-input
          .label=${this.label}
          .icon=${this.icon}
          .vertical="${this.vertical}"
        >
          <div class="color-container">
            <div
              style="display: flex; align-items: center; gap: .375rem; height: 100%; flex: 1; padding: 0 0.5rem;"
            >
              <input
                ${J(this._colorInput)}
                @input="${this.onColorInput}"
                type="color"
                aria-label=${this.label || this.name || "Color Input"}
                value="${this.color}"
              />
              <div
                @click=${this.focus}
                class="sample"
                style="background-color: ${this.color}"
              ></div>
              <input
                ${J(this._textInput)}
                @input="${this.onTextInput}"
                value="${this.color}"
                type="text"
                aria-label=${this.label || this.name || "Text Color Input"}
              />
            </div>
            ${this.opacity !== void 0 ? f`<bim-number-input
                  @change=${this.onOpacityInput}
                  slider
                  suffix="%"
                  min="0"
                  value=${this.opacity}
                  max="100"
                ></bim-number-input>` : null}
          </div>
        </bim-input>
      </div>
    `;
  }
};
qs.styles = R`
    :host {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
      flex: 1;
      display: block;
    }

    :host(:focus) {
      --bim-input--olw: var(--bim-number-input--olw, 2px);
      --bim-input--olc: var(--bim-ui_accent-base);
    }

    .parent {
      display: flex;
      gap: 0.375rem;
    }

    .color-container {
      position: relative;
      outline: none;
      display: flex;
      height: 100%;
      gap: 0.5rem;
      justify-content: flex-start;
      align-items: center;
      flex: 1;
      border-radius: var(--bim-color-input--bdrs, var(--bim-ui_size-4xs));
    }

    .color-container input[type="color"] {
      position: absolute;
      bottom: -0.25rem;
      visibility: hidden;
      width: 0;
      height: 0;
    }

    .color-container .sample {
      width: 1rem;
      height: 1rem;
      border-radius: 0.125rem;
      background-color: #fff;
    }

    .color-container input[type="text"] {
      height: 100%;
      flex: 1;
      width: 3.25rem;
      text-transform: uppercase;
      font-size: 0.75rem;
      background-color: transparent;
      padding: 0%;
      outline: none;
      border: none;
      color: var(--bim-color-input--c, var(--bim-ui_bg-contrast-100));
    }

    bim-number-input {
      flex-grow: 0;
    }
  `;
let Wt = qs;
de([
  b({ type: String, reflect: !0 })
], Wt.prototype, "name");
de([
  b({ type: String, reflect: !0 })
], Wt.prototype, "label");
de([
  b({ type: String, reflect: !0 })
], Wt.prototype, "icon");
de([
  b({ type: Boolean, reflect: !0 })
], Wt.prototype, "vertical");
de([
  b({ type: Number, reflect: !0 })
], Wt.prototype, "opacity");
de([
  b({ type: String, reflect: !0 })
], Wt.prototype, "color");
const gi = (i, t = {}, e = !0) => {
  let n = {};
  for (const o of i.children) {
    const s = o, r = s.getAttribute("name") || s.getAttribute("label"), a = t[r];
    if (r) {
      if ("value" in s && typeof s.value < "u" && s.value !== null) {
        const l = s.value;
        if (typeof l == "object" && !Array.isArray(l) && Object.keys(l).length === 0)
          continue;
        n[r] = a ? a(s.value) : s.value;
      } else if (e) {
        const l = gi(s, t);
        if (Object.keys(l).length === 0)
          continue;
        n[r] = a ? a(l) : l;
      }
    } else
      e && (n = { ...n, ...gi(s, t) });
  }
  return n;
}, Ii = (i) => i === "true" || i === "false" ? i === "true" : i && !isNaN(Number(i)) && i.trim() !== "" ? Number(i) : i, sc = [">=", "<=", "=", ">", "<", "?", "/", "#"];
function Io(i) {
  const t = sc.find(
    (r) => i.split(r).length === 2
  ), e = i.split(t).map((r) => r.trim()), [n, o] = e, s = o.startsWith("'") && o.endsWith("'") ? o.replace(/'/g, "") : Ii(o);
  return { key: n, condition: t, value: s };
}
const gn = (i) => {
  try {
    const t = [], e = i.split(/&(?![^()]*\))/).map((n) => n.trim());
    for (const n of e) {
      const o = !n.startsWith("(") && !n.endsWith(")"), s = n.startsWith("(") && n.endsWith(")");
      if (o) {
        const r = Io(n);
        t.push(r);
      }
      if (s) {
        const r = {
          operator: "&",
          queries: n.replace(/^(\()|(\))$/g, "").split("&").map((a) => a.trim()).map((a, l) => {
            const c = Io(a);
            return l > 0 && (c.operator = "&"), c;
          })
        };
        t.push(r);
      }
    }
    return t;
  } catch {
    return null;
  }
}, Ro = (i, t, e) => {
  let n = !1;
  switch (t) {
    case "=":
      n = i === e;
      break;
    case "?":
      n = String(i).includes(String(e));
      break;
    case "<":
      (typeof i == "number" || typeof e == "number") && (n = i < e);
      break;
    case "<=":
      (typeof i == "number" || typeof e == "number") && (n = i <= e);
      break;
    case ">":
      (typeof i == "number" || typeof e == "number") && (n = i > e);
      break;
    case ">=":
      (typeof i == "number" || typeof e == "number") && (n = i >= e);
      break;
    case "/":
      n = String(i).startsWith(String(e));
      break;
  }
  return n;
};
var rc = Object.defineProperty, ac = Object.getOwnPropertyDescriptor, It = (i, t, e, n) => {
  for (var o = n > 1 ? void 0 : n ? ac(t, e) : t, s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = (n ? r(t, e, o) : r(o)) || o);
  return n && o && rc(t, e, o), o;
};
const Ys = class extends I {
  constructor() {
    super(...arguments), this.checked = !1, this.checkbox = !1, this.noMark = !1, this.vertical = !1;
  }
  get value() {
    return this._value !== void 0 ? this._value : this.label ? Ii(this.label) : this.label;
  }
  set value(t) {
    this._value = t;
  }
  render() {
    return f`
      <div class="parent" .title=${this.label ?? ""}>
        ${this.img || this.icon || this.label ? f` <div style="display: flex; column-gap: 0.375rem">
              ${this.checkbox && !this.noMark ? f`<bim-checkbox
                    style="pointer-events: none"
                    .checked=${this.checked}
                  ></bim-checkbox>` : null}
              <bim-label
                .vertical=${this.vertical}
                .icon=${this.icon}
                .img=${this.img}
                >${this.label}</bim-label
              >
            </div>` : null}
        ${!this.checkbox && !this.noMark && this.checked ? f`<svg
              xmlns="http://www.w3.org/2000/svg"
              height="1.125rem"
              viewBox="0 0 24 24"
              width="1.125rem"
              fill="#FFFFFF"
            >
              <path d="M0 0h24v24H0z" fill="none" />
              <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" />
            </svg>` : null}
        <slot></slot>
      </div>
    `;
  }
};
Ys.styles = R`
    :host {
      --bim-label--c: var(--bim-ui_bg-contrast-100);
      display: block;
      box-sizing: border-box;
      flex: 1;
      padding: 0rem 0.5rem;
      border-radius: var(--bim-ui_size-4xs);
      transition: all 0.15s;
    }

    :host(:hover) {
      cursor: pointer;
      background-color: color-mix(
        in lab,
        var(--bim-selector--bgc, var(--bim-ui_bg-contrast-20)),
        var(--bim-ui_main-base) 10%
      );
    }

    :host([checked]) {
      --bim-label--c: color-mix(in lab, var(--bim-ui_main-base), white 30%);
    }

    :host([checked]) svg {
      fill: color-mix(in lab, var(--bim-ui_main-base), white 30%);
    }

    .parent {
      box-sizing: border-box;
      display: flex;
      justify-content: var(--bim-option--jc, space-between);
      column-gap: 0.5rem;
      align-items: center;
      min-height: 1.75rem;
      height: 100%;
    }

    input {
      height: 1rem;
      width: 1rem;
      cursor: pointer;
      border: none;
      outline: none;
      accent-color: var(--bim-checkbox--c, var(--bim-ui_main-base));
    }

    input:focus {
      outline: var(--bim-checkbox--olw, 2px) solid
        var(--bim-checkbox--olc, var(--bim-ui_accent-base));
    }

    bim-label {
      pointer-events: none;
    }
  `;
let W = Ys;
It([
  b({ type: String, reflect: !0 })
], W.prototype, "img", 2);
It([
  b({ type: String, reflect: !0 })
], W.prototype, "label", 2);
It([
  b({ type: String, reflect: !0 })
], W.prototype, "icon", 2);
It([
  b({ type: Boolean, reflect: !0 })
], W.prototype, "checked", 2);
It([
  b({ type: Boolean, reflect: !0 })
], W.prototype, "checkbox", 2);
It([
  b({ type: Boolean, attribute: "no-mark", reflect: !0 })
], W.prototype, "noMark", 2);
It([
  b({
    converter: {
      fromAttribute(i) {
        return i && Ii(i);
      }
    }
  })
], W.prototype, "value", 1);
It([
  b({ type: Boolean, reflect: !0 })
], W.prototype, "vertical", 2);
var lc = Object.defineProperty, cc = Object.getOwnPropertyDescriptor, Rt = (i, t, e, n) => {
  for (var o = n > 1 ? void 0 : n ? cc(t, e) : t, s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = (n ? r(t, e, o) : r(o)) || o);
  return n && o && lc(t, e, o), o;
};
const Xs = class extends Y {
  constructor() {
    super(), this.multiple = !1, this.required = !1, this.vertical = !1, this._visible = !1, this._value = /* @__PURE__ */ new Set(), this.onValueChange = new Event("change"), this._contextMenu = oe(), this.onOptionClick = (t) => {
      const e = t.target, n = this._value.has(e);
      if (!this.multiple && !this.required && !n)
        this._value = /* @__PURE__ */ new Set([e]);
      else if (!this.multiple && !this.required && n)
        this._value = /* @__PURE__ */ new Set([]);
      else if (!this.multiple && this.required && !n)
        this._value = /* @__PURE__ */ new Set([e]);
      else if (this.multiple && !this.required && !n)
        this._value = /* @__PURE__ */ new Set([...this._value, e]);
      else if (this.multiple && !this.required && n) {
        const o = [...this._value].filter((s) => s !== e);
        this._value = new Set(o);
      } else if (this.multiple && this.required && !n)
        this._value = /* @__PURE__ */ new Set([...this._value, e]);
      else if (this.multiple && this.required && n) {
        const o = [...this._value].filter((r) => r !== e), s = new Set(o);
        s.size !== 0 && (this._value = s);
      }
      this.updateOptionsState(), this.dispatchEvent(this.onValueChange);
    }, this.useObserver = !0;
  }
  set visible(t) {
    if (t) {
      const { value: e } = this._contextMenu;
      if (!e)
        return;
      for (const n of this.elements)
        e.append(n);
      this._visible = !0;
    } else {
      for (const e of this.elements)
        this.append(e);
      this._visible = !1, this.resetVisibleElements();
    }
  }
  get visible() {
    return this._visible;
  }
  /**
   * The selected values in the dropdown.
   * @type {any[]}
   * @example
   * const dropdown = document.createElement('bim-dropdown');
   * dropdown.value = ['option1', 'option2'];
   */
  set value(t) {
    if (this.required && Object.keys(t).length === 0)
      return;
    const e = /* @__PURE__ */ new Set();
    for (const n of t) {
      const o = this.findOption(n);
      if (o && (e.add(o), !this.multiple && Object.keys(t).length === 1))
        break;
    }
    this._value = e, this.updateOptionsState(), this.dispatchEvent(this.onValueChange);
  }
  get value() {
    return [...this._value].filter(
      (t) => t instanceof W && t.checked
    ).map((t) => t.value);
  }
  get _options() {
    const t = /* @__PURE__ */ new Set([...this.elements]);
    for (const e of this.children)
      e instanceof W && t.add(e);
    return [...t];
  }
  onSlotChange(t) {
    const e = t.target.assignedElements();
    this.observe(e);
    const n = /* @__PURE__ */ new Set();
    for (const o of this.elements) {
      if (!(o instanceof W)) {
        o.remove();
        continue;
      }
      o.checked && n.add(o), o.removeEventListener("click", this.onOptionClick), o.addEventListener("click", this.onOptionClick);
    }
    this._value = n;
  }
  updateOptionsState() {
    for (const t of this._options)
      t instanceof W && (t.checked = this._value.has(t));
  }
  findOption(t) {
    return this._options.find((e) => e instanceof W ? e.label === t || e.value === t : !1);
  }
  render() {
    let t, e, n;
    if (this._value.size === 0)
      t = "Select an option...";
    else if (this._value.size === 1) {
      const o = [...this._value][0];
      t = (o == null ? void 0 : o.label) || (o == null ? void 0 : o.value), e = o == null ? void 0 : o.img, n = o == null ? void 0 : o.icon;
    } else
      t = `Multiple (${this._value.size})`;
    return f`
      <bim-input
        title=${this.label ?? ""}
        .label=${this.label}
        .icon=${this.icon}
        .vertical=${this.vertical}
      >
        <div class="input" @click=${() => this.visible = !this.visible}>
          <bim-label
            .img=${e}
            .icon=${n}
            style="overflow: hidden;"
            >${t}</bim-label
          >
          <svg
            style="flex-shrink: 0; fill: var(--bim-dropdown--c, var(--bim-ui_bg-contrast-100))"
            xmlns="http://www.w3.org/2000/svg"
            height="1.125rem"
            viewBox="0 0 24 24"
            width="1.125rem"
            fill="#9ca3af"
          >
            <path d="M0 0h24v24H0V0z" fill="none" />
            <path d="M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" />
          </svg>
          <bim-context-menu
            ${J(this._contextMenu)}
            .visible=${this.visible}
            @hidden=${() => {
      this.visible && (this.visible = !1);
    }}
          >
            <slot @slotchange=${this.onSlotChange}></slot>
          </bim-context-menu>
        </div>
      </bim-input>
    `;
  }
};
Xs.styles = [
  Ot.scrollbar,
  R`
      :host {
        --bim-input--bgc: var(
          --bim-dropdown--bgc,
          var(--bim-ui_bg-contrast-20)
        );
        --bim-input--olw: 2px;
        --bim-input--olc: transparent;
        --bim-input--bdrs: var(--bim-ui_size-4xs);
        flex: 1;
        display: block;
      }

      :host([visible]) {
        --bim-input--olc: var(--bim-ui_accent-base);
      }

      .input {
        --bim-label--fz: var(--bim-drodown--fz, var(--bim-ui_size-xs));
        --bim-label--c: var(--bim-dropdown--c, var(--bim-ui_bg-contrast-100));
        height: 100%;
        display: flex;
        flex: 1;
        overflow: hidden;
        column-gap: 0.25rem;
        outline: none;
        cursor: pointer;
        align-items: center;
        justify-content: space-between;
        padding: 0 0.5rem;
      }

      bim-label {
        pointer-events: none;
      }
    `
];
let vt = Xs;
Rt([
  b({ type: String, reflect: !0 })
], vt.prototype, "name", 2);
Rt([
  b({ type: String, reflect: !0 })
], vt.prototype, "icon", 2);
Rt([
  b({ type: String, reflect: !0 })
], vt.prototype, "label", 2);
Rt([
  b({ type: Boolean, reflect: !0 })
], vt.prototype, "multiple", 2);
Rt([
  b({ type: Boolean, reflect: !0 })
], vt.prototype, "required", 2);
Rt([
  b({ type: Boolean, reflect: !0 })
], vt.prototype, "vertical", 2);
Rt([
  b({ type: Boolean, reflect: !0 })
], vt.prototype, "visible", 1);
Rt([
  le()
], vt.prototype, "_value", 2);
var dc = Object.defineProperty, Js = (i, t, e, n) => {
  for (var o = void 0, s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = r(t, e, o) || o);
  return o && dc(t, e, o), o;
};
const Qs = class extends I {
  constructor() {
    super(...arguments), this.floating = !1, this.layouts = {};
  }
  // private isVerticalArea(area: string) {
  //   const { rows } = this;
  //   const row = rows.find((row) => row.includes(area));
  //   if (!row)
  //     throw new Error(
  //       `${area} wasn't defined in the grid-template of this bim-grid`,
  //     );
  //   const index = rows.indexOf(row);
  //   const abovePanel = index > 0 && rows[index - 1].includes(area);
  //   const belowPanel =
  //     index < rows.length - 1 && rows[index + 1].includes(area);
  //   return abovePanel || belowPanel;
  // }
  getUniqueAreasFromTemplate(t) {
    const e = t.split(`
`).map((n) => n.trim()).map((n) => n.split('"')[1]).filter((n) => n !== void 0).flatMap((n) => n.split(/\s+/));
    return [...new Set(e)].filter((n) => n !== "");
  }
  firstUpdated() {
    this._onLayoutChange = new Event("layoutchange");
  }
  render() {
    if (this.layout) {
      if (this.layouts[this.layout]) {
        this.innerHTML = "";
        const t = this.layouts[this.layout], e = this.getUniqueAreasFromTemplate(t.template).map((n) => {
          const o = t.elements[n];
          return o && (o.style.gridArea = n), o;
        }).filter((n) => !!n);
        this.style.gridTemplate = t.template, this._onLayoutChange && this.dispatchEvent(this._onLayoutChange), this.append(...e);
      }
    } else
      this.innerHTML = "", this.style.gridTemplate = "", this._onLayoutChange && this.dispatchEvent(this._onLayoutChange);
    return f`<slot></slot>`;
  }
};
Qs.styles = R`
    :host {
      display: grid;
      height: 100%;
      width: 100%;
      overflow: hidden;
      box-sizing: border-box;
    }

    /* :host(:not([layout])) {
      display: none;
    } */

    :host([floating]) {
      --bim-panel--bdrs: var(--bim-ui_size-4xs);
      background-color: transparent;
      padding: 1rem;
      gap: 1rem;
      position: absolute;
      pointer-events: none;
      top: 0px;
      left: 0px;
    }

    :host(:not([floating])) {
      --bim-panel--bdrs: 0;
      background-color: var(--bim-ui_bg-contrast-20);
      gap: 1px;
    }
  `;
let Mn = Qs;
Js([
  b({ type: Boolean, reflect: !0 })
], Mn.prototype, "floating");
Js([
  b({ type: String, reflect: !0 })
], Mn.prototype, "layout");
const vn = class extends I {
  render() {
    return f`
      <iconify-icon .icon=${this.icon} height="none"></iconify-icon>
    `;
  }
};
vn.styles = R`
    :host {
      height: var(--bim-icon--fz, var(--bim-ui_size-sm));
      width: var(--bim-icon--fz, var(--bim-ui_size-sm));
    }

    iconify-icon {
      height: var(--bim-icon--fz, var(--bim-ui_size-sm));
      width: var(--bim-icon--fz, var(--bim-ui_size-sm));
      color: var(--bim-icon--c);
      transition: all 0.15s;
    }
  `, vn.properties = {
  icon: { type: String }
};
let uc = vn;
var hc = Object.defineProperty, Ri = (i, t, e, n) => {
  for (var o = void 0, s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = r(t, e, o) || o);
  return o && hc(t, e, o), o;
};
const Ks = class extends I {
  constructor() {
    super(...arguments), this.vertical = !1, this.onValueChange = new Event("change");
  }
  get value() {
    const t = {};
    for (const e of this.children) {
      const n = e;
      "value" in n ? t[n.name || n.label] = n.value : "checked" in n && (t[n.name || n.label] = n.checked);
    }
    return t;
  }
  set value(t) {
    const e = [...this.children];
    for (const n in t) {
      const o = e.find((a) => {
        const l = a;
        return l.name === n || l.label === n;
      });
      if (!o)
        continue;
      const s = o, r = t[n];
      typeof r == "boolean" ? s.checked = r : s.value = r;
    }
  }
  render() {
    return f`
      <div class="parent">
        ${this.label || this.icon ? f`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
        <div class="input">
          <slot></slot>
        </div>
      </div>
    `;
  }
};
Ks.styles = R`
    :host {
      flex: 1;
      display: block;
    }

    .parent {
      display: flex;
      flex-wrap: wrap;
      column-gap: 1rem;
      row-gap: 0.375rem;
      user-select: none;
      flex: 1;
    }

    :host(:not([vertical])) .parent {
      justify-content: space-between;
    }

    :host([vertical]) .parent {
      flex-direction: column;
    }

    .input {
      overflow: hidden;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      min-height: 1.75rem;
      min-width: 3rem;
      gap: var(--bim-input--g, var(--bim-ui_size-4xs));
      padding: var(--bim-input--p, 0);
      background-color: var(--bim-input--bgc, transparent);
      outline: var(--bim-input--olw, 2px) solid
        var(--bim-input--olc, transparent);
      border-radius: var(--bim-input--bdrs, var(--bim-ui_size-4xs));
      transition: all 0.15s;
    }

    :host(:not([vertical])) .input {
      flex: 1;
      justify-content: flex-end;
    }

    :host(:not([vertical])[label]) .input {
      max-width: fit-content;
    }
  `;
let Ge = Ks;
Ri([
  b({ type: String, reflect: !0 })
], Ge.prototype, "name");
Ri([
  b({ type: String, reflect: !0 })
], Ge.prototype, "label");
Ri([
  b({ type: String, reflect: !0 })
], Ge.prototype, "icon");
Ri([
  b({ type: Boolean, reflect: !0 })
], Ge.prototype, "vertical");
var pc = Object.defineProperty, qe = (i, t, e, n) => {
  for (var o = void 0, s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = r(t, e, o) || o);
  return o && pc(t, e, o), o;
};
const Zs = class extends I {
  constructor() {
    super(...arguments), this.labelHidden = !1, this.iconHidden = !1, this.vertical = !1;
  }
  get value() {
    return this.textContent ? Ii(this.textContent) : this.textContent;
  }
  render() {
    return f`
      <div class="parent" .title=${this.textContent ?? ""}>
        ${this.img ? f`<img .src=${this.img} .alt=${this.textContent || ""} />` : null}
        ${!this.iconHidden && this.icon ? f`<bim-icon .icon=${this.icon}></bim-icon>` : null}
        <p><slot></slot></p>
      </div>
    `;
  }
};
Zs.styles = R`
    :host {
      --bim-icon--c: var(--bim-label--c);
      color: var(--bim-label--c, var(--bim-ui_bg-contrast-60));
      font-size: var(--bim-label--fz, var(--bim-ui_size-xs));
      overflow: hidden;
      display: block;
      white-space: nowrap;
      line-height: 1.1rem;
      transition: all 0.15s;
    }

    .parent {
      display: flex;
      align-items: center;
      column-gap: 0.25rem;
      row-gap: 0.125rem;
      user-select: none;
      height: 100%;
    }

    :host([vertical]) .parent {
      flex-direction: column;
    }

    .parent p {
      margin: 0;
      text-overflow: ellipsis;
      overflow: hidden;
      display: flex;
      align-items: center;
      gap: 0.125rem;
    }

    :host([label-hidden]) .parent p,
    :host(:empty) .parent p {
      display: none;
    }

    img {
      height: 100%;
      aspect-ratio: 1;
      border-radius: 100%;
      margin-right: 0.125rem;
    }

    :host(:not([vertical])) img {
      max-height: var(
        --bim-label_icon--sz,
        calc(var(--bim-label--fz, var(--bim-ui_size-xs)) * 1.8)
      );
    }

    :host([vertical]) img {
      max-height: var(
        --bim-label_icon--sz,
        calc(var(--bim-label--fz, var(--bim-ui_size-xs)) * 4)
      );
    }
  `;
let ue = Zs;
qe([
  b({ type: String, reflect: !0 })
], ue.prototype, "img");
qe([
  b({ type: Boolean, attribute: "label-hidden", reflect: !0 })
], ue.prototype, "labelHidden");
qe([
  b({ type: String, reflect: !0 })
], ue.prototype, "icon");
qe([
  b({ type: Boolean, attribute: "icon-hidden", reflect: !0 })
], ue.prototype, "iconHidden");
qe([
  b({ type: Boolean, reflect: !0 })
], ue.prototype, "vertical");
var mc = Object.defineProperty, fc = Object.getOwnPropertyDescriptor, st = (i, t, e, n) => {
  for (var o = n > 1 ? void 0 : n ? fc(t, e) : t, s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = (n ? r(t, e, o) : r(o)) || o);
  return n && o && mc(t, e, o), o;
};
const tr = class extends I {
  constructor() {
    super(...arguments), this._value = 0, this.vertical = !1, this.slider = !1, this._input = oe(), this.onValueChange = new Event("change");
  }
  set value(t) {
    this.setValue(t.toString());
  }
  get value() {
    return this._value;
  }
  onChange(t) {
    t.stopPropagation();
    const { value: e } = this._input;
    e && this.setValue(e.value);
  }
  setValue(t) {
    const { value: e } = this._input;
    let n = t;
    if (n = n.replace(/[^0-9.-]/g, ""), n = n.replace(/(\..*)\./g, "$1"), n.endsWith(".") || (n.lastIndexOf("-") > 0 && (n = n[0] + n.substring(1).replace(/-/g, "")), n === "-" || n === "-0"))
      return;
    let o = Number(n);
    Number.isNaN(o) || (o = this.min !== void 0 ? Math.max(o, this.min) : o, o = this.max !== void 0 ? Math.min(o, this.max) : o, this.value !== o && (this._value = o, e && (e.value = this.value.toString()), this.requestUpdate(), this.dispatchEvent(this.onValueChange)));
  }
  onBlur() {
    const { value: t } = this._input;
    t && Number.isNaN(Number(t.value)) && (t.value = this.value.toString());
  }
  onSliderMouseDown(t) {
    document.body.style.cursor = "w-resize";
    const { clientX: e } = t, n = this.value;
    let o = !1;
    const s = (l) => {
      var c;
      o = !0;
      const { clientX: h } = l, u = this.step ?? 1, p = ((c = u.toString().split(".")[1]) == null ? void 0 : c.length) || 0, d = 1 / (this.sensitivity ?? 1), m = (h - e) / d;
      if (Math.floor(Math.abs(m)) !== Math.abs(m))
        return;
      const v = n + m * u;
      this.setValue(v.toFixed(p));
    }, r = () => {
      this.slider = !0, this.removeEventListener("blur", r);
    }, a = () => {
      document.removeEventListener("mousemove", s), document.body.style.cursor = "default", o ? o = !1 : (this.addEventListener("blur", r), this.slider = !1, requestAnimationFrame(() => this.focus())), document.removeEventListener("mouseup", a);
    };
    document.addEventListener("mousemove", s), document.addEventListener("mouseup", a);
  }
  onFocus(t) {
    t.stopPropagation();
    const e = (n) => {
      n.key === "Escape" && (this.blur(), window.removeEventListener("keydown", e));
    };
    window.addEventListener("keydown", e);
  }
  connectedCallback() {
    super.connectedCallback(), this.min && this.min > this.value && (this._value = this.min), this.max && this.max < this.value && (this._value = this.max);
  }
  /**
   * Sets focus to the input element of the number input component.
   * This method is useful for programmatically focusing the input element, for example,
   * in response to a user action or to emphasize the input in the UI.
   *
   * If the input element reference is not available (not yet rendered or disconnected),
   * this method will do nothing.
   */
  focus() {
    const { value: t } = this._input;
    t && t.focus();
  }
  render() {
    const t = f`
      ${this.pref || this.icon ? f`<bim-label
            style="pointer-events: auto"
            @mousedown=${this.onSliderMouseDown}
            .icon=${this.icon}
            >${this.pref}</bim-label
          >` : null}
      <input
        ${J(this._input)}
        type="text"
        aria-label=${this.label || this.name || "Number Input"}
        size="1"
        @input=${(a) => a.stopPropagation()}
        @change=${this.onChange}
        @blur=${this.onBlur}
        @focus=${this.onFocus}
        .value=${this.value.toString()}
      />
      ${this.suffix ? f`<bim-label
            style="pointer-events: auto"
            @mousedown=${this.onSliderMouseDown}
            >${this.suffix}</bim-label
          >` : null}
    `, e = this.min ?? -1 / 0, n = this.max ?? 1 / 0, o = 100 * (this.value - e) / (n - e), s = f`
      <style>
        .slider-indicator {
          width: ${`${o}%`};
        }
      </style>
      <div class="slider" @mousedown=${this.onSliderMouseDown}>
        <div class="slider-indicator"></div>
        ${this.pref || this.icon ? f`<bim-label
              style="z-index: 1; margin-right: 0.125rem"
              .icon=${this.icon}
              >${`${this.pref}: `}</bim-label
            >` : null}
        <bim-label style="z-index: 1;">${this.value}</bim-label>
        ${this.suffix ? f`<bim-label style="z-index: 1;">${this.suffix}</bim-label>` : null}
      </div>
    `, r = `${this.label || this.name || this.pref ? `${this.label || this.name || this.pref}: ` : ""}${this.value}${this.suffix ?? ""}`;
    return f`
      <bim-input
        title=${r}
        .label=${this.label}
        .icon=${this.icon}
        .vertical=${this.vertical}
      >
        ${this.slider ? s : t}
      </bim-input>
    `;
  }
};
tr.styles = R`
    :host {
      --bim-input--bgc: var(
        --bim-number-input--bgc,
        var(--bim-ui_bg-contrast-20)
      );
      --bim-input--olw: var(--bim-number-input--olw, 2px);
      --bim-input--olc: var(--bim-number-input--olc, transparent);
      --bim-input--bdrs: var(--bim-number-input--bdrs, var(--bim-ui_size-4xs));
      --bim-input--p: 0 0.375rem;
      flex: 1;
      display: block;
    }

    :host(:focus) {
      --bim-input--olw: var(--bim-number-input--olw, 2px);
      --bim-input--olc: var(
        --bim-number-inputfocus--c,
        var(--bim-ui_accent-base)
      );
    }

    :host(:not([slider])) bim-label {
      --bim-label--c: var(
        --bim-number-input_affixes--c,
        var(--bim-ui_bg-contrast-60)
      );
      --bim-label--fz: var(
        --bim-number-input_affixes--fz,
        var(--bim-ui_size-xs)
      );
    }

    p {
      margin: 0;
      padding: 0;
    }

    input {
      background-color: transparent;
      outline: none;
      border: none;
      padding: 0;
      flex-grow: 1;
      text-align: right;
      font-family: inherit;
      font-feature-settings: inherit;
      font-variation-settings: inherit;
      font-size: var(--bim-number-input--fz, var(--bim-ui_size-xs));
      color: var(--bim-number-input--c, var(--bim-ui_bg-contrast-100));
    }

    :host([suffix]:not([pref])) input {
      text-align: left;
    }

    :host([slider]) {
      --bim-input--p: 0;
    }

    :host([slider]) .slider {
      --bim-label--c: var(--bim-ui_bg-contrast-100);
    }

    .slider {
      position: relative;
      display: flex;
      justify-content: center;
      width: 100%;
      height: 100%;
      padding: 0 0.5rem;
    }

    .slider-indicator {
      height: 100%;
      background-color: var(--bim-ui_main-base);
      position: absolute;
      top: 0;
      left: 0;
      border-radius: var(--bim-input--bdrs, var(--bim-ui_size-4xs));
    }

    bim-input {
      display: flex;
    }

    bim-label {
      pointer-events: none;
    }
  `;
let Z = tr;
st([
  b({ type: String, reflect: !0 })
], Z.prototype, "name", 2);
st([
  b({ type: String, reflect: !0 })
], Z.prototype, "icon", 2);
st([
  b({ type: String, reflect: !0 })
], Z.prototype, "label", 2);
st([
  b({ type: String, reflect: !0 })
], Z.prototype, "pref", 2);
st([
  b({ type: Number, reflect: !0 })
], Z.prototype, "min", 2);
st([
  b({ type: Number, reflect: !0 })
], Z.prototype, "value", 1);
st([
  b({ type: Number, reflect: !0 })
], Z.prototype, "step", 2);
st([
  b({ type: Number, reflect: !0 })
], Z.prototype, "sensitivity", 2);
st([
  b({ type: Number, reflect: !0 })
], Z.prototype, "max", 2);
st([
  b({ type: String, reflect: !0 })
], Z.prototype, "suffix", 2);
st([
  b({ type: Boolean, reflect: !0 })
], Z.prototype, "vertical", 2);
st([
  b({ type: Boolean, reflect: !0 })
], Z.prototype, "slider", 2);
var bc = Object.defineProperty, gc = Object.getOwnPropertyDescriptor, Ye = (i, t, e, n) => {
  for (var o = n > 1 ? void 0 : n ? gc(t, e) : t, s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = (n ? r(t, e, o) : r(o)) || o);
  return n && o && bc(t, e, o), o;
};
const er = class extends I {
  constructor() {
    super(...arguments), this.onValueChange = new Event("change"), this._hidden = !1, this.headerHidden = !1, this.valueTransform = {}, this.activationButton = document.createElement("bim-button");
  }
  set hidden(t) {
    this._hidden = t, this.activationButton.active = !t, this.dispatchEvent(new Event("hiddenchange"));
  }
  get hidden() {
    return this._hidden;
  }
  /**
   * The `value` getter computes and returns the current state of the panel's form elements as an object. This property is dynamic and reflects the current input values within the panel. When accessed, it traverses the panel's child elements, collecting values from those that have a `name` or `label` attribute, and constructs an object where each key corresponds to the `name` or `label` of the element, and the value is the element's value. This property is particularly useful for forms or interactive panels where the user's input needs to be retrieved programmatically. The value returned is a snapshot of the panel's state at the time of access, and it does not maintain a live link to the input elements.
   *
   * @default {}
   * @example <bim-panel></bim-panel> <!-- Access via JavaScript to get value -->
   * @example
   * const panel = document.createElement('bim-panel');
   * document.body.appendChild(panel);
   * console.log(panel.value); // Logs the current value object of the panel
   */
  get value() {
    return gi(this, this.valueTransform);
  }
  /**
   * The `value` setter allows programmatically updating the values of the panel's form elements. When a data object is passed to this property, it attempts to match the object's keys with the `name` or `label` attributes of the panel's child elements. If a match is found, the corresponding element's value is updated to the value associated with the key in the data object. This property is useful for initializing the panel with specific data or updating its state based on external inputs. Note that this operation does not affect elements without a matching `name` or `label`, and it only updates the values of elements that are direct children of the panel.
   *
   * @type {Record<string, any>}
   * @example <bim-panel></bim-panel> <!-- Set value via JavaScript -->
   * @example
   * const panel = document.createElement('bim-panel');
   * document.body.appendChild(panel);
   * panel.value = { 'input-name': 'John Doe', 'checkbox-name': true };
   */
  set value(t) {
    const e = [...this.children];
    for (const n in t) {
      const o = e.find((r) => {
        const a = r;
        return a.name === n || a.label === n;
      });
      if (!o)
        continue;
      const s = o;
      s.value = t[n];
    }
  }
  connectedCallback() {
    super.connectedCallback(), this.activationButton.active = !this.hidden, this.activationButton.onclick = () => this.hidden = !this.hidden;
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.activationButton.remove();
  }
  /**
   * Collapses all `bim-panel-section` elements within the panel.
   * This method iterates over each `bim-panel-section` found within the panel's DOM and sets their `collapsed` property to `true`,
   * effectively hiding their content from view. This can be used to programmatically minimize the space taken up by sections
   * within the panel, making the panel more compact or to hide details that are not immediately necessary.
   */
  collapseSections() {
    const t = this.querySelectorAll("bim-panel-section");
    for (const e of t)
      e.collapsed = !0;
  }
  /**
   * Expands all `bim-panel-section` elements within the panel.
   * This method iterates over each `bim-panel-section` found within the panel's DOM and sets their `collapsed` property to `false`,
   * effectively showing their content. This can be used to programmatically reveal the content of sections within the panel,
   * making the panel more informative or to display details that are necessary for the user.
   */
  expandSections() {
    const t = this.querySelectorAll("bim-panel-section");
    for (const e of t)
      e.collapsed = !1;
  }
  render() {
    return this.activationButton.icon = this.icon, this.activationButton.label = this.label || this.name, this.activationButton.tooltipTitle = this.label || this.name, f`
      <div class="parent">
        ${this.label || this.name || this.icon ? f`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
        <div class="sections">
          <slot></slot>
        </div>
      </div>
    `;
  }
};
er.styles = [
  Ot.scrollbar,
  R`
      :host {
        display: flex;
        border-radius: var(--bim-ui_size-base);
        background-color: var(--bim-ui_bg-base);
        overflow: auto;
      }

      :host([hidden]) {
        display: none;
      }

      .parent {
        display: flex;
        flex: 1;
        flex-direction: column;
        pointer-events: auto;
        overflow: auto;
      }

      .parent bim-label {
        --bim-label--c: var(--bim-panel--c, var(--bim-ui_bg-contrast-80));
        --bim-label--fz: var(--bim-panel--fz, var(--bim-ui_size-sm));
        font-weight: 600;
        padding: 1rem;
        flex-shrink: 0;
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([header-hidden]) .parent bim-label {
        display: none;
      }

      .sections {
        display: flex;
        flex-direction: column;
        overflow: auto;
      }

      ::slotted(bim-panel-section:not(:last-child)) {
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }
    `
];
let Gt = er;
Ye([
  b({ type: String, reflect: !0 })
], Gt.prototype, "icon", 2);
Ye([
  b({ type: String, reflect: !0 })
], Gt.prototype, "name", 2);
Ye([
  b({ type: String, reflect: !0 })
], Gt.prototype, "label", 2);
Ye([
  b({ type: Boolean, reflect: !0 })
], Gt.prototype, "hidden", 1);
Ye([
  b({ type: Boolean, attribute: "header-hidden", reflect: !0 })
], Gt.prototype, "headerHidden", 2);
var vc = Object.defineProperty, Xe = (i, t, e, n) => {
  for (var o = void 0, s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = r(t, e, o) || o);
  return o && vc(t, e, o), o;
};
const ir = class extends I {
  constructor() {
    super(...arguments), this.onValueChange = new Event("change"), this.valueTransform = {};
  }
  /**
   * The `value` getter computes and returns the current state of the panel section's form elements as an object. This object's keys are the `name` or `label` attributes of the child elements, and the values are the corresponding values of these elements. This property is particularly useful for retrieving a consolidated view of the user's input or selections within the panel section. When the value of any child element changes, the returned object from this getter will reflect those changes, providing a dynamic snapshot of the panel section's state. Note that this property does not have a default value as it dynamically reflects the current state of the panel section's form elements.
   * @example <bim-panel-section></bim-panel-section> <!-- Usage in HTML not directly applicable as this is a getter -->
   * @example
   * const section = document.createElement('bim-panel-section');
   * console.log(section.value); // Logs the current value object
   */
  get value() {
    const t = this.parentElement;
    let e;
    return t instanceof Gt && (e = t.valueTransform), Object.values(this.valueTransform).length !== 0 && (e = this.valueTransform), gi(this, e);
  }
  /**
   * The `value` setter allows programmatically updating the values of the panel section's child elements. It accepts an object where keys correspond to the `name` or `label` attributes of the child elements, and the values are the new values to be set for these elements. This property is useful for initializing the panel section with specific values or updating its state based on external data. When the property changes, the corresponding child elements' values are updated to reflect the new state. This does not have a default value as it is a method for updating child elements' values.
   * @type {Record<string, any>}
   * @default undefined
   * @example <bim-panel-section></bim-panel-section> <!-- Usage in HTML not directly applicable as this is a setter -->
   * @example
   * const section = document.createElement('bim-panel-section');
   * section.value = { 'user-settings': 'John Doe' }; // Programmatically sets the value of a child element named 'user-settings'
   */
  set value(t) {
    const e = [...this.children];
    for (const n in t) {
      const o = e.find((r) => {
        const a = r;
        return a.name === n || a.label === n;
      });
      if (!o)
        continue;
      const s = o;
      s.value = t[n];
    }
  }
  onHeaderClick() {
    this.fixed || (this.collapsed = !this.collapsed);
  }
  render() {
    const t = this.label || this.icon || this.name || this.fixed, e = f`<svg
      xmlns="http://www.w3.org/2000/svg"
      height="1.125rem"
      viewBox="0 0 24 24"
      width="1.125rem"
    >
      <path d="M0 0h24v24H0V0z" fill="none" />
      <path d="M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" />
    </svg>`, n = f`<svg
      xmlns="http://www.w3.org/2000/svg"
      height="1.125rem"
      viewBox="0 0 24 24"
      width="1.125rem"
    >
      <path d="M0 0h24v24H0z" fill="none" />
      <path d="M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z" />
    </svg>`, o = this.collapsed ? e : n, s = f`
      <div
        class="header"
        title=${this.label ?? ""}
        @click=${this.onHeaderClick}
      >
        ${this.label || this.icon || this.name ? f`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
        ${this.fixed ? null : o}
      </div>
    `;
    return f`
      <div class="parent">
        ${t ? s : null}
        <div class="components">
          <slot></slot>
        </div>
      </div>
    `;
  }
};
ir.styles = [
  Ot.scrollbar,
  R`
      :host {
        display: block;
        pointer-events: auto;
      }

      :host(:not([fixed])) .header:hover {
        --bim-label--c: var(--bim-ui_accent-base);
        color: var(--bim-ui_accent-base);
        cursor: pointer;
      }

      :host(:not([fixed])) .header:hover svg {
        fill: var(--bim-ui_accent-base);
      }

      .header {
        --bim-label--fz: var(--bim-ui_size-sm);
        --bim-label--c: var(--bim-ui_bg-contrast-80);
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        height: 1.5rem;
        padding: 0.75rem 1rem;
      }

      .header svg {
        fill: var(--bim-ui_bg-contrast-80);
      }

      .title {
        display: flex;
        align-items: center;
        column-gap: 0.5rem;
      }

      .title p {
        font-size: var(--bim-ui_size-sm);
      }

      .components {
        display: flex;
        flex-direction: column;
        row-gap: 0.75rem;
        padding: 0.125rem 1rem 1rem;
      }

      :host(:not([fixed])[collapsed]) .components {
        display: none;
        height: 0px;
      }

      bim-label {
        pointer-events: none;
      }
    `
];
let he = ir;
Xe([
  b({ type: String, reflect: !0 })
], he.prototype, "icon");
Xe([
  b({ type: String, reflect: !0 })
], he.prototype, "label");
Xe([
  b({ type: String, reflect: !0 })
], he.prototype, "name");
Xe([
  b({ type: Boolean, reflect: !0 })
], he.prototype, "fixed");
Xe([
  b({ type: Boolean, reflect: !0 })
], he.prototype, "collapsed");
var yc = Object.defineProperty, Je = (i, t, e, n) => {
  for (var o = void 0, s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = r(t, e, o) || o);
  return o && yc(t, e, o), o;
};
const nr = class extends I {
  constructor() {
    super(...arguments), this.vertical = !1, this.onValueChange = new Event("change"), this._canEmitEvents = !1, this._value = document.createElement("bim-option"), this.onOptionClick = (t) => {
      this._value = t.target, this.dispatchEvent(this.onValueChange);
      for (const e of this.children)
        e instanceof W && (e.checked = e === t.target);
    };
  }
  get _options() {
    return [...this.querySelectorAll("bim-option")];
  }
  /**
   * Sets the value of the selector.
   * It finds the matching option based on the provided value and sets it as the selected option.
   * If no matching option is found, it does nothing.
   *
   * @param value - The value to set for the selector.
   */
  set value(t) {
    const e = this.findOption(t);
    if (e) {
      for (const n of this._options)
        n.checked = n === e;
      this._value = e, this._canEmitEvents && this.dispatchEvent(this.onValueChange);
    }
  }
  get value() {
    return this._value.value;
  }
  onSlotChange(t) {
    const e = t.target.assignedElements();
    for (const n of e)
      n instanceof W && (n.noMark = !0, n.removeEventListener("click", this.onOptionClick), n.addEventListener("click", this.onOptionClick));
  }
  findOption(t) {
    return this._options.find((e) => e instanceof W ? e.label === t || e.value === t : !1);
  }
  firstUpdated() {
    const t = [...this.children].find(
      (e) => e instanceof W && e.checked
    );
    t && (this._value = t);
  }
  render() {
    return f`
      <bim-input
        .vertical=${this.vertical}
        .label=${this.label}
        .icon=${this.icon}
      >
        <slot @slotchange=${this.onSlotChange}></slot>
      </bim-input>
    `;
  }
};
nr.styles = R`
    :host {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
      --bim-input--g: 0;
      --bim-option--jc: center;
      flex: 1;
      display: block;
    }

    ::slotted(bim-option) {
      border-radius: 0;
    }

    ::slotted(bim-option[checked]) {
      --bim-label--c: var(--bim-ui_main-contrast);
      background-color: var(--bim-ui_main-base);
    }
  `;
let pe = nr;
Je([
  b({ type: String, reflect: !0 })
], pe.prototype, "name");
Je([
  b({ type: String, reflect: !0 })
], pe.prototype, "icon");
Je([
  b({ type: String, reflect: !0 })
], pe.prototype, "label");
Je([
  b({ type: Boolean, reflect: !0 })
], pe.prototype, "vertical");
Je([
  le()
], pe.prototype, "_value");
const _c = () => f`
    <style>
      div {
        display: flex;
        gap: 0.375rem;
        border-radius: 0.25rem;
        min-height: 1.25rem;
      }

      [data-type="row"] {
        background-color: var(--bim-ui_bg-contrast-10);
        animation: row-loading 1s linear infinite alternate;
        padding: 0.5rem;
      }

      [data-type="cell"] {
        background-color: var(--bim-ui_bg-contrast-20);
        flex: 0.25;
      }

      @keyframes row-loading {
        0% {
          background-color: var(--bim-ui_bg-contrast-10);
        }
        100% {
          background-color: var(--bim-ui_bg-contrast-20);
        }
      }
    </style>
    <div style="display: flex; flex-direction: column;">
      <div data-type="row" style="gap: 2rem">
        <div data-type="cell" style="flex: 1"></div>
        <div data-type="cell" style="flex: 2"></div>
        <div data-type="cell" style="flex: 1"></div>
        <div data-type="cell" style="flex: 0.5"></div>
      </div>
      <div style="display: flex;">
        <div data-type="row" style="flex: 1">
          <div data-type="cell" style="flex: 0.5"></div>
        </div>
        <div data-type="row" style="flex: 2">
          <div data-type="cell" style="flex: 0.75"></div>
        </div>
        <div data-type="row" style="flex: 1">
          <div data-type="cell"></div>
        </div>
        <div data-type="row" style="flex: 0.5">
          <div data-type="cell" style="flex: 0.75"></div>
        </div>
      </div>
      <div style="display: flex;">
        <div data-type="row" style="flex: 1">
          <div data-type="cell" style="flex: 0.75"></div>
        </div>
        <div data-type="row" style="flex: 2">
          <div data-type="cell"></div>
        </div>
        <div data-type="row" style="flex: 1">
          <div data-type="cell" style="flex: 0.5"></div>
        </div>
        <div data-type="row" style="flex: 0.5">
          <div data-type="cell" style="flex: 0.5"></div>
        </div>
      </div>
      <div style="display: flex;">
        <div data-type="row" style="flex: 1">
          <div data-type="cell"></div>
        </div>
        <div data-type="row" style="flex: 2">
          <div data-type="cell" style="flex: 0.5"></div>
        </div>
        <div data-type="row" style="flex: 1">
          <div data-type="cell" style="flex: 0.75"></div>
        </div>
        <div data-type="row" style="flex: 0.5">
          <div data-type="cell" style="flex: 0.7s5"></div>
        </div>
      </div>
    </div>
  `, wc = () => f`
    <style>
      .loader {
        grid-area: Processing;
        position: relative;
        padding: 0.125rem;
      }
      .loader:before {
        content: "";
        position: absolute;
      }
      .loader .loaderBar {
        position: absolute;
        top: 0;
        right: 100%;
        bottom: 0;
        left: 0;
        background: var(--bim-ui_main-base);
        /* width: 25%; */
        width: 0;
        animation: borealisBar 2s linear infinite;
      }

      @keyframes borealisBar {
        0% {
          left: 0%;
          right: 100%;
          width: 0%;
        }
        10% {
          left: 0%;
          right: 75%;
          width: 25%;
        }
        90% {
          right: 0%;
          left: 75%;
          width: 25%;
        }
        100% {
          left: 100%;
          right: 0%;
          width: 0%;
        }
      }
    </style>
    <div class="loader">
      <div class="loaderBar"></div>
    </div>
  `;
var xc = Object.defineProperty, $c = (i, t, e, n) => {
  for (var o = void 0, s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = r(t, e, o) || o);
  return o && xc(t, e, o), o;
};
const or = class extends I {
  constructor() {
    super(...arguments), this.column = "", this.columnIndex = 0, this.rowData = {};
  }
  get data() {
    return this.column ? this.rowData[this.column] : null;
  }
  render() {
    return f`
      <style>
        :host {
          grid-area: ${this.column ?? "unset"};
        }
      </style>
      <slot></slot>
    `;
  }
};
or.styles = R`
    :host {
      padding: 0.375rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    :host([data-column-index="0"]) {
      justify-content: normal;
    }

    :host([data-column-index="0"]:not([data-cell-header]))
      ::slotted(bim-label) {
      text-align: left;
    }

    ::slotted(*) {
      --bim-input--bgc: transparent;
      --bim-input--olc: var(--bim-ui_bg-contrast-20);
      --bim-input--olw: 1px;
    }

    ::slotted(bim-input) {
      --bim-input--olw: 0;
    }

    ::slotted(bim-label) {
      white-space: normal;
      text-align: center;
    }
  `;
let sr = or;
$c([
  b({ type: String, reflect: !0 })
], sr.prototype, "column");
var Cc = Object.defineProperty, Ac = (i, t, e, n) => {
  for (var o = void 0, s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = r(t, e, o) || o);
  return o && Cc(t, e, o), o;
};
const rr = class extends I {
  constructor() {
    super(...arguments), this._groups = [], this.data = [], this.table = this.closest("bim-table");
  }
  toggleGroups(t, e = !1) {
    for (const n of this._groups)
      n.childrenHidden = typeof t > "u" ? !n.childrenHidden : !t, e && n.toggleChildren(t, e);
  }
  render() {
    return this._groups = [], f`
      <slot></slot>
      ${this.data.map((t) => {
      const e = document.createElement(
        "bim-table-group"
      );
      return this._groups.push(e), e.table = this.table, e.data = t, e;
    })}
    `;
  }
};
rr.styles = R`
    :host {
      --bim-button--bgc: transparent;
      position: relative;
      grid-area: Children;
    }

    :host([hidden]) {
      display: none;
    }

    ::slotted(.branch.branch-vertical) {
      top: 0;
      bottom: 1.125rem;
    }
  `;
let ar = rr;
Ac([
  b({ type: Array, attribute: !1 })
], ar.prototype, "data");
var Ec = Object.defineProperty, Sc = (i, t, e, n) => {
  for (var o = void 0, s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = r(t, e, o) || o);
  return o && Ec(t, e, o), o;
};
const lr = class extends I {
  constructor() {
    super(...arguments), this.data = { data: {} }, this.childrenHidden = !0, this.table = this.closest("bim-table");
  }
  connectedCallback() {
    super.connectedCallback(), this.table && this.table.expanded ? this.childrenHidden = !1 : this.childrenHidden = !0;
  }
  toggleChildren(t, e = !1) {
    this._children && (this.childrenHidden = typeof t > "u" ? !this.childrenHidden : !t, e && this._children.toggleGroups(t, e));
  }
  render() {
    if (!this.table)
      throw new Error("TableGroup: parent table wasn't found!");
    const t = this.table.getGroupIndentation(this.data) ?? 0, e = f`
      ${this.table.noIndentation ? null : f`
            <style>
              .branch-vertical {
                left: ${t + (this.table.selectableRows ? 1.9375 : 0.5625)}rem;
              }
            </style>
            <div class="branch branch-vertical"></div>
          `}
    `, n = document.createDocumentFragment();
    ne(e, n);
    let o = null;
    this.table.noIndentation || (o = document.createElement("div"), o.classList.add("branch", "branch-horizontal"), o.style.left = `${t - 1 + (this.table.selectableRows ? 2.05 : 0.5625)}rem`);
    let s = null;
    if (!this.table.noIndentation) {
      const l = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "svg"
      );
      l.setAttribute("height", "9.5"), l.setAttribute("width", "7.5"), l.setAttribute("viewBox", "0 0 4.6666672 7.3333333");
      const c = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "path"
      );
      c.setAttribute(
        "d",
        "m 1.7470835,6.9583848 2.5899999,-2.59 c 0.39,-0.39 0.39,-1.02 0,-1.41 L 1.7470835,0.36838483 c -0.63,-0.62000003 -1.71000005,-0.18 -1.71000005,0.70999997 v 5.17 c 0,0.9 1.08000005,1.34 1.71000005,0.71 z"
      ), l.append(c);
      const h = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "svg"
      );
      h.setAttribute("height", "6.5"), h.setAttribute("width", "9.5"), h.setAttribute("viewBox", "0 0 5.9111118 5.0175439");
      const u = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "path"
      );
      u.setAttribute(
        "d",
        "M -0.33616196,1.922522 2.253838,4.5125219 c 0.39,0.39 1.02,0.39 1.41,0 L 6.2538379,1.922522 c 0.6200001,-0.63 0.18,-1.71000007 -0.7099999,-1.71000007 H 0.37383804 c -0.89999997,0 -1.33999997,1.08000007 -0.71,1.71000007 z"
      ), h.append(u), s = document.createElement("div"), s.addEventListener("click", (p) => {
        p.stopPropagation(), this.toggleChildren();
      }), s.classList.add("caret"), s.style.left = `${(this.table.selectableRows ? 1.5 : 0.125) + t}rem`, this.childrenHidden ? s.append(l) : s.append(h);
    }
    const r = document.createElement("bim-table-row");
    this.data.children && !this.childrenHidden && r.append(n), r.table = this.table, r.data = this.data.data, this.table.dispatchEvent(
      new CustomEvent("rowcreated", { detail: { row: r } })
    ), s && this.data.children && r.append(s), t !== 0 && (!this.data.children || this.childrenHidden) && o && r.append(o);
    let a;
    if (this.data.children) {
      a = document.createElement("bim-table-children"), this._children = a, a.table = this.table, a.data = this.data.children;
      const l = document.createDocumentFragment();
      ne(e, l), a.append(l);
    }
    return f`
      <div class="parent">${r} ${this.childrenHidden ? null : a}</div>
    `;
  }
};
lr.styles = R`
    :host {
      position: relative;
    }

    .parent {
      display: grid;
      grid-template-areas: "Data" "Children";
    }

    .branch {
      position: absolute;
      z-index: 1;
    }

    .branch-vertical {
      border-left: 1px dotted var(--bim-ui_bg-contrast-40);
    }

    .branch-horizontal {
      top: 50%;
      width: 1rem;
      border-bottom: 1px dotted var(--bim-ui_bg-contrast-40);
    }

    .caret {
      position: absolute;
      z-index: 2;
      transform: translateY(-50%) rotate(0deg);
      top: 50%;
      display: flex;
      width: 0.95rem;
      height: 0.95rem;
      justify-content: center;
      align-items: center;
      cursor: pointer;
    }

    .caret svg {
      fill: var(--bim-ui_bg-contrast-60);
    }
  `;
let cr = lr;
Sc([
  b({ type: Boolean, attribute: "children-hidden", reflect: !0 })
], cr.prototype, "childrenHidden");
var kc = Object.defineProperty, me = (i, t, e, n) => {
  for (var o = void 0, s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = r(t, e, o) || o);
  return o && kc(t, e, o), o;
};
const dr = class extends I {
  constructor() {
    super(...arguments), this.selected = !1, this.columns = [], this.hiddenColumns = [], this.data = {}, this.isHeader = !1, this.table = this.closest("bim-table"), this.onTableColumnsChange = () => {
      this.table && (this.columns = this.table.columns);
    }, this.onTableColumnsHidden = () => {
      this.table && (this.hiddenColumns = this.table.hiddenColumns);
    }, this._observer = new IntersectionObserver(
      (t) => {
        this._intersecting = t[0].isIntersecting;
      },
      { rootMargin: "36px" }
    );
  }
  get _columnNames() {
    return this.columns.filter(
      (t) => !this.hiddenColumns.includes(t.name)
    ).map((t) => t.name);
  }
  get _columnWidths() {
    return this.columns.filter(
      (t) => !this.hiddenColumns.includes(t.name)
    ).map((t) => t.width);
  }
  get _isSelected() {
    var t;
    return (t = this.table) == null ? void 0 : t.selection.has(this.data);
  }
  onSelectionChange(t) {
    if (!this.table)
      return;
    const e = t.target;
    this.selected = e.value, e.value ? (this.table.selection.add(this.data), this.table.dispatchEvent(
      new CustomEvent("rowselected", {
        detail: {
          data: this.data
        }
      })
    )) : (this.table.selection.delete(this.data), this.table.dispatchEvent(
      new CustomEvent("rowdeselected", {
        detail: {
          data: this.data
        }
      })
    ));
  }
  connectedCallback() {
    super.connectedCallback(), this._observer.observe(this), this.table && (this.columns = this.table.columns, this.hiddenColumns = this.table.hiddenColumns, this.table.addEventListener("columnschange", this.onTableColumnsChange), this.table.addEventListener("columnshidden", this.onTableColumnsHidden), this.toggleAttribute("selected", this._isSelected));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._observer.unobserve(this), this.table && (this.columns = [], this.hiddenColumns = [], this.table.removeEventListener("columnschange", this.onTableColumnsChange), this.table.removeEventListener("columnshidden", this.onTableColumnsHidden), this.toggleAttribute("selected", !1));
  }
  compute() {
    if (!this.table)
      throw new Error("TableRow: parent table wasn't found!");
    const t = this.table.getRowIndentation(this.data) ?? 0, e = this.isHeader ? this.data : this.table.applyDataTransform(this.data) ?? this.data, n = [];
    for (const o in e) {
      if (this.hiddenColumns.includes(o))
        continue;
      const s = e[o];
      let r;
      if (typeof s == "string" || typeof s == "boolean" || typeof s == "number" ? (r = document.createElement("bim-label"), r.textContent = String(s)) : s instanceof HTMLElement ? r = s : (r = document.createDocumentFragment(), ne(s, r)), !r)
        continue;
      const a = document.createElement("bim-table-cell");
      a.append(r), a.column = o, this._columnNames.indexOf(o) === 0 && (a.style.marginLeft = `${this.table.noIndentation ? 0 : t + 0.75}rem`);
      const l = this._columnNames.indexOf(o);
      a.setAttribute("data-column-index", String(l)), a.toggleAttribute(
        "data-no-indentation",
        l === 0 && this.table.noIndentation
      ), a.toggleAttribute("data-cell-header", this.isHeader), a.rowData = this.data, this.table.dispatchEvent(
        new CustomEvent("cellcreated", {
          detail: { cell: a }
        })
      ), n.push(a);
    }
    return this.style.gridTemplateAreas = `"${this.table.selectableRows ? "Selection" : ""} ${this._columnNames.join(" ")}"`, this.style.gridTemplateColumns = `${this.table.selectableRows ? "1.6rem" : ""} ${this._columnWidths.join(" ")}`, f`
      ${!this.isHeader && this.table.selectableRows ? f`<bim-checkbox
            @change=${this.onSelectionChange}
            .checked=${this._isSelected}
            style="align-self: center; justify-self: center"
          ></bim-checkbox>` : null}
      ${n}
      <slot></slot>
    `;
  }
  render() {
    return f`${this._intersecting ? this.compute() : f``}`;
  }
};
dr.styles = R`
    :host {
      position: relative;
      grid-area: Data;
      display: grid;
      min-height: 2.25rem;
      transition: all 0.15s;
    }

    ::slotted(.branch.branch-vertical) {
      top: 50%;
      bottom: 0;
    }

    :host([selected]) {
      background-color: color-mix(
        in lab,
        var(--bim-ui_bg-contrast-20) 30%,
        var(--bim-ui_main-base) 10%
      );
    }
  `;
let qt = dr;
me([
  b({ type: Boolean, reflect: !0 })
], qt.prototype, "selected");
me([
  b({ attribute: !1 })
], qt.prototype, "columns");
me([
  b({ attribute: !1 })
], qt.prototype, "hiddenColumns");
me([
  b({ attribute: !1 })
], qt.prototype, "data");
me([
  b({ type: Boolean, attribute: "is-header", reflect: !0 })
], qt.prototype, "isHeader");
me([
  le()
], qt.prototype, "_intersecting");
var Tc = Object.defineProperty, Oc = Object.getOwnPropertyDescriptor, ct = (i, t, e, n) => {
  for (var o = n > 1 ? void 0 : n ? Oc(t, e) : t, s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = (n ? r(t, e, o) : r(o)) || o);
  return n && o && Tc(t, e, o), o;
};
const ur = class extends I {
  constructor() {
    super(...arguments), this._columnsChange = new Event("columnschange"), this._filteredData = [], this.headersHidden = !1, this.minColWidth = "4rem", this._columns = [], this._textDelimiters = {
      comma: ",",
      tab: "	"
    }, this._queryString = null, this._data = [], this.expanded = !1, this.preserveStructureOnFilter = !1, this.indentationInText = !1, this.dataTransform = {}, this.selectableRows = !1, this.selection = /* @__PURE__ */ new Set(), this.noIndentation = !1, this.loading = !1, this._errorLoading = !1, this._onColumnsHidden = new Event("columnshidden"), this._hiddenColumns = [], this.loadingErrorElement = null, this._stringFilterFunction = (t, e) => Object.values(e.data).some((n) => String(n).toLowerCase().includes(t.toLowerCase())), this._queryFilterFunction = (t, e) => {
      let n = !1;
      const o = gn(t) ?? [];
      for (const s of o) {
        if ("queries" in s) {
          n = !1;
          break;
        }
        const { condition: r, value: a } = s;
        let { key: l } = s;
        if (l.startsWith("[") && l.endsWith("]")) {
          const c = l.replace("[", "").replace("]", "");
          l = c, n = Object.keys(e.data).filter((h) => h.includes(c)).map(
            (h) => Ro(e.data[h], r, a)
          ).some((h) => h);
        } else
          n = Ro(e.data[l], r, a);
        if (!n)
          break;
      }
      return n;
    };
  }
  set columns(t) {
    const e = [];
    for (const n of t) {
      const o = typeof n == "string" ? { name: n, width: `minmax(${this.minColWidth}, 1fr)` } : n;
      e.push(o);
    }
    this._columns = e, this.computeMissingColumns(this.data), this.dispatchEvent(this._columnsChange);
  }
  get columns() {
    return this._columns;
  }
  get _headerRowData() {
    const t = {};
    for (const e of this.columns)
      if (typeof e == "string")
        t[e] = e;
      else {
        const { name: n } = e;
        t[n] = n;
      }
    return t;
  }
  /**
   * Getter for the `value` property.
   * Returns the filtered data if a search string is provided, otherwise returns the original data.
   *
   * @example
   * ```typescript
   * const tableValue = table.value;
   * console.log(tableValue); // Output: The filtered or original data.
   * ```
   */
  get value() {
    return this._filteredData;
  }
  /**
   * Sets the search string for filtering the table data.
   * This property allows you to filter the table data based on a search string.
   * If a search string is provided, the table will only display rows that match the search criteria.
   * The search criteria can be a simple string or a complex query.
   * If a simple string is provided, the table will filter rows based on the string's presence in any column.
   * If a complex query is provided, the table will filter rows based on the query's conditions and values.
   *
   * @example Simple Query
   * ```typescript
   * table.queryString = "example";
   * ```
   *
   * @example Complex Query
   * ```typescript
   * table.queryString = "column1="Jhon Doe" & column2=20";
   * ```
   */
  set queryString(t) {
    this.toggleAttribute("data-processing", !0), this._queryString = t && t.trim() !== "" ? t.trim() : null, this.updateFilteredData(), this.toggleAttribute("data-processing", !1);
  }
  get queryString() {
    return this._queryString;
  }
  set data(t) {
    this._data = t, this.updateFilteredData(), this.computeMissingColumns(t) && (this.columns = this._columns);
  }
  get data() {
    return this._data;
  }
  get dataAsync() {
    return new Promise((t) => {
      setTimeout(() => {
        t(this.data);
      });
    });
  }
  set hiddenColumns(t) {
    this._hiddenColumns = t, setTimeout(() => {
      this.dispatchEvent(this._onColumnsHidden);
    });
  }
  get hiddenColumns() {
    return this._hiddenColumns;
  }
  updateFilteredData() {
    this.queryString ? (gn(this.queryString) ? (this.filterFunction = this._queryFilterFunction, this._filteredData = this.filter(this.queryString)) : (this.filterFunction = this._stringFilterFunction, this._filteredData = this.filter(this.queryString)), this.preserveStructureOnFilter && (this._expandedBeforeFilter === void 0 && (this._expandedBeforeFilter = this.expanded), this.expanded = !0)) : (this.preserveStructureOnFilter && this._expandedBeforeFilter !== void 0 && (this.expanded = this._expandedBeforeFilter, this._expandedBeforeFilter = void 0), this._filteredData = this.data);
  }
  computeMissingColumns(t) {
    let e = !1;
    for (const n of t) {
      const { children: o, data: s } = n;
      for (const r in s)
        this._columns.map((a) => typeof a == "string" ? a : a.name).includes(r) || (this._columns.push({
          name: r,
          width: `minmax(${this.minColWidth}, 1fr)`
        }), e = !0);
      if (o) {
        const r = this.computeMissingColumns(o);
        r && !e && (e = r);
      }
    }
    return e;
  }
  generateText(t = "comma", e = this.value, n = "", o = !0) {
    const s = this._textDelimiters[t];
    let r = "";
    const a = this.columns.map((l) => l.name);
    if (o) {
      this.indentationInText && (r += `Indentation${s}`);
      const l = `${a.join(s)}
`;
      r += l;
    }
    for (const [l, c] of e.entries()) {
      const { data: h, children: u } = c, p = this.indentationInText ? `${n}${l + 1}${s}` : "", d = a.map((v) => h[v] ?? ""), m = `${p}${d.join(s)}
`;
      r += m, u && (r += this.generateText(
        t,
        c.children,
        `${n}${l + 1}.`,
        !1
      ));
    }
    return r;
  }
  /**
   * A getter function that generates a CSV (Comma Separated Values) representation of the table data.
   *
   * @returns A string containing the CSV representation of the table data.
   *
   * @example
   * ```typescript
   * const csvData = table.csv;
   * console.log(csvData); // Output: "Column 1,Column 2\nValue 1,Value 2\nValue 3,Value 4"
   * ```
   */
  get csv() {
    return this.generateText("comma");
  }
  /**
   * A getter function that generates a Tab Separated Values (TSV) representation of the table data.
   *
   * @returns A string containing the TSV representation of the table data.
   *
   * @example
   * ```typescript
   * const tsvData = table.tsv;
   * console.log(tsvData); // Output: "Column 1\tColumn 2\nValue 1\tValue 2\nValue 3\tValue 4"
   * ```
   */
  get tsv() {
    return this.generateText("tab");
  }
  applyDataTransform(t) {
    const e = {};
    for (const n of Object.keys(this.dataTransform)) {
      const o = this.columns.find((s) => s.name === n);
      o && o.forceDataTransform && (n in t || (t[n] = ""));
    }
    for (const n in t) {
      const o = this.dataTransform[n];
      o ? e[n] = o(t[n], t) : e[n] = t[n];
    }
    return e;
  }
  /**
   * The `downloadData` method is used to download the table data in different formats.
   *
   * @param fileName - The name of the downloaded file. Default is "BIM Table Data".
   * @param format - The format of the downloaded file. Can be "json", "tsv", or "csv". Default is "json".
   *
   * @returns - This method does not return any value.
   *
   * @example
   * ```typescript
   * table.downloadData("MyTableData", "tsv");
   * ```
   */
  downloadData(t = "BIM Table Data", e = "json") {
    let n = null;
    if (e === "json" && (n = new File(
      [JSON.stringify(this.value, void 0, 2)],
      `${t}.json`
    )), e === "csv" && (n = new File([this.csv], `${t}.csv`)), e === "tsv" && (n = new File([this.tsv], `${t}.tsv`)), !n)
      return;
    const o = document.createElement("a");
    o.href = URL.createObjectURL(n), o.download = n.name, o.click(), URL.revokeObjectURL(o.href);
  }
  getRowIndentation(t, e = this.value, n = 0) {
    for (const o of e) {
      if (o.data === t)
        return n;
      if (o.children) {
        const s = this.getRowIndentation(
          t,
          o.children,
          n + 1
        );
        if (s !== null)
          return s;
      }
    }
    return null;
  }
  getGroupIndentation(t, e = this.value, n = 0) {
    for (const o of e) {
      if (o === t)
        return n;
      if (o.children) {
        const s = this.getGroupIndentation(
          t,
          o.children,
          n + 1
        );
        if (s !== null)
          return s;
      }
    }
    return null;
  }
  connectedCallback() {
    super.connectedCallback(), this.dispatchEvent(new Event("connected"));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.dispatchEvent(new Event("disconnected"));
  }
  /**
   * Asynchronously loads data into the table based on Table.loadFunction.
   * If the data is already available, just set it in Table.data.
   *
   * @param force - A boolean indicating whether to force loading even if the table already has data.
   *
   * @returns - A promise that resolves to a boolean indicating whether the data loading was successful.
   * If the promise resolves to `true`, the data loading was successful.
   * If the promise resolves to `false`, the data loading was not successful.
   *
   * @remarks - If the table already has data and `force` is `false`, the function resolves to `false` without making any changes.
   * If the table already has data and `force` is `true`, the existing data is discarded before loading the new data.
   * If an error occurs during data loading, the function sets the `errorLoadingMessage` property with the error message and resolves to `false`.
   */
  async loadData(t = !1) {
    if (this._filteredData.length !== 0 && !t || !this.loadFunction)
      return !1;
    this.loading = !0;
    try {
      const e = await this.loadFunction();
      return this.data = e, this.loading = !1, this._errorLoading = !1, !0;
    } catch (e) {
      return this.loading = !1, this._filteredData.length !== 0 || (e instanceof Error && this.loadingErrorElement && e.message.trim() !== "" && (this.loadingErrorElement.textContent = e.message), this._errorLoading = !0), !1;
    }
  }
  filter(t, e = this.filterFunction ?? this._stringFilterFunction, n = this.data) {
    const o = [];
    for (const s of n)
      if (e(t, s)) {
        if (this.preserveStructureOnFilter) {
          const r = { data: s.data };
          if (s.children) {
            const a = this.filter(
              t,
              e,
              s.children
            );
            a.length && (r.children = a);
          }
          o.push(r);
        } else if (o.push({ data: s.data }), s.children) {
          const r = this.filter(
            t,
            e,
            s.children
          );
          o.push(...r);
        }
      } else if (s.children) {
        const r = this.filter(
          t,
          e,
          s.children
        );
        this.preserveStructureOnFilter && r.length ? o.push({
          data: s.data,
          children: r
        }) : o.push(...r);
      }
    return o;
  }
  get _missingDataElement() {
    return this.querySelector("[slot='missing-data']");
  }
  render() {
    if (this.loading)
      return _c();
    if (this._errorLoading)
      return f`<slot name="error-loading"></slot>`;
    if (this._filteredData.length === 0 && this._missingDataElement)
      return f`<slot name="missing-data"></slot>`;
    const t = document.createElement("bim-table-row");
    t.table = this, t.isHeader = !0, t.data = this._headerRowData, t.style.gridArea = "Header", t.style.position = "sticky", t.style.top = "0", t.style.zIndex = "5";
    const e = document.createElement("bim-table-children");
    return e.table = this, e.data = this.value, e.style.gridArea = "Body", e.style.backgroundColor = "transparent", f`
      <div class="parent">
        ${this.headersHidden ? null : t} ${wc()}
        <div style="overflow-x: hidden; grid-area: Body">${e}</div>
      </div>
    `;
  }
};
ur.styles = [
  Ot.scrollbar,
  R`
      :host {
        position: relative;
        overflow: auto;
        display: block;
        pointer-events: auto;
      }

      :host(:not([data-processing])) .loader {
        display: none;
      }

      .parent {
        display: grid;
        grid-template:
          "Header" auto
          "Processing" auto
          "Body" 1fr
          "Footer" auto;
        overflow: auto;
        height: 100%;
      }

      .parent > bim-table-row[is-header] {
        color: var(--bim-table_header--c, var(--bim-ui_bg-contrast-100));
        background-color: var(
          --bim-table_header--bgc,
          var(--bim-ui_bg-contrast-20)
        );
      }

      .controls {
        display: flex;
        gap: 0.375rem;
        flex-wrap: wrap;
        margin-bottom: 0.5rem;
      }
    `
];
let rt = ur;
ct([
  le()
], rt.prototype, "_filteredData", 2);
ct([
  b({
    type: Boolean,
    attribute: "headers-hidden",
    reflect: !0
  })
], rt.prototype, "headersHidden", 2);
ct([
  b({ type: String, attribute: "min-col-width", reflect: !0 })
], rt.prototype, "minColWidth", 2);
ct([
  b({ type: Array, attribute: !1 })
], rt.prototype, "columns", 1);
ct([
  b({ type: Array, attribute: !1 })
], rt.prototype, "data", 1);
ct([
  b({ type: Boolean, reflect: !0 })
], rt.prototype, "expanded", 2);
ct([
  b({ type: Boolean, reflect: !0, attribute: "selectable-rows" })
], rt.prototype, "selectableRows", 2);
ct([
  b({ attribute: !1 })
], rt.prototype, "selection", 2);
ct([
  b({ type: Boolean, attribute: "no-indentation", reflect: !0 })
], rt.prototype, "noIndentation", 2);
ct([
  b({ type: Boolean, reflect: !0 })
], rt.prototype, "loading", 2);
ct([
  le()
], rt.prototype, "_errorLoading", 2);
var Ic = Object.defineProperty, Rc = Object.getOwnPropertyDescriptor, Pi = (i, t, e, n) => {
  for (var o = n > 1 ? void 0 : n ? Rc(t, e) : t, s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = (n ? r(t, e, o) : r(o)) || o);
  return n && o && Ic(t, e, o), o;
};
const hr = class extends I {
  constructor() {
    super(...arguments), this._defaultName = "__unnamed__", this.name = this._defaultName, this._hidden = !1;
  }
  set hidden(t) {
    this._hidden = t, this.dispatchEvent(new Event("hiddenchange"));
  }
  get hidden() {
    return this._hidden;
  }
  connectedCallback() {
    super.connectedCallback();
    const { parentElement: t } = this;
    if (t && this.name === this._defaultName) {
      const e = [...t.children].indexOf(this);
      this.name = `${this._defaultName}${e}`;
    }
  }
  render() {
    return f` <slot></slot> `;
  }
};
hr.styles = R`
    :host {
      display: block;
      height: 100%;
    }

    :host([hidden]) {
      display: none;
    }
  `;
let it = hr;
Pi([
  b({ type: String, reflect: !0 })
], it.prototype, "name", 2);
Pi([
  b({ type: String, reflect: !0 })
], it.prototype, "label", 2);
Pi([
  b({ type: String, reflect: !0 })
], it.prototype, "icon", 2);
Pi([
  b({ type: Boolean, reflect: !0 })
], it.prototype, "hidden", 1);
var Pc = Object.defineProperty, Nc = Object.getOwnPropertyDescriptor, fe = (i, t, e, n) => {
  for (var o = n > 1 ? void 0 : n ? Nc(t, e) : t, s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = (n ? r(t, e, o) : r(o)) || o);
  return n && o && Pc(t, e, o), o;
};
const pr = class extends I {
  constructor() {
    super(...arguments), this._switchers = [], this.bottom = !1, this.switchersHidden = !1, this.floating = !1, this.switchersFull = !1, this.onTabHiddenChange = (t) => {
      const e = t.target;
      e instanceof it && !e.hidden && (e.removeEventListener("hiddenchange", this.onTabHiddenChange), this.tab = e.name, e.addEventListener("hiddenchange", this.onTabHiddenChange));
    };
  }
  set tab(t) {
    this._tab = t;
    const e = [...this.children], n = e.find(
      (o) => o instanceof it && o.name === t
    );
    for (const o of e) {
      if (!(o instanceof it))
        continue;
      o.hidden = n !== o;
      const s = this.getTabSwitcher(o.name);
      s && s.toggleAttribute("data-active", !o.hidden);
    }
  }
  get tab() {
    return this._tab;
  }
  getTabSwitcher(t) {
    return this._switchers.find(
      (e) => e.getAttribute("data-name") === t
    );
  }
  createSwitchers() {
    this._switchers = [];
    for (const t of this.children) {
      if (!(t instanceof it))
        continue;
      const e = document.createElement("div");
      e.addEventListener("click", () => {
        this.tab === t.name ? this.toggleAttribute("tab", !1) : this.tab = t.name;
      }), e.setAttribute("data-name", t.name), e.className = "switcher";
      const n = document.createElement("bim-label");
      n.textContent = t.label ?? "", n.icon = t.icon, e.append(n), this._switchers.push(e);
    }
  }
  onSlotChange(t) {
    this.createSwitchers();
    const e = t.target.assignedElements(), n = e.find((o) => o instanceof it ? this.tab ? o.name === this.tab : !o.hidden : !1);
    n && n instanceof it && (this.tab = n.name);
    for (const o of e) {
      if (!(o instanceof it)) {
        o.remove();
        continue;
      }
      o.removeEventListener("hiddenchange", this.onTabHiddenChange), n !== o && (o.hidden = !0), o.addEventListener("hiddenchange", this.onTabHiddenChange);
    }
  }
  render() {
    return f`
      <div class="parent">
        <div class="switchers">${this._switchers}</div>
        <div class="content">
          <slot @slotchange=${this.onSlotChange}></slot>
        </div>
      </div>
    `;
  }
};
pr.styles = [
  Ot.scrollbar,
  R`
      * {
        box-sizing: border-box;
      }

      :host {
        background-color: var(--bim-ui_bg-base);
        display: block;
        overflow: auto;
      }

      .parent {
        display: grid;
        grid-template: "switchers" auto "content" 1fr;
        height: 100%;
      }

      :host([bottom]) .parent {
        grid-template: "content" 1fr "switchers" auto;
      }

      .switchers {
        display: flex;
        height: 2.25rem;
        font-weight: 600;
        grid-area: switchers;
      }

      .switcher {
        --bim-label--c: var(--bim-ui_bg-contrast-80);
        background-color: var(--bim-ui_bg-base);
        cursor: pointer;
        pointer-events: auto;
        padding: 0rem 0.75rem;
        display: flex;
        justify-content: center;
        transition: all 0.15s;
      }

      :host([switchers-full]) .switcher {
        flex: 1;
      }

      .switcher:hover,
      .switcher[data-active] {
        --bim-label--c: var(--bim-ui_main-contrast);
        background-color: var(--bim-ui_main-base);
      }

      .switchers bim-label {
        pointer-events: none;
      }

      :host([switchers-hidden]) .switchers {
        display: none;
      }

      .content {
        grid-area: content;
        overflow: auto;
      }

      :host(:not([bottom])) .content {
        border-top: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([bottom]) .content {
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host(:not([tab])) .content {
        display: none;
      }

      :host([floating]) {
        background-color: transparent;
      }

      :host([floating]) .switchers {
        justify-self: center;
        overflow: auto;
      }

      :host([floating]:not([bottom])) .switchers {
        border-radius: var(--bim-ui_size-2xs) var(--bim-ui_size-2xs) 0 0;
        border-top: 1px solid var(--bim-ui_bg-contrast-20);
        border-left: 1px solid var(--bim-ui_bg-contrast-20);
        border-right: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating][bottom]) .switchers {
        border-radius: 0 0 var(--bim-ui_size-2xs) var(--bim-ui_size-2xs);
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
        border-left: 1px solid var(--bim-ui_bg-contrast-20);
        border-right: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating]:not([tab])) .switchers {
        border-radius: var(--bim-ui_size-2xs);
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating][bottom]:not([tab])) .switchers {
        border-top: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating]) .content {
        border: 1px solid var(--bim-ui_bg-contrast-20);
        border-radius: var(--bim-ui_size-2xs);
        background-color: var(--bim-ui_bg-base);
      }
    `
];
let Yt = pr;
fe([
  le()
], Yt.prototype, "_switchers", 2);
fe([
  b({ type: Boolean, reflect: !0 })
], Yt.prototype, "bottom", 2);
fe([
  b({ type: Boolean, attribute: "switchers-hidden", reflect: !0 })
], Yt.prototype, "switchersHidden", 2);
fe([
  b({ type: Boolean, reflect: !0 })
], Yt.prototype, "floating", 2);
fe([
  b({ type: String, reflect: !0 })
], Yt.prototype, "tab", 1);
fe([
  b({ type: Boolean, attribute: "switchers-full", reflect: !0 })
], Yt.prototype, "switchersFull", 2);
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Po = (i) => i ?? j;
var Mc = Object.defineProperty, Lc = Object.getOwnPropertyDescriptor, yt = (i, t, e, n) => {
  for (var o = n > 1 ? void 0 : n ? Lc(t, e) : t, s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = (n ? r(t, e, o) : r(o)) || o);
  return n && o && Mc(t, e, o), o;
};
const mr = class extends I {
  constructor() {
    super(...arguments), this._inputTypes = [
      "date",
      "datetime-local",
      "email",
      "month",
      "password",
      "search",
      "tel",
      "text",
      "time",
      "url",
      "week",
      "area"
    ], this.value = "", this.vertical = !1, this._type = "text", this.onValueChange = new Event("input");
  }
  set type(t) {
    this._inputTypes.includes(t) && (this._type = t);
  }
  get type() {
    return this._type;
  }
  /**
   * Gets the query value derived from the current input value.
   * The `getQuery` function is assumed to be a utility function that takes a string as input
   * and returns a processed query value based on the input.
   *
   * @returns The processed query value derived from the current input value.
   *
   * @example
   * ```typescript
   * const textInput = new TextInput();
   * textInput.value = "Key?Value";
   * console.log(textInput.query);
   * ```
   */
  get query() {
    return gn(this.value);
  }
  onInputChange(t) {
    t.stopPropagation();
    const e = t.target;
    clearTimeout(this._debounceTimeoutID), this._debounceTimeoutID = setTimeout(() => {
      this.value = e.value, this.dispatchEvent(this.onValueChange);
    }, this.debounce);
  }
  focus() {
    setTimeout(() => {
      var t;
      const e = (t = this.shadowRoot) == null ? void 0 : t.querySelector("input");
      e == null || e.focus();
    });
  }
  render() {
    return f`
      <bim-input
        .name=${this.name}
        .icon=${this.icon}
        .label=${this.label}
        .vertical=${this.vertical}
      >
        ${this.type === "area" ? f` <textarea
              aria-label=${this.label || this.name || "Text Input"}
              .value=${this.value}
              .rows=${this.rows ?? 5}
              placeholder=${Po(this.placeholder)}
              @input=${this.onInputChange}
            ></textarea>` : f` <input
              aria-label=${this.label || this.name || "Text Input"}
              .type=${this.type}
              .value=${this.value}
              placeholder=${Po(this.placeholder)}
              @input=${this.onInputChange}
            />`}
      </bim-input>
    `;
  }
};
mr.styles = [
  Ot.scrollbar,
  R`
      :host {
        --bim-input--bgc: var(--bim-ui_bg-contrast-20);
        flex: 1;
        display: block;
      }

      input,
      textarea {
        font-family: inherit;
        background-color: transparent;
        border: none;
        width: 100%;
        padding: var(--bim-ui_size-3xs);
        color: var(--bim-text-input--c, var(--bim-ui_bg-contrast-100));
      }

      input {
        outline: none;
        height: 100%;
        padding: 0 var(--bim-ui_size-3xs); /* Override padding */
        border-radius: var(--bim-text-input--bdrs, var(--bim-ui_size-4xs));
      }

      textarea {
        line-height: 1.1rem;
        resize: vertical;
      }

      :host(:focus) {
        --bim-input--olc: var(--bim-ui_accent-base);
      }

      /* :host([disabled]) {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
    } */
    `
];
let pt = mr;
yt([
  b({ type: String, reflect: !0 })
], pt.prototype, "icon", 2);
yt([
  b({ type: String, reflect: !0 })
], pt.prototype, "label", 2);
yt([
  b({ type: String, reflect: !0 })
], pt.prototype, "name", 2);
yt([
  b({ type: String, reflect: !0 })
], pt.prototype, "placeholder", 2);
yt([
  b({ type: String, reflect: !0 })
], pt.prototype, "value", 2);
yt([
  b({ type: Boolean, reflect: !0 })
], pt.prototype, "vertical", 2);
yt([
  b({ type: Number, reflect: !0 })
], pt.prototype, "debounce", 2);
yt([
  b({ type: Number, reflect: !0 })
], pt.prototype, "rows", 2);
yt([
  b({ type: String, reflect: !0 })
], pt.prototype, "type", 1);
var Dc = Object.defineProperty, Fc = Object.getOwnPropertyDescriptor, fr = (i, t, e, n) => {
  for (var o = n > 1 ? void 0 : n ? Fc(t, e) : t, s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = (n ? r(t, e, o) : r(o)) || o);
  return n && o && Dc(t, e, o), o;
};
const br = class extends I {
  constructor() {
    super(...arguments), this.rows = 2, this._vertical = !1;
  }
  set vertical(t) {
    this._vertical = t, this.updateChildren();
  }
  get vertical() {
    return this._vertical;
  }
  updateChildren() {
    const t = this.children;
    for (const e of t)
      this.vertical ? e.setAttribute("label-hidden", "") : e.removeAttribute("label-hidden");
  }
  render() {
    return f`
      <style>
        .parent {
          grid-auto-flow: ${this.vertical ? "row" : "column"};
          grid-template-rows: repeat(${this.rows}, 1fr);
        }
      </style>
      <div class="parent">
        <slot @slotchange=${this.updateChildren}></slot>
      </div>
    `;
  }
};
br.styles = R`
    .parent {
      display: grid;
      gap: 0.25rem;
    }

    ::slotted(bim-button[label]:not([vertical])) {
      --bim-button--jc: flex-start;
    }

    ::slotted(bim-button) {
      --bim-label--c: var(--bim-ui_bg-contrast-80);
    }
  `;
let Ni = br;
fr([
  b({ type: Number, reflect: !0 })
], Ni.prototype, "rows", 2);
fr([
  b({ type: Boolean, reflect: !0 })
], Ni.prototype, "vertical", 1);
var zc = Object.defineProperty, jc = Object.getOwnPropertyDescriptor, Mi = (i, t, e, n) => {
  for (var o = n > 1 ? void 0 : n ? jc(t, e) : t, s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = (n ? r(t, e, o) : r(o)) || o);
  return n && o && zc(t, e, o), o;
};
const gr = class extends I {
  constructor() {
    super(...arguments), this._vertical = !1, this._labelHidden = !1;
  }
  set vertical(t) {
    this._vertical = t, this.updateChildren();
  }
  get vertical() {
    return this._vertical;
  }
  set labelHidden(t) {
    this._labelHidden = t, this.updateChildren();
  }
  get labelHidden() {
    return this._labelHidden;
  }
  updateChildren() {
    const t = this.children;
    for (const e of t)
      e instanceof Ni && (e.vertical = this.vertical), e.toggleAttribute("label-hidden", this.vertical);
  }
  render() {
    return f`
      <div class="parent">
        <div class="children">
          <slot @slotchange=${this.updateChildren}></slot>
        </div>
        ${!this.labelHidden && (this.label || this.icon) ? f`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
      </div>
    `;
  }
};
gr.styles = R`
    :host {
      --bim-label--fz: var(--bim-ui_size-xs);
      --bim-label--c: var(--bim-ui_bg-contrast-60);
      display: block;
      flex: 1;
    }

    :host(:not([vertical])) ::slotted(bim-button[vertical]) {
      --bim-icon--fz: var(--bim-ui_size-5xl);
      min-height: 3.75rem;
    }

    ::slotted(bim-button) {
      --bim-label--c: var(--bim-ui_bg-contrast-80);
    }

    .parent {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      align-items: center;
      padding: 0.5rem;
      height: 100%;
      box-sizing: border-box;
      justify-content: space-between;
    }

    :host([vertical]) .parent {
      flex-direction: row-reverse;
    }

    :host([vertical]) .parent > bim-label {
      writing-mode: tb;
    }

    .children {
      display: flex;
      gap: 0.25rem;
    }

    :host([vertical]) .children {
      flex-direction: column;
    }
  `;
let be = gr;
Mi([
  b({ type: String, reflect: !0 })
], be.prototype, "label", 2);
Mi([
  b({ type: String, reflect: !0 })
], be.prototype, "icon", 2);
Mi([
  b({ type: Boolean, reflect: !0 })
], be.prototype, "vertical", 1);
Mi([
  b({ type: Boolean, attribute: "label-hidden", reflect: !0 })
], be.prototype, "labelHidden", 1);
var Bc = Object.defineProperty, Hc = Object.getOwnPropertyDescriptor, Ln = (i, t, e, n) => {
  for (var o = n > 1 ? void 0 : n ? Hc(t, e) : t, s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = (n ? r(t, e, o) : r(o)) || o);
  return n && o && Bc(t, e, o), o;
};
const vr = class extends I {
  constructor() {
    super(...arguments), this.labelsHidden = !1, this._vertical = !1, this._hidden = !1;
  }
  set vertical(t) {
    this._vertical = t, this.updateSections();
  }
  get vertical() {
    return this._vertical;
  }
  set hidden(t) {
    this._hidden = t, this.dispatchEvent(new Event("hiddenchange"));
  }
  get hidden() {
    return this._hidden;
  }
  // private setActivationButton() {
  //   this.activationButton.draggable = Manager.config.draggableToolbars;
  //   this.activationButton.addEventListener(
  //     "click",
  //     () => (this.hidden = !this.hidden),
  //   );
  //   this.activationButton.setAttribute("data-ui-manager-id", this._managerID);
  //   this.activationButton.addEventListener("dragstart", (e) => {
  //     const id = this.getAttribute("data-ui-manager-id");
  //     if (e.dataTransfer && id) {
  //       e.dataTransfer.setData("id", id);
  //       e.dataTransfer.effectAllowed = "move";
  //     }
  //     const containers = document.querySelectorAll("bim-toolbars-container");
  //     for (const container of containers) {
  //       if (container === this.parentElement) continue;
  //       container.dropping = true;
  //     }
  //   });
  //   this.activationButton.addEventListener("dragend", (e) => {
  //     if (e.dataTransfer) e.dataTransfer.clearData();
  //     const containers = document.querySelectorAll("bim-toolbars-container");
  //     for (const container of containers) {
  //       container.dropping = false;
  //     }
  //   });
  // }
  updateSections() {
    const t = this.children;
    for (const e of t)
      e instanceof be && (e.labelHidden = this.vertical && !Ee.config.sectionLabelOnVerticalToolbar, e.vertical = this.vertical);
  }
  // firstUpdated() {
  //   this.setAttribute("data-ui-manager-id", this._managerID);
  // }
  render() {
    return f`
      <div class="parent">
        <slot @slotchange=${this.updateSections}></slot>
      </div>
    `;
  }
};
vr.styles = R`
    :host {
      --bim-button--bgc: transparent;
      background-color: var(--bim-ui_bg-base);
      border-radius: var(--bim-ui_size-2xs);
      display: block;
    }

    :host([hidden]) {
      display: none;
    }

    .parent {
      display: flex;
      width: min-content;
      pointer-events: auto;
    }

    :host([vertical]) .parent {
      flex-direction: column;
    }

    :host([vertical]) {
      width: min-content;
      border-radius: var(--bim-ui_size-2xs);
      border: 1px solid var(--bim-ui_bg-contrast-20);
    }

    ::slotted(bim-toolbar-section:not(:last-child)) {
      border-right: 1px solid var(--bim-ui_bg-contrast-20);
      border-bottom: none;
    }

    :host([vertical]) ::slotted(bim-toolbar-section:not(:last-child)) {
      border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      border-right: none;
    }
  `;
let Li = vr;
Ln([
  b({ type: String, reflect: !0 })
], Li.prototype, "icon", 2);
Ln([
  b({ type: Boolean, attribute: "labels-hidden", reflect: !0 })
], Li.prototype, "labelsHidden", 2);
Ln([
  b({ type: Boolean, reflect: !0 })
], Li.prototype, "vertical", 1);
var Uc = Object.defineProperty, Vc = (i, t, e, n) => {
  for (var o = void 0, s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = r(t, e, o) || o);
  return o && Uc(t, e, o), o;
};
const yr = class extends I {
  constructor() {
    super(), this._onResize = new Event("resize"), new ResizeObserver(() => {
      setTimeout(() => {
        this.dispatchEvent(this._onResize);
      });
    }).observe(this);
  }
  render() {
    return f`
      <div class="parent">
        <slot></slot>
      </div>
    `;
  }
};
yr.styles = R`
    :host {
      display: grid;
      min-width: 0;
      min-height: 0;
      height: 100%;
    }

    .parent {
      overflow: hidden;
      position: relative;
    }
  `;
let _r = yr;
Vc([
  b({ type: String, reflect: !0 })
], _r.prototype, "name");
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const wr = "important", Wc = " !" + wr, bt = ys(class extends _s {
  constructor(i) {
    var t;
    if (super(i), i.type !== vs.ATTRIBUTE || i.name !== "style" || ((t = i.strings) == null ? void 0 : t.length) > 2)
      throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(i) {
    return Object.keys(i).reduce((t, e) => {
      const n = i[e];
      return n == null ? t : t + `${e = e.includes("-") ? e : e.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${n};`;
    }, "");
  }
  update(i, [t]) {
    const { style: e } = i.element;
    if (this.ft === void 0)
      return this.ft = new Set(Object.keys(t)), this.render(t);
    for (const n of this.ft)
      t[n] == null && (this.ft.delete(n), n.includes("-") ? e.removeProperty(n) : e[n] = null);
    for (const n in t) {
      const o = t[n];
      if (o != null) {
        this.ft.add(n);
        const s = typeof o == "string" && o.endsWith(Wc);
        n.includes("-") || s ? e.setProperty(n, s ? o.slice(0, -11) : o, s ? wr : "") : e[n] = o;
      }
    }
    return Ut;
  }
}), Gc = (i) => {
  const { components: t } = i, e = t.get(A.IfcLoader);
  return f`
    <bim-button
      data-ui-id="import-ifc"
      label="Load IFC"
      icon="mage:box-3d-fill"
      @click=${() => {
    const o = document.createElement("input");
    o.type = "file", o.accept = ".ifc", o.onchange = async () => {
      if (o.files === null || o.files.length === 0)
        return;
      const s = o.files[0], r = s.name.replace(".ifc", "");
      o.remove();
      const a = await s.arrayBuffer(), l = new Uint8Array(a);
      await e.load(l, !0, r);
    }, o.click();
  }}
    ></bim-button>
  `;
}, qc = (i) => Y.create(
  Gc,
  i
), Yc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  loadIfc: qc
}, Symbol.toStringTag, { value: "Module" })), hh = {
  ...Yc
  // fragmentExploder,
}, oi = {
  users: {
    "jhon.doe@example.com": { name: "Jhon Doe" }
  },
  priorities: {
    "On hold": {
      icon: "flowbite:circle-pause-outline",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#767676"
      }
    },
    Minor: {
      icon: "mingcute:arrows-down-fill",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#4CAF50"
      }
    },
    Normal: {
      icon: "fa6-solid:grip-lines",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FB8C00"
      }
    },
    Major: {
      icon: "mingcute:arrows-up-fill",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FF5252"
      }
    },
    Critical: {
      icon: "ph:warning",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FB8C00"
      }
    }
  },
  statuses: {
    Active: {
      icon: "prime:circle-fill",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)"
      }
    },
    "In Progress": {
      icon: "prime:circle-fill",
      style: {
        backgroundColor: "#fa89004d",
        "--bim-label--c": "#FB8C00",
        "--bim-icon--c": "#FB8C00"
      }
    },
    "In Review": {
      icon: "prime:circle-fill",
      style: {
        backgroundColor: "#9c6bff4d",
        "--bim-label--c": "#9D6BFF",
        "--bim-icon--c": "#9D6BFF"
      }
    },
    Done: {
      icon: "prime:circle-fill",
      style: {
        backgroundColor: "#4CAF504D",
        "--bim-label--c": "#4CAF50",
        "--bim-icon--c": "#4CAF50"
      }
    },
    Closed: {
      icon: "prime:circle-fill",
      style: {
        backgroundColor: "#414141",
        "--bim-label--c": "#727272",
        "--bim-icon--c": "#727272"
      }
    }
  },
  types: {
    Clash: {
      icon: "gg:close-r",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FB8C00"
      }
    },
    Issue: {
      icon: "mdi:bug-outline",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FF5252"
      }
    },
    Failure: {
      icon: "mdi:bug-outline",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FF5252"
      }
    },
    Inquiry: {
      icon: "majesticons:comment-line",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FF5252"
      }
    },
    Fault: {
      icon: "ph:warning",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FF5252"
      }
    },
    Remark: {
      icon: "ph:note-blank-bold",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FB8C00"
      }
    },
    Request: {
      icon: "mynaui:edit-one",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#9D6BFF"
      }
    }
  }
}, Xi = {
  padding: "0.25rem 0.5rem",
  borderRadius: "999px",
  "--bim-label--c": "var(--bim-ui_bg-contrast-100)"
}, No = (i, t) => {
  const n = ((t == null ? void 0 : t.users) ?? oi.users)[i], o = (n == null ? void 0 : n.name) ?? i, s = o.trim().split(/\s+/);
  let r, a;
  return s[0] && s[0][0] && (r = s[0][0].toUpperCase(), s[0][1] && (a = s[0][1].toUpperCase())), s[1] && s[1][0] && (a = s[1][0].toUpperCase()), f`
  <div style="display: flex; gap: 0.25rem; overflow: hidden;">
    ${!(n != null && n.picture) && (r || a) ? f`
      <bim-label
        style=${bt({
    borderRadius: "999px",
    padding: "0.375rem",
    backgroundColor: "var(--bim-ui_bg-contrast-20)",
    aspectRatio: "1",
    fontSize: "0.7rem"
  })}>${r}${a}</bim-label>
      ` : null}
    <bim-label .img=${n == null ? void 0 : n.picture}>${o}</bim-label>
  </div>
`;
}, Xc = (i) => {
  const { components: t, dataStyles: e, onTopicEnter: n } = i, o = t.get(A.BCFTopics), s = i.topics ?? o.list.values();
  return f`
    <bim-table @cellcreated=${({ detail: a }) => {
    const { cell: l } = a;
    l.style.marginLeft = "0";
  }} ${J((a) => {
    if (!a)
      return;
    const l = a;
    l.hiddenColumns = ["Guid"], l.columns = ["Title"], l.selectableRows = !0, l.dataTransform = {
      Title: (c, h) => {
        const { Guid: u } = h;
        if (typeof u != "string")
          return c;
        const p = o.list.get(u);
        return p ? f`
        <div style="display: flex; overflow: hidden;">
          <style>
            #BBETO {
              background-color: transparent
            }
  
            #BBETO:hover {
              --bim-label--c: var(--bim-ui_accent-base)
            }
          </style> 
          <bim-button @click=${() => {
          n && n(p);
        }} id="BBETO" icon="iconamoon:enter-duotone"></bim-button>
          <bim-label>${c}</bim-label>
        </div>` : c;
      },
      Priority: (c) => {
        if (typeof c != "string")
          return c;
        const u = ((e == null ? void 0 : e.priorities) ?? oi.priorities)[c];
        return f`
          <bim-label
            .icon=${u == null ? void 0 : u.icon}
            style=${bt({ ...Xi, ...u == null ? void 0 : u.style })}
          >${c}
          </bim-label>
        `;
      },
      Status: (c) => {
        if (typeof c != "string")
          return c;
        const u = ((e == null ? void 0 : e.statuses) ?? oi.statuses)[c];
        return f`
          <bim-label
            .icon=${u == null ? void 0 : u.icon}
            style=${bt({ ...Xi, ...u == null ? void 0 : u.style })}
          >${c}
          </bim-label>
        `;
      },
      Type: (c) => {
        if (typeof c != "string")
          return c;
        const u = ((e == null ? void 0 : e.types) ?? oi.types)[c];
        return f`
          <bim-label
            .icon=${u == null ? void 0 : u.icon}
            style=${bt({ ...Xi, ...u == null ? void 0 : u.style })}
          >${c}
          </bim-label>
        `;
      },
      Author: (c) => typeof c != "string" ? c : No(c, e),
      Assignee: (c) => typeof c != "string" ? c : No(c, e)
    }, l.data = [...s].map((c) => {
      var h;
      return {
        data: {
          Guid: c.guid,
          Title: c.title,
          Status: c.status,
          Description: c.description ?? "",
          Author: c.creationAuthor,
          Assignee: c.assignedTo ?? "",
          Date: c.creationDate.toDateString(),
          DueDate: ((h = c.dueDate) == null ? void 0 : h.toDateString()) ?? "",
          Type: c.type,
          Priority: c.priority ?? ""
        }
      };
    });
  })}>
      <bim-label slot="missing-data" icon="ph:warning-fill" style="--bim-icon--c: gold;">There are no topics to display</bim-label>
    </bim-table>`;
}, xr = (i, t = !0) => {
  const e = Y.create(
    Xc,
    i
  );
  if (t) {
    const { components: n, topics: o } = i, [, s] = e, r = n.get(A.BCFTopics);
    if (r.list.onItemUpdated.add(() => s()), r.list.onItemDeleted.add(() => s()), o)
      for (const a of o)
        a.relatedTopics.onItemAdded.add(() => s()), a.relatedTopics.onItemDeleted.add(() => s()), a.relatedTopics.onCleared.add(() => s());
    else
      r.list.onItemSet.add(() => s());
  }
  return e;
}, Jc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  topicsList: xr
}, Symbol.toStringTag, { value: "Module" })), Qc = (i) => {
  var c;
  const { components: t, topic: e, actions: n } = i, o = {
    selectComponents: !0,
    colorizeComponent: !0,
    resetColors: !0,
    updateCamera: !0,
    delete: !0,
    unlink: !!e,
    ...n
  }, s = t.get(A.Viewpoints), r = ((c = i.topic) == null ? void 0 : c.viewpoints) ?? s.list.keys(), a = [];
  for (const h of r) {
    const u = s.list.get(h);
    u && a.push(u);
  }
  return f`
    <bim-table ${J((h) => {
    if (!h)
      return;
    const u = h;
    u.addEventListener("cellcreated", ({ detail: p }) => {
      const { cell: d } = p;
      d.style.padding = "0.25rem";
    }), u.headersHidden = !0, u.hiddenColumns = ["Guid"], u.columns = ["Title", { name: "Actions", width: "auto" }], u.dataTransform = {
      Actions: (p, d) => {
        const { Guid: m } = d;
        if (!(m && typeof m == "string"))
          return m;
        const v = s.list.get(m);
        return v ? f`
          <bim-button icon="ph:eye-fill" @click=${() => v.go()}></bim-button>
          ${Object.values(o).includes(!0) ? f`
                <bim-button icon="prime:ellipsis-v">
                  <bim-context-menu>
                    ${o.selectComponents ? f`<bim-button label="Select Components" @click=${() => console.log(v.selection)}></bim-button> ` : null}
                    ${o.colorizeComponent ? f`<bim-button label="Colorize Components" @click=${() => v.colorize()}></bim-button> ` : null}
                    ${o.resetColors ? f`<bim-button label="Reset Colors" @click=${() => v.resetColors()}></bim-button> ` : null}
                    ${o.updateCamera ? f`<bim-button label="Update Camera" @click=${() => v.updateCamera()}></bim-button> ` : null}
                    ${o.unlink ? f`<bim-button .disabled=${!e} label="Unlink" @click=${() => e == null ? void 0 : e.viewpoints.delete(v.guid)}></bim-button> ` : null}
                    ${o.delete ? f`<bim-button label="Delete" @click=${() => s.list.delete(v.guid)}></bim-button>` : null}
                  </bim-context-menu>
                </bim-button>
              ` : null}
        ` : m;
      }
    }, u.data = a.map((p, d) => ({
      data: {
        Guid: p.guid,
        Title: p.title ?? `Viewpoint ${i.topic ? d + 1 : ""}`,
        Actions: ""
      }
    }));
  })}>
      <bim-label slot="missing-data" icon="ph:warning-fill" style="--bim-icon--c: gold;">No viewpoints to show</bim-label>
    </bim-table>
  `;
}, Dn = (i, t = !0) => {
  const e = Y.create(
    Qc,
    i
  ), { components: n, topic: o } = i;
  if (t) {
    const [, s] = e, r = n.get(A.Viewpoints);
    r.list.onItemUpdated.add(() => s()), r.list.onItemDeleted.add(() => s()), r.list.onCleared.add(() => s()), o ? (o.viewpoints.onItemAdded.add(() => s()), o.viewpoints.onItemDeleted.add(() => s()), o.viewpoints.onCleared.add(() => s())) : r.list.onItemSet.add(() => s());
  }
  return e;
}, Kc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  viewpointsList: Dn
}, Symbol.toStringTag, { value: "Module" })), Zc = {
  "jhon.doe@example.com": {
    name: "Jhon Doe",
    picture: "https://www.profilebakery.com/wp-content/uploads/2023/04/Profile-Image-AI.jpg"
  }
}, td = (i, t) => {
  const n = (t ?? Zc)[i], o = (n == null ? void 0 : n.name) ?? i, s = o.trim().split(/\s+/);
  let r, a;
  return s[0] && s[0][0] && (r = s[0][0].toUpperCase(), s[0][1] && (a = s[0][1].toUpperCase())), s[1] && s[1][0] && (a = s[1][0].toUpperCase()), f`
  <div style="display: flex; gap: 0.25rem; overflow: hidden;">
    ${!(n != null && n.picture) && (r || a) ? f`
      <bim-label
        style=${bt({
    borderRadius: "999px",
    padding: "0.375rem",
    backgroundColor: "var(--bim-ui_bg-contrast-20)",
    aspectRatio: "1",
    fontSize: "0.7rem"
  })}>${r}${a}</bim-label>
      ` : null}
    <bim-label .img=${n == null ? void 0 : n.picture}>${o}</bim-label>
  </div>
`;
}, ed = (i) => {
  const { topic: t, styles: e, viewpoint: n, actions: o } = i, s = { delete: !0, ...o };
  return f`<bim-table @cellcreated=${({ detail: a }) => {
    const { cell: l } = a;
    l.style.marginLeft = "0";
  }} ${J((a) => {
    if (!a)
      return;
    const l = a;
    l.headersHidden = !0, l.hiddenColumns = ["guid", "author"], l.dataTransform = {
      Comment: (h, u) => {
        const { guid: p } = u;
        if (typeof p != "string")
          return h;
        const d = t.comments.get(p);
        if (!d)
          return h;
        const m = () => {
          t.comments.delete(p);
        };
        return f`
        <div style="display: flex; flex-direction: column; gap: 0.25rem; flex: 1">
          <div style="display: flex; justify-content: space-between;">
            <div style="display: flex; gap: 0.375rem;">
              ${td(d.author, e)}
              <bim-label style="color: var(--bim-ui_bg-contrast-40)">@ ${d.date.toDateString()}</bim-label>
            </div>
            <div>
              <style>
                #TCDBT {
                  background-color: transparent;
                  --bim-label--c: var(--bim-ui_bg-contrast-60)
                }

                #TCDBT:hover {
                  --bim-label--c: #FF5252;
                }
              </style>
              ${s != null && s.delete ? f`<bim-button @click=${m} id="TCDBT" icon="majesticons:delete-bin"></bim-button>` : null}
            </div>
          </div>
          <bim-label style="margin-left: 1.7rem; white-space: normal">${d.comment}</bim-label>
        </div>
      `;
      }
    };
    let c = t.comments.values();
    n && (c = [...t.comments.values()].filter(
      (h) => h.viewpoint === n
    )), l.data = [...c].map((h) => ({
      data: {
        guid: h.guid,
        Comment: h.comment,
        author: (() => {
          const u = e;
          if (!u)
            return h.author;
          const p = u[h.author];
          return (p == null ? void 0 : p.name) ?? h.author;
        })()
      }
    }));
  })}><bim-label slot="missing-data" icon="ph:warning-fill" style="--bim-icon--c: gold;">This topic has no comments</bim-label></bim-table>`;
}, $r = (i, t = !0) => {
  const e = Y.create(
    ed,
    i
  );
  if (t) {
    const { topic: n } = i, [o, s] = e;
    n.comments.onItemSet.add(() => s()), n.comments.onItemUpdated.add(() => s()), n.comments.onItemDeleted.add(() => s()), n.comments.onCleared.add(() => s());
  }
  return e;
}, id = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  topicComments: $r
}, Symbol.toStringTag, { value: "Module" })), si = {
  users: {
    "jhon.doe@example.com": { name: "Jhon Doe" }
  },
  priorities: {
    "On hold": {
      icon: "flowbite:circle-pause-outline",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#767676"
      }
    },
    Minor: {
      icon: "mingcute:arrows-down-fill",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#4CAF50"
      }
    },
    Normal: {
      icon: "fa6-solid:grip-lines",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FB8C00"
      }
    },
    Major: {
      icon: "mingcute:arrows-up-fill",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FF5252"
      }
    },
    Critical: {
      icon: "ph:warning",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FB8C00"
      }
    }
  },
  statuses: {
    Active: {
      icon: "prime:circle-fill",
      style: {
        backgroundColor: "#2E2E2E"
      }
    },
    "In Progress": {
      icon: "prime:circle-fill",
      style: {
        backgroundColor: "#fa89004d",
        "--bim-label--c": "#FB8C00",
        "--bim-icon--c": "#FB8C00"
      }
    },
    "In Review": {
      icon: "prime:circle-fill",
      style: {
        backgroundColor: "#9c6bff4d",
        "--bim-label--c": "#9D6BFF",
        "--bim-icon--c": "#9D6BFF"
      }
    },
    Done: {
      icon: "prime:circle-fill",
      style: {
        backgroundColor: "#4CAF504D",
        "--bim-label--c": "#4CAF50",
        "--bim-icon--c": "#4CAF50"
      }
    },
    Closed: {
      icon: "prime:circle-fill",
      style: {
        backgroundColor: "#2E2E2E",
        "--bim-label--c": "#727272",
        "--bim-icon--c": "#727272"
      }
    }
  },
  types: {
    Clash: {
      icon: "gg:close-r",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FB8C00"
      }
    },
    Issue: {
      icon: "mdi:bug-outline",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FF5252"
      }
    },
    Failure: {
      icon: "mdi:bug-outline",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FF5252"
      }
    },
    Inquiry: {
      icon: "majesticons:comment-line",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FF5252"
      }
    },
    Fault: {
      icon: "ph:warning",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FF5252"
      }
    },
    Remark: {
      icon: "ph:note-blank-bold",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#FB8C00"
      }
    },
    Request: {
      icon: "mynaui:edit-one",
      style: {
        backgroundColor: "var(--bim-ui_bg-contrast-20)",
        "--bim-icon--c": "#9D6BFF"
      }
    }
  }
}, Ji = {
  padding: "0.25rem 0.5rem",
  borderRadius: "999px",
  "--bim-label--c": "white"
}, Qi = (i, t) => {
  const n = ((t == null ? void 0 : t.users) ?? si.users)[i], o = (n == null ? void 0 : n.name) ?? i, s = o.trim().split(/\s+/);
  let r, a;
  return s[0] && s[0][0] && (r = s[0][0].toUpperCase(), s[0][1] && (a = s[0][1].toUpperCase())), s[1] && s[1][0] && (a = s[1][0].toUpperCase()), f`
  <div style="display: flex; gap: 0.25rem; overflow: hidden;">
    ${!(n != null && n.picture) && (r || a) ? f`
      <bim-label
        style=${bt({
    borderRadius: "999px",
    padding: "0.375rem",
    backgroundColor: "var(--bim-ui_bg-contrast-20)",
    aspectRatio: "1",
    fontSize: "0.7rem"
  })}>${r}${a}</bim-label>
      ` : null}
    <bim-label .img=${n == null ? void 0 : n.picture}>${o}</bim-label>
  </div>
`;
}, [vi, nd] = Y.create((i) => {
  const { topic: t } = i, e = document.createElement("bim-text-input");
  e.type = "area";
  const n = () => {
    e.value = "", vi.close(), vi.remove();
  };
  return f`
     <dialog>
      ${t ? f`
            <bim-panel style="border-radius: var(--bim-ui_size-base); outline: 2px solid var(--bim-ui_bg-contrast-20); width: 20rem;">
              <bim-panel-section label="New Comment" fixed>
                ${e}
                <div style="justify-content: right; display: flex; gap: 0.375rem">
                  <style>
                    #PAISD {
                      background-color: transparent;
                    }

                    #PAISD:hover {
                      --bim-label--c: #FF5252;
                    }

                    #MDOG9:hover {
                      background-color: #329936;
                    }
                  </style>
                  <bim-button @click=${n} style="flex: 0" id="PAISD" label="Cancel"></bim-button>
                  <bim-button @click=${() => {
    const s = e.value;
    !t || s.trim() === "" || (t.createComment(s), n());
  }} style="flex: 0" id="MDOG9" label="Add Comment"} icon="mi:add"}></bim-button>
                </div>
              </bim-panel-section>
            </bim-panel> 
          ` : f`<bim-label>No topic refereced</bim-label>`}
     </dialog> 
    `;
}, {}), [yi, od] = Y.create((i) => {
  const { components: t, topic: e } = i;
  let n;
  t && (n = Dn({
    components: t,
    actions: {
      delete: !1,
      updateCamera: !1,
      colorizeComponent: !1,
      resetColors: !1,
      selectComponents: !1
    }
  })[0], n.selectableRows = !0);
  const o = () => {
    yi.close(), yi.remove(), n == null || n.remove();
  };
  return f`
     <dialog>
      ${e ? f`
            <bim-panel style="border-radius: var(--bim-ui_size-base); outline: 2px solid var(--bim-ui_bg-contrast-20); width: 20rem;">
              <bim-panel-section label="Link Viewpoints" fixed>
                ${n}
                <div style="justify-content: right; display: flex; gap: 0.375rem">
                  <style>
                    #PAISD {
                      background-color: transparent;
                    }

                    #PAISD:hover {
                      --bim-label--c: #FF5252;
                    }

                    #MDOG9:hover {
                      background-color: #329936;
                    }
                  </style>
                  <bim-button @click=${o} style="flex: 0" id="PAISD" label="Cancel"></bim-button>
                  <bim-button @click=${() => {
    if (!(n && e))
      return;
    const r = n.selection;
    for (const a of r) {
      const { Guid: l } = a;
      typeof l == "string" && e.viewpoints.add(l);
    }
    o();
  }} style="flex: 0" id="MDOG9" label="Link Viewpoints"} icon="mi:add"}></bim-button>
                </div>
              </bim-panel-section>
            </bim-panel> 
          ` : f`<bim-label>No topic refereced</bim-label>`}
     </dialog> 
    `;
}, {}), [_i, sd] = Y.create((i) => {
  const { components: t, topic: e } = i;
  let n;
  if (t) {
    const a = [...t.get(A.BCFTopics).list.values()].filter(
      (l) => l !== e
    );
    n = xr({
      components: t,
      topics: a
    })[0], n.selectableRows = !0, n.hiddenColumns = ["Guid", "Author", "Assignee", "Date", "DueDate"];
  }
  const o = () => {
    _i.close(), _i.remove(), n == null || n.remove();
  };
  return f`
     <dialog>
        <bim-panel style="border-radius: var(--bim-ui_size-base); outline: 2px solid var(--bim-ui_bg-contrast-20); width: 50rem;">
          <bim-panel-section label="Link Viewpoints" fixed>
            ${n}
            <div style="justify-content: right; display: flex; gap: 0.375rem">
              <style>
                #PAISD {
                  background-color: transparent;
                }

                #PAISD:hover {
                  --bim-label--c: #FF5252;
                }

                #MDOG9:hover {
                  background-color: #329936;
                }
              </style>
              <bim-button @click=${o} style="flex: 0" id="PAISD" label="Cancel"></bim-button>
              <bim-button @click=${() => {
    if (!(n && e))
      return;
    const r = n.selection;
    for (const a of r) {
      const { Guid: l } = a;
      typeof l == "string" && e.relatedTopics.add(l);
    }
    o();
  }} style="flex: 0" id="MDOG9" label="Link Topics"} icon="mi:add"}></bim-button>
            </div>
          </bim-panel-section>
        </bim-panel> 
     </dialog> 
    `;
}, {}), rd = (i) => {
  const {
    components: t,
    topic: e,
    styles: n,
    onUpdateInformation: o,
    actions: s,
    world: r
  } = i, a = {
    update: !0,
    addComments: !0,
    linkViewpoints: !0,
    addViewpoints: !0,
    linkTopics: !0,
    ...s
  }, l = (n == null ? void 0 : n.priorities) ?? si.priorities, c = (n == null ? void 0 : n.statuses) ?? si.statuses, h = (n == null ? void 0 : n.types) ?? si.types;
  let u;
  e != null && e.priority && (u = l[e.priority]);
  let p;
  e != null && e.type && (p = h[e.type]);
  let d;
  e != null && e.type && (d = c[e.status]);
  let m, v, w;
  e && (m = $r({
    topic: e,
    styles: n == null ? void 0 : n.users
  })[0], v = Dn({
    components: t,
    topic: e
  })[0]);
  const C = () => {
    if (!(e && r))
      return;
    const _ = t.get(A.Viewpoints).create(r);
    e.viewpoints.add(_.guid);
  }, x = () => {
    nd({ topic: e }), document.body.append(vi), vi.showModal();
  }, g = () => {
    od({ components: t, topic: e }), document.body.append(yi), yi.showModal();
  }, y = () => {
    sd({ components: t, topic: e }), document.body.append(_i), _i.showModal();
  };
  return f`
   <bim-panel>
    ${e ? f`
      <bim-panel-section label="Information" icon="ph:info-bold" collapsed>
      <div>
        <bim-label>Title</bim-label> 
        <bim-label style="--bim-label--c: var(--bim-ui_bg-contrast-100)">${e.title}</bim-label> 
      </div>
      <div>
        <bim-label>Description</bim-label> 
        <bim-label style="--bim-label--c: var(--bim-ui_bg-contrast-100)">${e.description}</bim-label> 
      </div>
      <div style="display: flex; gap: 0.375rem">
        <bim-label>Status</bim-label> 
        <bim-label .icon=${d == null ? void 0 : d.icon} style=${bt({ ...Ji, ...d == null ? void 0 : d.style })}
        >${e.status}
        </bim-label>
      </div>
      <div style="display: flex; gap: 0.375rem">
        <bim-label>Type</bim-label> 
        <bim-label .icon=${p == null ? void 0 : p.icon} style=${bt({ ...Ji, ...p == null ? void 0 : p.style })}
        >${e.type}
        </bim-label>
      </div>
      ${e.priority ? f`
            <div style="display: flex; gap: 0.375rem">
              <bim-label>Priority</bim-label> 
              <bim-label .icon=${u == null ? void 0 : u.icon} style=${bt({ ...Ji, ...u == null ? void 0 : u.style })}
              >${e.priority}
              </bim-label>
            </div>` : null}
      <div style="display: flex; gap: 0.375rem">
        <bim-label>Author</bim-label> 
        ${Qi(e.creationAuthor, n)}
      </div>
      ${e.assignedTo ? f`
          <div style="display: flex; gap: 0.375rem">
            <bim-label>Assignee</bim-label> 
            ${Qi(e.assignedTo, n)}
          </div>` : null}
      ${e.dueDate ? f`
          <div style="display: flex; gap: 0.375rem">
            <bim-label>Due Date</bim-label> 
            <bim-label style="--bim-label--c: var(--bim-ui_bg-contrast-100)">${e.dueDate.toDateString()}</bim-label>
          </div>` : null}
      ${e.modifiedAuthor ? f`
          <div style="display: flex; gap: 0.375rem">
            <bim-label>Modified By</bim-label> 
            ${Qi(e.modifiedAuthor, n)}
          </div>` : null}
      ${e.modifiedDate ? f`
            <div style="display: flex; gap: 0.375rem">
              <bim-label>Modified Date</bim-label> 
              <bim-label style="--bim-label--c: var(--bim-ui_bg-contrast-100)">${e.modifiedDate.toDateString()}</bim-label>
            </div>` : null}
      ${e.labels.size !== 0 ? f`
          <div style="display: flex; gap: 0.375rem">
            <bim-label>Labels</bim-label> 
            <bim-label style="--bim-label--c: var(--bim-ui_bg-contrast-100)">${[...e.labels].join(", ")}</bim-label>
          </div>` : null}
      ${a.update ? f`
            <bim-button @click=${() => {
    o && o(e);
  }} label="Update Information" icon="tabler:refresh"></bim-button> 
          ` : null}
    </bim-panel-section>
    <bim-panel-section label="Comments" icon="majesticons:comment-line">
      ${m}
      ${a.addComments ? f`
            <bim-button @click=${x} label="Add Comment" icon="majesticons:comment-line"></bim-button>
          ` : null}
    </bim-panel-section>
    <bim-panel-section label="Viewpoints" icon="tabler:camera">
      ${v}
      ${a.linkViewpoints || a.addViewpoints ? f`
          <div style="display: flex; gap: 0.375rem">
            ${a.addViewpoints ? f`<bim-button @click=${C} .disabled=${!r} label="Add Viewpoint" icon="mi:add"></bim-button> ` : null}
            ${a.linkViewpoints ? f`<bim-button @click=${g} label="Link Viewpoint" icon="tabler:camera"></bim-button>` : null}
          </div>
          ` : null}
    </bim-panel-section>
    <!-- <bim-panel-section label="Related Topics" icon="material-symbols:topic-outline">
      ${w}
      ${a.linkViewpoints ? f`
            <bim-button @click=${y} label="Link Topic" icon="material-symbols:topic-outline"></bim-button> 
          ` : null}
    </bim-panel-section> -->
    ` : f`<bim-label>No topic selected!</bim-label>`}
   </bim-panel> 
  `;
}, ad = (i, t = !0) => {
  const e = Y.create(
    rd,
    i
  );
  if (t) {
    const { components: n } = i, [o, s] = e;
    n.get(A.BCFTopics).list.onItemUpdated.add(({ value: a }) => {
      const { topic: l } = s(), { guid: c } = a;
      c === (l == null ? void 0 : l.guid) && s();
    });
  }
  return e;
}, ld = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  topicData: ad
}, Symbol.toStringTag, { value: "Module" })), ph = {
  // mesh,
  ...ld
}, cd = (i) => {
  const { components: t, actions: e, tags: n } = i, o = (e == null ? void 0 : e.dispose) ?? !0, s = (e == null ? void 0 : e.download) ?? !0, r = (e == null ? void 0 : e.visibility) ?? !0, a = (n == null ? void 0 : n.schema) ?? !0, l = (n == null ? void 0 : n.viewDefinition) ?? !0, c = t.get(A.FragmentsManager), h = ({
    detail: p
  }) => {
    const { cell: d } = p;
    d.style.padding = "0.25rem 0";
  };
  return f`
    <bim-table ${J((p) => {
    if (!p)
      return;
    const d = p;
    d.hiddenColumns = ["modelID"];
    const m = [];
    for (const [, v] of c.groups) {
      if (!v)
        continue;
      const w = {
        data: {
          Name: v.name || v.uuid,
          modelID: v.uuid
        }
      };
      m.push(w);
    }
    d.dataTransform = {
      Name: (v, w) => {
        const { modelID: C } = w;
        if (typeof C != "string")
          return v;
        const x = c.groups.get(C);
        if (!x)
          return C;
        const g = {};
        for (const T of x.items)
          g[T.id] = T.ids;
        let y;
        const { schema: $ } = x.ifcMetadata;
        a && $ && (y = f`
            <bim-label style="background-color: var(--bim-ui_main-base); padding: 0 0.25rem; color: var(--bim-ui_main-contrast); border-radius: 0.25rem;">${$}</bim-label>
            `);
        let _;
        if (l && "viewDefinition" in x.ifcMetadata) {
          const T = x.ifcMetadata.viewDefinition;
          _ = f`
            ${T.split(",").map((M) => f`<bim-label style="background-color: var(--bim-ui_main-base); padding: 0 0.25rem; color: var(--bim-ui_main-contrast); border-radius: 0.25rem;">${M}</bim-label>`)}
          `;
        }
        let E;
        o && (E = f`<bim-button @click=${() => c.disposeGroup(x)} icon="mdi:delete"></bim-button>`);
        let L;
        r && (L = f`<bim-button @click=${(M) => {
          const S = t.get(A.Hider), P = M.target;
          S.set(P.hasAttribute("data-model-hidden"), g), P.toggleAttribute("data-model-hidden"), P.icon = P.hasAttribute("data-model-hidden") ? "mdi:eye-off" : "mdi:eye";
        }} icon="mdi:eye"></bim-button>`);
        let D;
        return s && (D = f`<bim-button @click=${() => {
          const M = document.createElement("input");
          M.type = "file", M.accept = ".ifc", M.multiple = !1, M.addEventListener("change", async () => {
            if (!(M.files && M.files.length === 1))
              return;
            const S = M.files[0], P = await S.arrayBuffer(), tt = await t.get(A.IfcPropertiesManager).saveToIfc(
              x,
              new Uint8Array(P)
            ), B = new File(
              [tt],
              S.name
            ), X = document.createElement("a");
            X.href = URL.createObjectURL(B), X.download = B.name, X.click(), URL.revokeObjectURL(X.href);
          }), M.click();
        }} icon="flowbite:download-solid"></bim-button>`), f`
         <div style="display: flex; flex: 1; gap: var(--bim-ui_size-4xs); justify-content: space-between; overflow: auto;">
          <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 0 var(--bim-ui_size-4xs); flex-grow: 1; overflow: auto;">
            <div style="min-height: 1.75rem; overflow: auto; display: flex;">
              <bim-label style="white-space: normal;">${v}</bim-label>
            </div>
            <div style="display: flex; flex-wrap: wrap; gap: var(--bim-ui_size-4xs); overflow: auto;">
              ${y}
              ${_}
            </div>
          </div>
          <div style="display: flex; align-self: flex-start; flex-shrink: 0;">
            ${D}
            ${L}
            ${E}
          </div>
         </div>
        `;
      }
    }, d.data = m;
  })} @cellcreated=${h} headers-hidden no-indentation>
      <bim-label slot="missing-data" style="--bim-icon--c: gold" icon="ic:round-warning">
        No models has been loaded yet
      </bim-label>
    </bim-table>
  `;
}, dd = (i, t = !0) => {
  const e = Y.create(
    cd,
    i
  );
  if (t) {
    const { components: n } = i, o = n.get(A.FragmentsManager), [, s] = e;
    o.onFragmentsLoaded.add(() => setTimeout(() => s())), o.onFragmentsDisposed.add(() => s());
  }
  return e;
}, ud = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  modelsList: dd
}, Symbol.toStringTag, { value: "Module" })), Cr = [
  "Name",
  "ContainedInStructure",
  "ForLayerSet",
  "LayerThickness",
  "HasProperties",
  "HasAssociations",
  "HasAssignments",
  "HasPropertySets",
  "PredefinedType",
  "Quantities",
  "ReferencedSource",
  "Identification",
  (i) => i.includes("Value"),
  (i) => i.startsWith("Material"),
  (i) => i.startsWith("Relating"),
  (i) => {
    const t = ["IsGroupedBy", "IsDecomposedBy"];
    return i.startsWith("Is") && !t.includes(i);
  }
];
async function ri(i, t, e, n = Cr, o = !1) {
  const s = i.get(A.IfcRelationsIndexer), r = await t.getProperties(e);
  if (!r)
    return {
      data: { Entity: `${e} properties not found...` }
      // onRowCreated(row) {
      //   row.addEventListener("cellcreated", (event) => {
      //     if (!(event instanceof CustomEvent)) return;
      //     const { cell } = event.detail;
      //     cell.style.gridColumn = "1 / -1";
      //   });
      // },
    };
  const a = s.relationMaps[t.uuid], l = {
    data: {}
  };
  for (const c in r) {
    const h = n.map((p) => typeof p == "string" ? c === p : p(c)).includes(!0);
    if (!(c === "type" || h))
      continue;
    const u = r[c];
    if (u)
      if (u.type === 5) {
        l.children || (l.children = []);
        const p = await ri(
          i,
          t,
          u.value,
          n,
          o
        );
        l.children.push(p);
      } else if (typeof u == "object" && !Array.isArray(u)) {
        const { value: p, type: d } = u;
        if (o)
          d === 1 || d === 2 || d === 3 || (l.data[c] = p);
        else {
          const m = typeof p == "number" ? Number(p.toFixed(3)) : p;
          l.data[c] = m;
        }
      } else if (Array.isArray(u))
        for (const p of u) {
          if (p.type !== 5)
            continue;
          l.children || (l.children = []);
          const d = await ri(
            i,
            t,
            p.value,
            n,
            o
          );
          l.children.push(d);
        }
      else if (c === "type") {
        const p = A.IfcCategoryMap[u];
        l.data.Entity = p;
      } else
        l.data[c] = u;
  }
  if (a && a.get(r.expressID)) {
    const c = a.get(r.expressID);
    for (const h of n) {
      const u = [];
      if (typeof h == "string") {
        const p = s._inverseAttributes.indexOf(
          h
        );
        p !== -1 && u.push(p);
      } else {
        const p = s._inverseAttributes.filter(
          (d) => h(d)
        );
        for (const d of p) {
          const m = s._inverseAttributes.indexOf(d);
          u.push(m);
        }
      }
      for (const p of u) {
        const d = c.get(p);
        if (d)
          for (const m of d) {
            const v = await ri(
              i,
              t,
              m,
              n,
              o
            );
            l.children || (l.children = []), l.children.push(v);
          }
      }
    }
  }
  return l;
}
const hd = (i) => {
  const {
    components: t,
    fragmentIdMap: e,
    attributesToInclude: n,
    editable: o,
    tableDefinition: s
  } = i, r = t.get(A.FragmentsManager);
  let a;
  return typeof n == "function" ? a = n(Cr) : a = n, f`<bim-table ${J(async (c) => {
    if (!c)
      return;
    const h = c, u = [], p = [];
    for (const d in e) {
      const m = r.list.get(d);
      if (!(m && m.group))
        continue;
      const v = m.group, w = p.find((C) => C.model === v);
      if (w)
        for (const C of e[d])
          w.expressIDs.add(C);
      else {
        const C = { model: v, expressIDs: new Set(e[d]) };
        p.push(C);
      }
    }
    for (const d of p) {
      const { model: m, expressIDs: v } = d;
      for (const w of v) {
        const C = await ri(
          t,
          m,
          w,
          a,
          o
        );
        u.push(C);
      }
    }
    h.dataTransform = s, h.data = u, h.columns = [{ name: "Entity", width: "minmax(15rem, 1fr)" }];
  })}></bim-table>`;
}, pd = (i) => Y.create(
  hd,
  i
), md = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  entityAttributes: pd
}, Symbol.toStringTag, { value: "Module" }));
let _t;
const fd = (i) => {
  const { components: t, classifications: e } = i, n = t.get(A.Classifier), o = t.get(A.Hider);
  _t || (_t = document.createElement("bim-table"), _t.headersHidden = !0, _t.hiddenColumns = ["system"], _t.columns = ["Name", { name: "Actions", width: "auto" }], _t.dataTransform = {
    Actions: (r, a) => {
      const { system: l, Name: c } = a;
      if (!(typeof l == "string" && typeof c == "string"))
        return r;
      const h = n.list[l];
      if (!(h && h[c]))
        return r;
      const u = h[c], { map: p } = u;
      return f`
          <div>
            <bim-checkbox checked @change=${(m) => {
        const v = m.target;
        o.set(v.value, p);
      }}></bim-checkbox>
          </div>
        `;
    }
  });
  const s = [];
  for (const r of e) {
    const a = typeof r == "string" ? r : r.system, l = typeof r == "string" ? r : r.label, c = n.list[a];
    c && s.push({
      data: { Name: l, system: a },
      children: Object.keys(c).map((h) => ({ data: { Name: h, system: a, Actions: "" } }))
    });
  }
  return _t.data = s, f`${_t}`;
}, bd = (i, t = !0) => {
  const e = Y.create(
    fd,
    i
  );
  if (t) {
    const { components: n } = i, o = n.get(A.FragmentsManager), [, s] = e;
    o.onFragmentsDisposed.add(() => s());
  }
  return e;
}, gd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  classificationTree: bd
}, Symbol.toStringTag, { value: "Module" })), Ar = async (i, t, e) => {
  var a, l, c, h;
  const n = i.get(A.IfcRelationsIndexer), o = {
    data: { Name: (a = e.Name) == null ? void 0 : a.value },
    children: [
      { data: { Name: "Identification", Value: (l = e.Identification) == null ? void 0 : l.value } },
      { data: { Name: "Name", Value: (c = e.Name) == null ? void 0 : c.value } },
      { data: { Name: "Description", Value: (h = e.Description) == null ? void 0 : h.value } }
    ]
  }, s = n.getEntityRelations(
    t,
    e.expressID,
    "IsNestedBy"
  );
  if (!s)
    return o;
  o.children || (o.children = []);
  const r = [];
  o.children.push({ data: { Name: "Tasks" }, children: r });
  for (const u of s) {
    const p = await t.getProperties(u);
    if (!p)
      continue;
    const d = await Ar(i, t, p);
    r.push(d);
  }
  return o;
}, vd = async (i, t, e) => {
  const n = [];
  for (const s of e) {
    const r = await Ar(i, t, s);
    n.push(r);
  }
  return {
    data: { Name: "Tasks" },
    children: n
  };
}, yd = async (i, t) => {
  var n, o;
  const e = { data: { Name: "Classifications" } };
  for (const s of t) {
    const { value: r } = s.ReferencedSource, a = await i.getProperties(r);
    if (!a)
      continue;
    const l = {
      data: {
        Name: a.Name.value
      },
      children: [
        {
          data: {
            Name: "Identification",
            Value: ((n = s.Identification) == null ? void 0 : n.value) || ((o = s.ItemReference) == null ? void 0 : o.value)
          }
        },
        {
          data: {
            Name: "Name",
            Value: s.Name.value
          }
        }
      ]
    };
    e.children || (e.children = []), e.children.push(l);
  }
  return e;
}, _d = async (i, t) => {
  const e = { data: { Name: "Materials" } };
  for (const n of t) {
    if (n.type === q.IFCMATERIALLAYERSETUSAGE) {
      const o = n.ForLayerSet.value, s = await i.getProperties(o);
      if (!s)
        continue;
      for (const r of s.MaterialLayers) {
        const { value: a } = r, l = await i.getProperties(a);
        if (!l)
          continue;
        const c = await i.getProperties(
          l.Material.value
        );
        if (!c)
          continue;
        const h = {
          data: {
            Name: "Layer"
          },
          children: [
            {
              data: {
                Name: "Thickness",
                Value: l.LayerThickness.value
              }
            },
            {
              data: {
                Name: "Material",
                Value: c.Name.value
              }
            }
          ]
        };
        e.children || (e.children = []), e.children.push(h);
      }
    }
    if (n.type === q.IFCMATERIALLIST)
      for (const o of n.Materials) {
        const { value: s } = o, r = await i.getProperties(s);
        if (!r)
          continue;
        const a = {
          data: {
            Name: "Name",
            Value: r.Name.value
          }
        };
        e.children || (e.children = []), e.children.push(a);
      }
    if (n.type === q.IFCMATERIAL) {
      const o = {
        data: {
          Name: "Name",
          Value: n.Name.value
        }
      };
      e.children || (e.children = []), e.children.push(o);
    }
  }
  return e;
}, wd = {
  IFCLENGTHMEASURE: "LENGTHUNIT",
  IFCAREAMEASURE: "AREAUNIT",
  IFCVOLUMEMEASURE: "VOLUMEUNIT",
  IFCPLANEANGLEMEASURE: "PLANEANGLEUNIT"
}, xd = {
  MILLIMETRE: { symbol: "mm", digits: 0 },
  METRE: { symbol: "m", digits: 2 },
  KILOMETRE: { symbol: "km", digits: 2 },
  SQUARE_METRE: { symbol: "m", digits: 2 },
  CUBIC_METRE: { symbol: "m", digits: 2 },
  DEGREE: { symbol: "", digits: 2 },
  RADIAN: { symbol: "rad", digits: 2 },
  GRAM: { symbol: "g", digits: 0 },
  KILOGRAM: { symbol: "kg", digits: 2 },
  MILLISECOND: { symbol: "ms", digits: 0 },
  SECOND: { symbol: "s", digits: 0 }
}, Er = async (i, t) => {
  var o, s, r;
  const e = Object.values(
    await i.getAllPropertiesOfType(q.IFCUNITASSIGNMENT)
  )[0];
  let n;
  for (const a of e.Units) {
    const l = await i.getProperties(a.value);
    if (l && ((o = l.UnitType) == null ? void 0 : o.value) === wd[t]) {
      n = `${((s = l.Prefix) == null ? void 0 : s.value) ?? ""}${((r = l.Name) == null ? void 0 : r.value) ?? ""}`;
      break;
    }
  }
  return n ? xd[n] : null;
}, $d = async (i, t, e) => {
  const { displayUnits: n } = e, o = { data: { Name: "PropertySets" } };
  for (const s of t) {
    const r = {
      data: { Name: s.Name.value }
    };
    if (s.type === q.IFCPROPERTYSET) {
      for (const a of s.HasProperties) {
        const { value: l } = a, c = await i.getProperties(l);
        if (!c)
          continue;
        const h = Object.keys(c).find(
          (m) => m.includes("Value")
        );
        if (!(h && c[h]))
          continue;
        let u = c[h].value, p = "";
        if (n) {
          const { name: m } = c[h], v = await Er(i, m) ?? {};
          p = v.symbol, u = c[h].value, typeof u == "number" && v.digits && (u = u.toFixed(v.digits));
        }
        const d = {
          data: {
            Name: c.Name.value,
            Value: `${u} ${p ?? ""}`
          }
        };
        r.children || (r.children = []), r.children.push(d);
      }
      r.children && (o.children || (o.children = []), o.children.push(r));
    }
  }
  return o;
}, Cd = async (i, t, e) => {
  const { displayUnits: n } = e, o = { data: { Name: "QuantitySets" } };
  for (const s of t) {
    const r = { data: { Name: s.Name.value } };
    if (s.type === q.IFCELEMENTQUANTITY) {
      for (const a of s.Quantities) {
        const { value: l } = a, c = await i.getProperties(l);
        if (!c)
          continue;
        const h = Object.keys(c).find(
          (m) => m.includes("Value")
        );
        if (!(h && c[h]))
          continue;
        let u = c[h].value, p = "";
        if (n) {
          const { name: m } = c[h], v = await Er(i, m) ?? {};
          p = v.symbol, u = c[h].value, typeof u == "number" && v.digits && (u = u.toFixed(v.digits));
        }
        const d = {
          data: {
            Name: c.Name.value,
            Value: `${u} ${p ?? ""}`
          }
        };
        r.children || (r.children = []), r.children.push(d);
      }
      r.children && (o.children || (o.children = []), o.children.push(r));
    }
  }
  return o;
}, Ad = ["OwnerHistory", "ObjectPlacement", "CompositionType"], Sr = async (i, t) => {
  const n = { ...{
    groupName: "Attributes",
    includeClass: !1
  }, ...t }, { groupName: o, includeClass: s } = n, r = { data: { Name: o } };
  s && (r.children || (r.children = []), r.children.push({
    data: {
      Name: "Class",
      Value: A.IfcCategoryMap[i.type]
    }
  }));
  for (const a in i) {
    if (Ad.includes(a))
      continue;
    const l = i[a];
    if (l && typeof l == "object" && !Array.isArray(l)) {
      if (l.type === q.REF)
        continue;
      const c = {
        data: { Name: a, Value: l.value }
      };
      r.children || (r.children = []), r.children.push(c);
    }
  }
  return r;
}, se = (i, ...t) => {
  i.children || (i.children = []), i.children.push(...t);
}, Ed = async (i, t, e, n, o) => {
  const r = i.get(A.IfcRelationsIndexer).getEntityRelations(
    t,
    e,
    "IsDefinedBy"
  );
  if (r) {
    const a = [], l = [];
    for (const u of r) {
      const p = await t.getProperties(u);
      p && (p.type === q.IFCPROPERTYSET && a.push(p), p.type === q.IFCELEMENTQUANTITY && l.push(p));
    }
    const c = await $d(t, a, o);
    c.children && se(n, c);
    const h = await Cd(t, l, o);
    h.children && se(n, h);
  }
}, Sd = async (i, t, e, n) => {
  const s = i.get(A.IfcRelationsIndexer).getEntityRelations(
    t,
    e,
    "HasAssociations"
  );
  if (s) {
    const r = [], a = [];
    for (const h of s) {
      const u = await t.getProperties(h);
      u && (u.type === q.IFCCLASSIFICATIONREFERENCE && r.push(u), (u.type === q.IFCMATERIALLAYERSETUSAGE || u.type === q.IFCMATERIALLAYERSET || u.type === q.IFCMATERIALLAYER || u.type === q.IFCMATERIAL || u.type === q.IFCMATERIALLIST) && a.push(u));
    }
    const l = await yd(
      t,
      r
    );
    l.children && se(n, l);
    const c = await _d(t, a);
    c.children && se(n, c);
  }
}, kd = async (i, t, e, n) => {
  const s = i.get(A.IfcRelationsIndexer).getEntityRelations(
    t,
    e,
    "HasAssignments"
  );
  if (s) {
    const r = [];
    for (const l of s) {
      const c = await t.getProperties(l);
      c && c.type === q.IFCTASK && r.push(c);
    }
    const a = await vd(i, t, r);
    a.children && se(n, a);
  }
}, Td = async (i, t, e, n) => {
  const s = i.get(A.IfcRelationsIndexer).getEntityRelations(
    t,
    e,
    "ContainedInStructure"
  );
  if (s && s[0]) {
    const r = s[0], a = await t.getProperties(r);
    if (a) {
      const l = await Sr(a, {
        groupName: "SpatialContainer"
      });
      se(n, l);
    }
  }
};
let ei = {};
const Od = async (i, t, e) => {
  var a;
  const n = i.get(A.IfcRelationsIndexer), o = i.get(A.FragmentsManager), s = o.getModelIdMap(t);
  Object.keys(t).length === 0 && (ei = {});
  const r = [];
  for (const l in s) {
    const c = o.groups.get(l);
    if (!c)
      continue;
    const h = n.relationMaps[c.uuid];
    if (!h)
      continue;
    l in ei || (ei[l] = /* @__PURE__ */ new Map());
    const u = ei[l], p = s[l];
    for (const d of p) {
      let m = u.get(d);
      if (m) {
        r.push(m);
        continue;
      }
      const v = await c.getProperties(d);
      if (!v)
        continue;
      m = {
        data: {
          Name: (a = v.Name) == null ? void 0 : a.value
        }
      }, r.push(m), u.set(d, m);
      const w = await Sr(v, {
        includeClass: !0
      });
      m.children || (m.children = []), m.children.push(w), h.get(d) && (await Ed(
        i,
        c,
        d,
        m,
        e
      ), await Sd(i, c, d, m), await kd(
        i,
        c,
        d,
        m
      ), await Td(i, c, d, m));
    }
  }
  return r;
}, Id = (i) => {
  const t = {
    emptySelectionWarning: !0,
    ...i
  }, { components: e, fragmentIdMap: n, emptySelectionWarning: o } = t;
  return f`
    <bim-table @cellcreated=${({
    detail: a
  }) => {
    const { cell: l } = a;
    l.column === "Name" && !("Value" in l.rowData) && (l.style.gridColumn = "1 / -1");
  }} ${J(async (a) => {
    if (!a)
      return;
    const l = a;
    l.columns = [{ name: "Name", width: "12rem" }], l.headersHidden = !0, l.loadFunction = () => Od(e, n, i), await l.loadData(!0) && l.dispatchEvent(new Event("datacomputed"));
  })}>
      ${o ? f`
            <bim-label slot="missing-data" style="--bim-icon--c: gold" icon="ic:round-warning">
              Select some elements to display its properties
            </bim-label>
          ` : null}
    </bim-table>
  `;
}, Rd = (i) => Y.create(
  Id,
  i
), Pd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  elementProperties: Rd
}, Symbol.toStringTag, { value: "Module" })), yn = async (i, t, e, n) => {
  var c;
  const o = [], s = i.get(A.IfcRelationsIndexer), r = await t.getProperties(e);
  if (!r)
    return o;
  const { type: a } = r, l = {
    data: {
      Entity: A.IfcCategoryMap[a],
      Name: (c = r.Name) == null ? void 0 : c.value,
      modelID: t.uuid,
      expressID: e
    }
  };
  for (const h of n) {
    const u = s.getEntityRelations(t, e, h);
    if (!u)
      continue;
    l.children || (l.children = []), l.data.relations = JSON.stringify(u);
    const p = {};
    for (const d of u) {
      const m = await yn(
        i,
        t,
        d,
        n
      );
      for (const v of m)
        if (v.data.relations)
          l.children.push(v);
        else {
          const w = t.data.get(d);
          if (!w) {
            l.children.push(v);
            continue;
          }
          const C = w[1][1], x = A.IfcCategoryMap[C];
          x in p || (p[x] = []), v.data.Entity = v.data.Name, delete v.data.Name, p[x].push(v);
        }
    }
    for (const d in p) {
      const m = p[d], v = m.map((C) => C.data.expressID), w = {
        data: {
          Entity: d,
          modelID: t.uuid,
          relations: JSON.stringify(v)
        },
        children: m
      };
      l.children.push(w);
    }
  }
  return o.push(l), o;
}, Nd = async (i, t, e, n) => {
  const o = i.get(A.IfcRelationsIndexer), s = [];
  for (const r of t) {
    let a;
    if (n)
      a = {
        data: {
          Entity: r.name !== "" ? r.name : r.uuid
        },
        children: await yn(
          i,
          r,
          n,
          e
        )
      };
    else {
      const l = o.relationMaps[r.uuid], c = await r.getAllPropertiesOfType(
        q.IFCPROJECT
      );
      if (!(l && c))
        continue;
      const { expressID: h } = Object.values(c)[0];
      a = {
        data: {
          Entity: r.name !== "" ? r.name : r.uuid
        },
        children: await yn(
          i,
          r,
          h,
          e
        )
      };
    }
    s.push(a);
  }
  return s;
};
let mt;
const Md = (i, t) => {
  const e = i.get(A.FragmentsManager), { modelID: n, expressID: o, relations: s } = t.data;
  if (!n)
    return null;
  const r = e.groups.get(n);
  return r ? r.getFragmentMap([
    o,
    ...JSON.parse(s ?? "[]")
  ]) : null;
}, Ld = (i) => {
  const { components: t, models: e, expressID: n } = i, o = i.selectHighlighterName ?? "select", s = i.hoverHighlighterName ?? "hover";
  mt || (mt = document.createElement("bim-table"), mt.hiddenColumns = ["modelID", "expressID", "relations"], mt.columns = ["Entity", "Name"], mt.headersHidden = !0, mt.addEventListener("cellcreated", ({ detail: a }) => {
    const { cell: l } = a;
    l.column === "Entity" && !("Name" in l.rowData) && (l.style.gridColumn = "1 / -1");
  })), mt.addEventListener("rowcreated", (a) => {
    a.stopImmediatePropagation();
    const { row: l } = a.detail, c = t.get(z.Highlighter), h = Md(t, l);
    h && Object.keys(h).length !== 0 && (l.onmouseover = () => {
      s && (l.style.backgroundColor = "var(--bim-ui_bg-contrast-20)", c.highlightByID(
        s,
        h,
        !0,
        !1,
        c.selection[o] ?? {}
      ));
    }, l.onmouseout = () => {
      l.style.backgroundColor = "", c.clear(s);
    }, l.onclick = () => {
      o && c.highlightByID(
        o,
        h,
        !0,
        !0
      );
    });
  });
  const r = i.inverseAttributes ?? [
    "IsDecomposedBy",
    "ContainsElements"
  ];
  return Nd(t, e, r, n).then(
    (a) => mt.data = a
  ), f`${mt}`;
}, Dd = (i, t = !0) => {
  const e = Y.create(
    Ld,
    i
  );
  if (t) {
    const [, n] = e, { components: o } = i, s = o.get(A.FragmentsManager), r = o.get(A.IfcRelationsIndexer), a = () => n({ models: s.groups.values() });
    r.onRelationsIndexed.add(a), s.onFragmentsDisposed.add(a);
  }
  return e;
}, Fd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  relationsTree: Dd
}, Symbol.toStringTag, { value: "Module" })), _e = (i, t) => [...i.get(A.Grids).list.values()].find((o) => o.world === t), zd = (i, t) => f`
    <bim-color-input @input=${(n) => {
  const o = n.target;
  i.color = new N.Color(o.color);
}} color=${t}></bim-color-input>
  `, jd = (i, t) => {
  const { postproduction: e } = i, n = e.n8ao.configuration;
  return f`
    <bim-color-input @input=${(s) => {
    const r = s.target;
    n.color = new N.Color(r.color);
  }} color=${t}></bim-color-input>
  `;
}, Bd = (i, t) => {
  const { color: e, opacity: n } = JSON.parse(t), { postproduction: o } = i, { customEffects: s } = o;
  return f`
    <bim-color-input @input=${(a) => {
    const { color: l, opacity: c } = a.target;
    s.lineColor = new N.Color(l).getHex(), c && (s.opacity = c / 100);
  }} color=${e} opacity=${n * 100}></bim-color-input>
  `;
}, Hd = (i, t) => f`
    <bim-color-input @input=${(n) => {
  const o = n.target, s = new N.Color(o.color);
  i.material.uniforms.uColor.value = s;
}} color=${t}></bim-color-input>
  `, Ud = (i, t) => {
  const { postproduction: e } = i;
  return f`
    <bim-checkbox @change=${(o) => {
    const s = o.target;
    e.setPasses({ ao: s.checked });
  }} .checked=${t}></bim-checkbox>
  `;
}, Vd = (i, t) => {
  const { postproduction: e } = i;
  return f`
    <bim-checkbox @change=${(o) => {
    const s = o.target;
    e.setPasses({ gamma: s.checked });
  }} .checked=${t}></bim-checkbox>
  `;
}, Wd = (i, t) => {
  const { postproduction: e } = i;
  return f`
    <bim-checkbox @change=${(o) => {
    const s = o.target;
    e.setPasses({ custom: s.checked });
  }} .checked=${t}></bim-checkbox>
  `;
}, wt = (i, t, e, n = () => {
}) => f`
    <bim-checkbox .checked="${e}" @change="${(s) => {
  const a = s.target.checked;
  i[t] = a, n(a);
}}"></bim-checkbox> 
  `, F = (i, t, e, n) => {
  const o = {
    slider: !1,
    min: 0,
    max: 100,
    step: 1,
    prefix: null,
    suffix: null,
    onInputSet: () => {
    },
    ...n
  }, { slider: s, min: r, max: a, step: l, suffix: c, prefix: h, onInputSet: u } = o;
  return f`
    <bim-number-input
      .pref=${h}
      .suffix=${c}
      .slider=${s} 
      min=${r} 
      value="${e}" 
      max=${a} 
      step=${l} 
      @change="${(d) => {
    const v = d.target.value;
    i[t] = v, u(v);
  }}"
    ></bim-number-input> 
  `;
}, Gd = (i) => {
  const { components: t } = i, e = t.get(A.Worlds);
  return f`
    <bim-table @cellcreated=${({
    detail: s
  }) => {
    const r = s.cell.parentNode;
    if (!r)
      return;
    const a = r.querySelector(
      "bim-table-cell[column='Name']"
    ), l = r.querySelector(
      "bim-table-cell[column='Value']"
    );
    a && !l && (a.style.gridColumn = "1 / -1");
  }} ${J(async (s) => {
    var l, c, h, u, p;
    if (!s)
      return;
    const r = s;
    r.preserveStructureOnFilter = !0, r.dataTransform = {
      Value: (d, m) => {
        const v = m.World, w = e.list.get(v);
        if (!w)
          return d;
        const { scene: C, camera: x, renderer: g } = w, y = m.Name;
        if (y === "Grid" && m.IsGridConfig && typeof d == "boolean") {
          const $ = _e(t, w);
          return $ ? wt($, "visible", d) : d;
        }
        if (y === "Color" && m.IsGridConfig && typeof d == "string") {
          const $ = _e(t, w);
          return $ ? Hd($, d) : d;
        }
        if (y === "Distance" && m.IsGridConfig && typeof d == "number") {
          const $ = _e(t, w);
          return $ ? F(
            $.material.uniforms.uDistance,
            "value",
            d,
            { slider: !0, min: 300, max: 1e3 }
          ) : d;
        }
        if (y === "Size" && m.IsGridConfig && typeof d == "string") {
          const $ = _e(t, w);
          if (!$)
            return d;
          const { x: _, y: E } = JSON.parse(d), L = F(
            $.material.uniforms.uSize1,
            "value",
            _,
            { slider: !0, suffix: "m", prefix: "A", min: 1, max: 20 }
          ), D = F(
            $.material.uniforms.uSize2,
            "value",
            E,
            { slider: !0, suffix: "m", prefix: "B", min: 1, max: 20 }
          );
          return f`
            <div style="display: flex; gap: 0.25rem; width: 100%; flex-wrap: wrap">${L}${D}</div>
          `;
        }
        if (y === "Near Frustum" && x.three instanceof N.PerspectiveCamera && typeof d == "number") {
          const $ = x.three;
          return F(x.three, "near", d, {
            slider: !0,
            min: 0.1,
            max: 10,
            step: 0.1,
            onInputSet: () => $.updateProjectionMatrix()
          });
        }
        if (y === "Far Frustum" && x.three instanceof N.PerspectiveCamera && typeof d == "number") {
          const $ = x.three;
          return F(x.three, "far", d, {
            slider: !0,
            min: 300,
            max: 2e3,
            step: 10,
            onInputSet: () => $.updateProjectionMatrix()
          });
        }
        if (y === "Field of View" && x.three instanceof N.PerspectiveCamera && typeof d == "number") {
          const $ = x.three;
          return F(x.three, "fov", d, {
            slider: !0,
            min: 10,
            max: 120,
            onInputSet: () => $.updateProjectionMatrix()
          });
        }
        if (y === "Invert Drag" && x.hasCameraControls() && typeof d == "boolean")
          return wt(
            x.controls,
            "dollyDragInverted",
            d
          );
        if (y === "Dolly Speed" && x.hasCameraControls() && typeof d == "number")
          return F(x.controls, "dollySpeed", d, {
            slider: !0,
            min: 0.5,
            max: 3,
            step: 0.1
          });
        if (y === "Truck Speed" && x.hasCameraControls() && typeof d == "number")
          return F(x.controls, "truckSpeed", d, {
            slider: !0,
            min: 0.5,
            max: 6,
            step: 0.1
          });
        if (y === "Smooth Time" && x.hasCameraControls() && typeof d == "number")
          return F(x.controls, "smoothTime", d, {
            slider: !0,
            min: 0.01,
            max: 2,
            step: 0.01
          });
        if (y === "Intensity" && typeof d == "number") {
          if (m.Light && typeof m.Light == "string") {
            const $ = C.three.children.find(
              (_) => _.uuid === m.Light
            );
            return $ && $ instanceof N.Light ? F($, "intensity", d, {
              slider: !0,
              min: 0,
              max: 10,
              step: 0.1
            }) : d;
          }
          if (m.IsAOConfig && g instanceof z.PostproductionRenderer)
            return F(
              g.postproduction.n8ao.configuration,
              "intensity",
              d,
              { slider: !0, max: 16, step: 0.1 }
            );
        }
        if (y === "Color" && typeof d == "string") {
          const $ = m.Light, _ = C.three.children.find(
            (E) => E.uuid === $
          );
          if (_ && _ instanceof N.Light)
            return zd(_, d);
          if (m.IsAOConfig && g instanceof z.PostproductionRenderer)
            return jd(g, d);
        }
        if (y === "Ambient Oclussion" && typeof d == "boolean" && m.IsAOConfig && g instanceof z.PostproductionRenderer)
          return Ud(g, d);
        if (y === "Half Resolution" && m.IsAOConfig && g instanceof z.PostproductionRenderer && typeof d == "boolean")
          return wt(
            g.postproduction.n8ao.configuration,
            "halfRes",
            d
          );
        if (y === "Screen Space Radius" && m.IsAOConfig && g instanceof z.PostproductionRenderer && typeof d == "boolean")
          return wt(
            g.postproduction.n8ao.configuration,
            "screenSpaceRadius",
            d
          );
        if (y === "Radius" && m.IsAOConfig && g instanceof z.PostproductionRenderer && typeof d == "number")
          return F(
            g.postproduction.n8ao.configuration,
            "aoRadius",
            d,
            { slider: !0, max: 2, step: 0.1 }
          );
        if (y === "Denoise Samples" && m.IsAOConfig && g instanceof z.PostproductionRenderer && typeof d == "number")
          return F(
            g.postproduction.n8ao.configuration,
            "denoiseSamples",
            d,
            { slider: !0, min: 1, max: 16 }
          );
        if (y === "Samples" && m.IsAOConfig && g instanceof z.PostproductionRenderer && typeof d == "number")
          return F(
            g.postproduction.n8ao.configuration,
            "aoSamples",
            d,
            { slider: !0, min: 1, max: 16 }
          );
        if (y === "Denoise Radius" && m.IsAOConfig && g instanceof z.PostproductionRenderer && typeof d == "number")
          return F(
            g.postproduction.n8ao.configuration,
            "denoiseRadius",
            d,
            { slider: !0, min: 0, max: 16, step: 0.1 }
          );
        if (y === "Distance Falloff" && m.IsAOConfig && g instanceof z.PostproductionRenderer && typeof d == "number")
          return F(
            g.postproduction.n8ao.configuration,
            "distanceFalloff",
            d,
            { slider: !0, min: 0, max: 4, step: 0.1 }
          );
        if (y === "Directional Light" && m.Light && typeof m.Light == "string" && typeof d == "boolean") {
          const $ = C.three.children.find(
            (_) => _.uuid === m.Light
          );
          return $ && $ instanceof N.Light ? wt($, "visible", d) : d;
        }
        if (y === "Ambient Light" && m.Light && typeof m.Light == "string" && typeof d == "boolean") {
          const $ = C.three.children.find(
            (_) => _.uuid === m.Light
          );
          return $ && $ instanceof N.Light ? wt($, "visible", d) : d;
        }
        if (y === "Position" && m.Light && typeof m.Light == "string" && typeof d == "string") {
          const $ = C.three.children.find(
            (S) => S.uuid === m.Light
          );
          if (!($ && $ instanceof N.Light))
            return d;
          const { x: _, y: E, z: L } = JSON.parse(d), D = F($.position, "x", _, {
            slider: !0,
            prefix: "X",
            suffix: "m",
            min: -50,
            max: 50
          }), T = F($.position, "y", E, {
            slider: !0,
            prefix: "Y",
            suffix: "m",
            min: -50,
            max: 50
          }), M = F($.position, "z", L, {
            slider: !0,
            prefix: "Z",
            suffix: "m",
            min: -50,
            max: 50
          });
          return f`
            <div style="display: flex; gap: 0.25rem; width: 100%; flex-wrap: wrap">${D}${T}${M}</div>
          `;
        }
        return y === "Custom Effects" && m.IsCEConfig && g instanceof z.PostproductionRenderer && typeof d == "boolean" ? Wd(g, d) : y === "Color" && m.IsOutlineConfig && g instanceof z.PostproductionRenderer && typeof d == "string" ? Bd(g, d) : y === "Tolerance" && m.IsOutlineConfig && g instanceof z.PostproductionRenderer && typeof d == "number" ? F(
          g.postproduction.customEffects,
          "tolerance",
          d,
          { slider: !0, min: 0, max: 6, step: 0.01 }
        ) : y === "Outline" && m.IsOutlineConfig && g instanceof z.PostproductionRenderer && typeof d == "boolean" ? wt(
          g.postproduction.customEffects,
          "outlineEnabled",
          d
        ) : y === "Gloss" && m.IsGlossConfig && g instanceof z.PostproductionRenderer && typeof d == "boolean" ? wt(
          g.postproduction.customEffects,
          "glossEnabled",
          d
        ) : y === "Min" && m.IsGlossConfig && g instanceof z.PostproductionRenderer && typeof d == "number" ? F(
          g.postproduction.customEffects,
          "minGloss",
          d,
          { slider: !0, min: -0.5, max: 0.5, step: 0.01 }
        ) : y === "Max" && m.IsGlossConfig && g instanceof z.PostproductionRenderer && typeof d == "number" ? F(
          g.postproduction.customEffects,
          "maxGloss",
          d,
          { slider: !0, min: -0.5, max: 0.5, step: 0.01 }
        ) : y === "Exponent" && m.IsGlossConfig && g instanceof z.PostproductionRenderer && typeof d == "number" ? F(
          g.postproduction.customEffects,
          "glossExponent",
          d,
          { slider: !0, min: 0, max: 5, step: 0.01 }
        ) : y === "Gamma Correction" && m.IsGammaConfig && g instanceof z.PostproductionRenderer && typeof d == "boolean" ? Vd(g, d) : d;
      }
    };
    const a = [];
    for (const [, d] of e.list) {
      const { scene: m, camera: v, renderer: w } = d, C = _e(t, d), x = {
        data: {
          Name: d instanceof A.SimpleWorld && d.name || d.uuid
        },
        children: []
      };
      if (m) {
        const g = {
          data: {
            Name: "Scene"
          }
        };
        if (C) {
          const E = `#${C.material.uniforms.uColor.value.getHexString()}`, L = JSON.stringify({
            x: C.material.uniforms.uSize1.value,
            y: C.material.uniforms.uSize2.value
          }), D = {
            data: {
              Name: "Grid",
              Value: C.three.visible,
              World: d.uuid,
              IsGridConfig: !0
            },
            children: [
              {
                data: {
                  Name: "Color",
                  Value: E,
                  World: d.uuid,
                  IsGridConfig: !0
                }
              },
              {
                data: {
                  Name: "Size",
                  Value: L,
                  World: d.uuid,
                  IsGridConfig: !0
                }
              },
              {
                data: {
                  Name: "Distance",
                  Value: C.material.uniforms.uDistance.value,
                  World: d.uuid,
                  IsGridConfig: !0
                }
              }
            ]
          };
          g.children || (g.children = []), g.children.push(D);
        }
        const y = m.three.children.filter(
          (_) => _ instanceof N.DirectionalLight
        );
        for (const _ of y) {
          const E = {
            data: {
              Name: "Directional Light",
              Value: _.visible,
              World: d.uuid,
              Light: _.uuid
            },
            children: [
              {
                data: {
                  Name: "Position",
                  Value: JSON.stringify(_.position),
                  World: d.uuid,
                  Light: _.uuid
                }
              },
              {
                data: {
                  Name: "Intensity",
                  Value: _.intensity,
                  World: d.uuid,
                  Light: _.uuid
                }
              },
              {
                data: {
                  Name: "Color",
                  Value: `#${_.color.getHexString()}`,
                  World: d.uuid,
                  Light: _.uuid
                }
              }
            ]
          };
          g.children || (g.children = []), g.children.push(E);
        }
        const $ = m.three.children.filter(
          (_) => _ instanceof N.AmbientLight
        );
        for (const _ of $) {
          const E = {
            data: {
              Name: "Ambient Light",
              Value: _.visible,
              World: d.uuid,
              Light: _.uuid
            },
            children: [
              {
                data: {
                  Name: "Intensity",
                  Value: _.intensity,
                  World: d.uuid,
                  Light: _.uuid
                }
              },
              {
                data: {
                  Name: "Color",
                  Value: `#${_.color.getHexString()}`,
                  World: d.uuid,
                  Light: _.uuid
                }
              }
            ]
          };
          g.children || (g.children = []), g.children.push(E);
        }
        g.children && ((l = g.children) == null ? void 0 : l.length) > 0 && ((c = x.children) == null || c.push(g));
      }
      if (v.three instanceof N.PerspectiveCamera) {
        const g = {
          data: {
            Name: "Perspective Camera"
          },
          children: [
            {
              data: {
                Name: "Near Frustum",
                Value: v.three.near,
                World: d.uuid
              }
            },
            {
              data: {
                Name: "Far Frustum",
                Value: v.three.far,
                World: d.uuid
              }
            },
            {
              data: {
                Name: "Field of View",
                Value: v.three.fov,
                World: d.uuid
              }
            }
          ]
        };
        if (v.hasCameraControls()) {
          const { controls: y } = v, $ = {
            dollyDragInverted: "Invert Drag",
            dollySpeed: "Dolly Speed",
            truckSpeed: "Truck Speed",
            smoothTime: "Smooth Time"
          };
          for (const _ in $) {
            const E = y[_];
            E != null && ((h = g.children) == null || h.push({
              data: {
                Name: $[_],
                Value: E,
                World: d.uuid
              }
            }));
          }
        }
        (u = x.children) == null || u.push(g);
      }
      if (w instanceof z.PostproductionRenderer) {
        const { postproduction: g } = w, y = g.n8ao.configuration, $ = {
          data: {
            Name: "Renderer"
          },
          children: [
            {
              data: {
                Name: "Gamma Correction",
                Value: g.settings.gamma ?? !1,
                World: d.uuid,
                IsGammaConfig: !0
              }
            },
            {
              data: {
                Name: "Ambient Oclussion",
                Value: g.settings.ao ?? !1,
                World: d.uuid,
                IsAOConfig: !0
              },
              children: [
                {
                  data: {
                    Name: "Samples",
                    Value: y.aoSamples,
                    World: d.uuid,
                    IsAOConfig: !0
                  }
                },
                {
                  data: {
                    Name: "Color",
                    Value: `#${y.color.getHexString()}`,
                    World: d.uuid,
                    IsAOConfig: !0
                  }
                },
                {
                  data: {
                    Name: "Half Resolution",
                    Value: y.halfRes,
                    World: d.uuid,
                    IsAOConfig: !0
                  }
                },
                {
                  data: {
                    Name: "Screen Space Radius",
                    Value: y.screenSpaceRadius,
                    World: d.uuid,
                    IsAOConfig: !0
                  }
                },
                {
                  data: {
                    Name: "Radius",
                    Value: y.aoRadius,
                    World: d.uuid,
                    IsAOConfig: !0
                  }
                },
                {
                  data: {
                    Name: "Intensity",
                    Value: y.intensity,
                    World: d.uuid,
                    IsAOConfig: !0
                  }
                },
                {
                  data: {
                    Name: "Distance Falloff",
                    Value: y.distanceFalloff,
                    World: d.uuid,
                    IsAOConfig: !0
                  }
                },
                {
                  data: {
                    Name: "Denoise Samples",
                    Value: y.denoiseSamples,
                    World: d.uuid,
                    IsAOConfig: !0
                  }
                },
                {
                  data: {
                    Name: "Denoise Radius",
                    Value: y.denoiseRadius,
                    World: d.uuid,
                    IsAOConfig: !0
                  }
                }
              ]
            },
            {
              data: {
                Name: "Custom Effects",
                Value: g.settings.custom ?? !1,
                World: d.uuid,
                IsCEConfig: !0
              },
              children: [
                {
                  data: {
                    Name: "Gloss",
                    Value: g.customEffects.glossEnabled,
                    World: d.uuid,
                    IsGlossConfig: !0
                  },
                  children: [
                    {
                      data: {
                        Name: "Min",
                        Value: g.customEffects.minGloss,
                        World: d.uuid,
                        IsGlossConfig: !0
                      }
                    },
                    {
                      data: {
                        Name: "Max",
                        Value: g.customEffects.maxGloss,
                        World: d.uuid,
                        IsGlossConfig: !0
                      }
                    },
                    {
                      data: {
                        Name: "Exponent",
                        Value: g.customEffects.glossExponent,
                        World: d.uuid,
                        IsGlossConfig: !0
                      }
                    }
                  ]
                },
                {
                  data: {
                    Name: "Outline",
                    Value: g.customEffects.outlineEnabled,
                    World: d.uuid,
                    IsOutlineConfig: !0
                  },
                  children: [
                    {
                      data: {
                        Name: "Color",
                        get Value() {
                          const _ = new N.Color(
                            g.customEffects.lineColor
                          ), E = g.customEffects.opacity;
                          return JSON.stringify({
                            color: `#${_.getHexString()}`,
                            opacity: E
                          });
                        },
                        World: d.uuid,
                        IsOutlineConfig: !0
                      }
                    },
                    {
                      data: {
                        Name: "Tolerance",
                        Value: g.customEffects.tolerance,
                        World: d.uuid,
                        IsOutlineConfig: !0
                      }
                    }
                  ]
                }
              ]
            }
          ]
        };
        (p = x.children) == null || p.push($);
      }
      a.push(x);
    }
    r.columns = [{ name: "Name", width: "11rem" }], r.hiddenColumns = [
      "World",
      "Light",
      "IsAOConfig",
      "IsCEConfig",
      "IsGlossConfig",
      "IsOutlineConfig",
      "IsGammaConfig",
      "IsGridConfig"
    ], r.data = a;
  })} headers-hidden expanded>
     <bim-label slot="missing-data" style="--bim-icon--c: gold" icon="ic:round-warning">
        No worlds to configure
      </bim-label>
    </bim-table>
  `;
}, qd = (i, t = !0) => {
  const e = Y.create(
    Gd,
    i
  );
  if (t) {
    const [, n] = e, { components: o } = i;
    o.get(A.Worlds).list.onItemDeleted.add(() => n());
  }
  return e;
}, Yd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  worldsConfiguration: qd
}, Symbol.toStringTag, { value: "Module" })), mh = {
  ...ud,
  ...md,
  ...gd,
  ...Pd,
  ...Fd,
  ...Yd,
  ...Jc,
  ...id,
  ...Kc
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Se = globalThis, wi = Se.trustedTypes, Mo = wi ? wi.createPolicy("lit-html", { createHTML: (i) => i }) : void 0, kr = "$lit$", $t = `lit$${Math.random().toFixed(9).slice(2)}$`, Tr = "?" + $t, Xd = `<${Tr}>`, Vt = document, De = () => Vt.createComment(""), Fe = (i) => i === null || typeof i != "object" && typeof i != "function", Fn = Array.isArray, Jd = (i) => Fn(i) || typeof (i == null ? void 0 : i[Symbol.iterator]) == "function", Ki = `[ 	
\f\r]`, we = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, Lo = /-->/g, Do = />/g, Lt = RegExp(`>|${Ki}(?:([^\\s"'>=/]+)(${Ki}*=${Ki}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), Fo = /'/g, zo = /"/g, Or = /^(?:script|style|textarea|title)$/i, Qd = (i) => (t, ...e) => ({ _$litType$: i, strings: t, values: e }), zn = Qd(1), re = Symbol.for("lit-noChange"), H = Symbol.for("lit-nothing"), jo = /* @__PURE__ */ new WeakMap(), Ft = Vt.createTreeWalker(Vt, 129);
function Ir(i, t) {
  if (!Fn(i) || !i.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return Mo !== void 0 ? Mo.createHTML(t) : t;
}
const Kd = (i, t) => {
  const e = i.length - 1, n = [];
  let o, s = t === 2 ? "<svg>" : t === 3 ? "<math>" : "", r = we;
  for (let a = 0; a < e; a++) {
    const l = i[a];
    let c, h, u = -1, p = 0;
    for (; p < l.length && (r.lastIndex = p, h = r.exec(l), h !== null); )
      p = r.lastIndex, r === we ? h[1] === "!--" ? r = Lo : h[1] !== void 0 ? r = Do : h[2] !== void 0 ? (Or.test(h[2]) && (o = RegExp("</" + h[2], "g")), r = Lt) : h[3] !== void 0 && (r = Lt) : r === Lt ? h[0] === ">" ? (r = o ?? we, u = -1) : h[1] === void 0 ? u = -2 : (u = r.lastIndex - h[2].length, c = h[1], r = h[3] === void 0 ? Lt : h[3] === '"' ? zo : Fo) : r === zo || r === Fo ? r = Lt : r === Lo || r === Do ? r = we : (r = Lt, o = void 0);
    const d = r === Lt && i[a + 1].startsWith("/>") ? " " : "";
    s += r === we ? l + Xd : u >= 0 ? (n.push(c), l.slice(0, u) + kr + l.slice(u) + $t + d) : l + $t + (u === -2 ? a : d);
  }
  return [Ir(i, s + (i[e] || "<?>") + (t === 2 ? "</svg>" : t === 3 ? "</math>" : "")), n];
};
class ze {
  constructor({ strings: t, _$litType$: e }, n) {
    let o;
    this.parts = [];
    let s = 0, r = 0;
    const a = t.length - 1, l = this.parts, [c, h] = Kd(t, e);
    if (this.el = ze.createElement(c, n), Ft.currentNode = this.el.content, e === 2 || e === 3) {
      const u = this.el.content.firstChild;
      u.replaceWith(...u.childNodes);
    }
    for (; (o = Ft.nextNode()) !== null && l.length < a; ) {
      if (o.nodeType === 1) {
        if (o.hasAttributes())
          for (const u of o.getAttributeNames())
            if (u.endsWith(kr)) {
              const p = h[r++], d = o.getAttribute(u).split($t), m = /([.?@])?(.*)/.exec(p);
              l.push({ type: 1, index: s, name: m[2], strings: d, ctor: m[1] === "." ? tu : m[1] === "?" ? eu : m[1] === "@" ? iu : Di }), o.removeAttribute(u);
            } else
              u.startsWith($t) && (l.push({ type: 6, index: s }), o.removeAttribute(u));
        if (Or.test(o.tagName)) {
          const u = o.textContent.split($t), p = u.length - 1;
          if (p > 0) {
            o.textContent = wi ? wi.emptyScript : "";
            for (let d = 0; d < p; d++)
              o.append(u[d], De()), Ft.nextNode(), l.push({ type: 2, index: ++s });
            o.append(u[p], De());
          }
        }
      } else if (o.nodeType === 8)
        if (o.data === Tr)
          l.push({ type: 2, index: s });
        else {
          let u = -1;
          for (; (u = o.data.indexOf($t, u + 1)) !== -1; )
            l.push({ type: 7, index: s }), u += $t.length - 1;
        }
      s++;
    }
  }
  static createElement(t, e) {
    const n = Vt.createElement("template");
    return n.innerHTML = t, n;
  }
}
function ae(i, t, e = i, n) {
  var r, a;
  if (t === re)
    return t;
  let o = n !== void 0 ? (r = e.o) == null ? void 0 : r[n] : e.l;
  const s = Fe(t) ? void 0 : t._$litDirective$;
  return (o == null ? void 0 : o.constructor) !== s && ((a = o == null ? void 0 : o._$AO) == null || a.call(o, !1), s === void 0 ? o = void 0 : (o = new s(i), o._$AT(i, e, n)), n !== void 0 ? (e.o ?? (e.o = []))[n] = o : e.l = o), o !== void 0 && (t = ae(i, o._$AS(i, t.values), o, n)), t;
}
class Zd {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    const { el: { content: e }, parts: n } = this._$AD, o = ((t == null ? void 0 : t.creationScope) ?? Vt).importNode(e, !0);
    Ft.currentNode = o;
    let s = Ft.nextNode(), r = 0, a = 0, l = n[0];
    for (; l !== void 0; ) {
      if (r === l.index) {
        let c;
        l.type === 2 ? c = new Qe(s, s.nextSibling, this, t) : l.type === 1 ? c = new l.ctor(s, l.name, l.strings, this, t) : l.type === 6 && (c = new nu(s, this, t)), this._$AV.push(c), l = n[++a];
      }
      r !== (l == null ? void 0 : l.index) && (s = Ft.nextNode(), r++);
    }
    return Ft.currentNode = Vt, o;
  }
  p(t) {
    let e = 0;
    for (const n of this._$AV)
      n !== void 0 && (n.strings !== void 0 ? (n._$AI(t, n, e), e += n.strings.length - 2) : n._$AI(t[e])), e++;
  }
}
class Qe {
  get _$AU() {
    var t;
    return ((t = this._$AM) == null ? void 0 : t._$AU) ?? this.v;
  }
  constructor(t, e, n, o) {
    this.type = 2, this._$AH = H, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = n, this.options = o, this.v = (o == null ? void 0 : o.isConnected) ?? !0;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = ae(this, t, e), Fe(t) ? t === H || t == null || t === "" ? (this._$AH !== H && this._$AR(), this._$AH = H) : t !== this._$AH && t !== re && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : Jd(t) ? this.k(t) : this._(t);
  }
  O(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.O(t));
  }
  _(t) {
    this._$AH !== H && Fe(this._$AH) ? this._$AA.nextSibling.data = t : this.T(Vt.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    var s;
    const { values: e, _$litType$: n } = t, o = typeof n == "number" ? this._$AC(t) : (n.el === void 0 && (n.el = ze.createElement(Ir(n.h, n.h[0]), this.options)), n);
    if (((s = this._$AH) == null ? void 0 : s._$AD) === o)
      this._$AH.p(e);
    else {
      const r = new Zd(o, this), a = r.u(this.options);
      r.p(e), this.T(a), this._$AH = r;
    }
  }
  _$AC(t) {
    let e = jo.get(t.strings);
    return e === void 0 && jo.set(t.strings, e = new ze(t)), e;
  }
  k(t) {
    Fn(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let n, o = 0;
    for (const s of t)
      o === e.length ? e.push(n = new Qe(this.O(De()), this.O(De()), this, this.options)) : n = e[o], n._$AI(s), o++;
    o < e.length && (this._$AR(n && n._$AB.nextSibling, o), e.length = o);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    var n;
    for ((n = this._$AP) == null ? void 0 : n.call(this, !1, !0, e); t && t !== this._$AB; ) {
      const o = t.nextSibling;
      t.remove(), t = o;
    }
  }
  setConnected(t) {
    var e;
    this._$AM === void 0 && (this.v = t, (e = this._$AP) == null || e.call(this, t));
  }
}
class Di {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, e, n, o, s) {
    this.type = 1, this._$AH = H, this._$AN = void 0, this.element = t, this.name = e, this._$AM = o, this.options = s, n.length > 2 || n[0] !== "" || n[1] !== "" ? (this._$AH = Array(n.length - 1).fill(new String()), this.strings = n) : this._$AH = H;
  }
  _$AI(t, e = this, n, o) {
    const s = this.strings;
    let r = !1;
    if (s === void 0)
      t = ae(this, t, e, 0), r = !Fe(t) || t !== this._$AH && t !== re, r && (this._$AH = t);
    else {
      const a = t;
      let l, c;
      for (t = s[0], l = 0; l < s.length - 1; l++)
        c = ae(this, a[n + l], e, l), c === re && (c = this._$AH[l]), r || (r = !Fe(c) || c !== this._$AH[l]), c === H ? t = H : t !== H && (t += (c ?? "") + s[l + 1]), this._$AH[l] = c;
    }
    r && !o && this.j(t);
  }
  j(t) {
    t === H ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
}
class tu extends Di {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === H ? void 0 : t;
  }
}
class eu extends Di {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== H);
  }
}
class iu extends Di {
  constructor(t, e, n, o, s) {
    super(t, e, n, o, s), this.type = 5;
  }
  _$AI(t, e = this) {
    if ((t = ae(this, t, e, 0) ?? H) === re)
      return;
    const n = this._$AH, o = t === H && n !== H || t.capture !== n.capture || t.once !== n.once || t.passive !== n.passive, s = t !== H && (n === H || o);
    o && this.element.removeEventListener(this.name, this, n), s && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var e;
    typeof this._$AH == "function" ? this._$AH.call(((e = this.options) == null ? void 0 : e.host) ?? this.element, t) : this._$AH.handleEvent(t);
  }
}
class nu {
  constructor(t, e, n) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = n;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    ae(this, t);
  }
}
const Zi = Se.litHtmlPolyfillSupport;
Zi == null || Zi(ze, Qe), (Se.litHtmlVersions ?? (Se.litHtmlVersions = [])).push("3.2.0");
const ou = (i, t, e) => {
  const n = (e == null ? void 0 : e.renderBefore) ?? t;
  let o = n._$litPart$;
  if (o === void 0) {
    const s = (e == null ? void 0 : e.renderBefore) ?? null;
    n._$litPart$ = o = new Qe(t.insertBefore(De(), s), s, void 0, e ?? {});
  }
  return o._$AI(i), o;
};
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const su = (i) => i.strings === void 0;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ru = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 }, au = (i) => (...t) => ({ _$litDirective$: i, values: t });
let lu = class {
  constructor(t) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, e, n) {
    this.t = t, this._$AM = e, this.i = n;
  }
  _$AS(t, e) {
    return this.update(t, e);
  }
  update(t, e) {
    return this.render(...e);
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ke = (i, t) => {
  var n;
  const e = i._$AN;
  if (e === void 0)
    return !1;
  for (const o of e)
    (n = o._$AO) == null || n.call(o, t, !1), ke(o, t);
  return !0;
}, xi = (i) => {
  let t, e;
  do {
    if ((t = i._$AM) === void 0)
      break;
    e = t._$AN, e.delete(i), i = t;
  } while ((e == null ? void 0 : e.size) === 0);
}, Rr = (i) => {
  for (let t; t = i._$AM; i = t) {
    let e = t._$AN;
    if (e === void 0)
      t._$AN = e = /* @__PURE__ */ new Set();
    else if (e.has(i))
      break;
    e.add(i), uu(t);
  }
};
function cu(i) {
  this._$AN !== void 0 ? (xi(this), this._$AM = i, Rr(this)) : this._$AM = i;
}
function du(i, t = !1, e = 0) {
  const n = this._$AH, o = this._$AN;
  if (o !== void 0 && o.size !== 0)
    if (t)
      if (Array.isArray(n))
        for (let s = e; s < n.length; s++)
          ke(n[s], !1), xi(n[s]);
      else
        n != null && (ke(n, !1), xi(n));
    else
      ke(this, i);
}
const uu = (i) => {
  i.type == ru.CHILD && (i._$AP ?? (i._$AP = du), i._$AQ ?? (i._$AQ = cu));
};
class hu extends lu {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(t, e, n) {
    super._$AT(t, e, n), Rr(this), this.isConnected = t._$AU;
  }
  _$AO(t, e = !0) {
    var n, o;
    t !== this.isConnected && (this.isConnected = t, t ? (n = this.reconnected) == null || n.call(this) : (o = this.disconnected) == null || o.call(this)), e && (ke(this, t), xi(this));
  }
  setValue(t) {
    if (su(this.t))
      this.t._$AI(t, this);
    else {
      const e = [...this.t._$AH];
      e[this.i] = t, this.t._$AI(e, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const _n = () => new pu();
class pu {
}
const tn = /* @__PURE__ */ new WeakMap(), mu = au(class extends hu {
  render(i) {
    return H;
  }
  update(i, [t]) {
    var n;
    const e = t !== this.Y;
    return e && this.Y !== void 0 && this.rt(void 0), (e || this.lt !== this.ct) && (this.Y = t, this.ht = (n = i.options) == null ? void 0 : n.host, this.rt(this.ct = i.element)), H;
  }
  rt(i) {
    if (this.isConnected || (i = void 0), typeof this.Y == "function") {
      const t = this.ht ?? globalThis;
      let e = tn.get(t);
      e === void 0 && (e = /* @__PURE__ */ new WeakMap(), tn.set(t, e)), e.get(this.Y) !== void 0 && this.Y.call(this.ht, void 0), e.set(this.Y, i), i !== void 0 && this.Y.call(this.ht, i);
    } else
      this.Y.value = i;
  }
  get lt() {
    var i, t;
    return typeof this.Y == "function" ? (i = tn.get(this.ht ?? globalThis)) == null ? void 0 : i.get(this.Y) : (t = this.Y) == null ? void 0 : t.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
}), fu = (i) => {
  const {
    components: t,
    topic: e,
    value: n,
    onCancel: o,
    onSubmit: s,
    styles: r
  } = i, a = s ?? (() => {
  }), l = t.get(A.BCFTopics), c = (n == null ? void 0 : n.title) ?? (e == null ? void 0 : e.title) ?? A.Topic.default.title, h = (n == null ? void 0 : n.status) ?? (e == null ? void 0 : e.status) ?? A.Topic.default.status, u = (n == null ? void 0 : n.type) ?? (e == null ? void 0 : e.type) ?? A.Topic.default.type, p = (n == null ? void 0 : n.priority) ?? (e == null ? void 0 : e.priority) ?? A.Topic.default.priority, d = (n == null ? void 0 : n.assignedTo) ?? (e == null ? void 0 : e.assignedTo) ?? A.Topic.default.assignedTo, m = (n == null ? void 0 : n.labels) ?? (e == null ? void 0 : e.labels) ?? A.Topic.default.labels, v = (n == null ? void 0 : n.stage) ?? (e == null ? void 0 : e.stage) ?? A.Topic.default.stage, w = (n == null ? void 0 : n.description) ?? (e == null ? void 0 : e.description) ?? A.Topic.default.description, C = e != null && e.dueDate ? e.dueDate.toISOString().split("T")[0] : null, x = /* @__PURE__ */ new Set([...l.config.statuses]);
  h && x.add(h);
  const g = /* @__PURE__ */ new Set([...l.config.types]);
  u && g.add(u);
  const y = /* @__PURE__ */ new Set([...l.config.priorities]);
  p && y.add(p);
  const $ = /* @__PURE__ */ new Set([...l.config.users]);
  d && $.add(d);
  const _ = /* @__PURE__ */ new Set([...l.config.labels]);
  if (m)
    for (const S of m)
      _.add(S);
  const E = /* @__PURE__ */ new Set([...l.config.stages]);
  v && E.add(v);
  const L = _n(), D = async () => {
    const { value: S } = L;
    if (!S)
      return;
    Object.values(S.valueTransform).length === 0 && (S.valueTransform = {
      dueDate: (k) => {
        if (typeof k == "string" && k.trim() !== "")
          return new Date(k);
      },
      status: (k) => {
        if (Array.isArray(k) && k.length !== 0)
          return k[0];
      },
      type: (k) => {
        if (Array.isArray(k) && k.length !== 0)
          return k[0];
      },
      priority: (k) => {
        if (Array.isArray(k) && k.length !== 0)
          return k[0];
      },
      assignedTo: (k) => {
        if (Array.isArray(k) && k.length !== 0)
          return k[0];
      }
    });
    const P = S.value;
    if (e)
      e.set(P), await a(e);
    else {
      const k = l.create(P);
      await a(k);
    }
  }, T = _n(), M = (S) => {
    const { value: P } = T;
    if (!P)
      return;
    const k = S.target;
    P.disabled = k.value.trim() === "";
  };
  return f`
    <bim-panel style="border-radius: var(--bim-ui_size-base); outline: 2px solid var(--bim-ui_bg-contrast-20); width: 22rem;">
      <bim-panel-section ${J(L)} fixed label="New Topic" name="topic">
        <div style="display: flex; gap: 0.375rem">
          <bim-text-input @input=${M} vertical label="Title" name="title" .value=${c}></bim-text-input>
          ${e ? f`
              <bim-dropdown vertical label="Status" name="status" required>
                ${[...x].map((S) => f`<bim-option label=${S} .checked=${h === S}></bim-option>`)}
              </bim-dropdown>` : f``}
        </div>
        <div style="display: flex; gap: 0.375rem">
          <bim-dropdown vertical label="Type" name="type" required>
            ${[...g].map((S) => f`<bim-option label=${S} .checked=${u === S}></bim-option>`)}
          </bim-dropdown>
          <bim-dropdown vertical label="Priority" name="priority">
            ${[...y].map((S) => f`<bim-option label=${S} .checked=${p === S}></bim-option>`)}
          </bim-dropdown>
        </div>
        <div style="display: flex; gap: 0.375rem">
          <bim-dropdown vertical label="Labels" name="labels" multiple>
            ${[..._].map((S) => f`<bim-option label=${S} .checked=${m ? [...m].includes(S) : !1}></bim-option>`)}
          </bim-dropdown>
          <bim-dropdown vertical label="Assignee" name="assignedTo">
            ${[...$].map((S) => {
    const P = r != null && r.users ? r.users[S] : null, k = P ? P.name : S, tt = P == null ? void 0 : P.picture;
    return f`<bim-option label=${k} value=${S} .img=${tt} .checked=${d === S}></bim-option>`;
  })}
          </bim-dropdown>
        </div>
        <div style="display: flex; gap: 0.375rem">
          <bim-text-input vertical type="date" label="Due Date" name="dueDate" .value=${C}></bim-text-input> 
          <bim-dropdown vertical label="Stage" name="stage">
            ${[...E].map((S) => f`<bim-option label=${S} .checked=${v === S}></bim-option>`)}
          </bim-dropdown>
        </div>
        <bim-text-input vertical label="Description" name="description" type="area" .value=${w ?? null}></bim-text-input>
        <div style="justify-content: right; display: flex; gap: 0.375rem">
          <style>
            #A7T9K {
              background-color: transparent;
            }

            #A7T9K:hover {
              --bim-label--c: #FF5252;
            }

            #W3F2J:hover {
              background-color: #329936;
            }
          </style>
          <bim-button @click=${o} style="flex: 0" id="A7T9K" label="Cancel"></bim-button>
          <bim-button ${J(T)} @click=${D} style="flex: 0" id="W3F2J" label=${e ? "Update Topic" : "Add Topic"} icon=${e ? "tabler:refresh" : "mi:add"}></bim-button>
        </div>
      </bim-panel-section>
    </bim-panel>
  `;
}, bu = (i) => Y.create(
  fu,
  i
), gu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createTopic: bu
}, Symbol.toStringTag, { value: "Module" })), bh = {
  ...gu
};
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ai = globalThis, jn = ai.ShadowRoot && (ai.ShadyCSS === void 0 || ai.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, Bn = Symbol(), Bo = /* @__PURE__ */ new WeakMap();
let Pr = class {
  constructor(t, e, n) {
    if (this._$cssResult$ = !0, n !== Bn)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const e = this.t;
    if (jn && t === void 0) {
      const n = e !== void 0 && e.length === 1;
      n && (t = Bo.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), n && Bo.set(e, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
const vu = (i) => new Pr(typeof i == "string" ? i : i + "", void 0, Bn), Hn = (i, ...t) => {
  const e = i.length === 1 ? i[0] : t.reduce((n, o, s) => n + ((r) => {
    if (r._$cssResult$ === !0)
      return r.cssText;
    if (typeof r == "number")
      return r;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + r + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(o) + i[s + 1], i[0]);
  return new Pr(e, i, Bn);
}, yu = (i, t) => {
  if (jn)
    i.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet);
  else
    for (const e of t) {
      const n = document.createElement("style"), o = ai.litNonce;
      o !== void 0 && n.setAttribute("nonce", o), n.textContent = e.cssText, i.appendChild(n);
    }
}, Ho = jn ? (i) => i : (i) => i instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const n of t.cssRules)
    e += n.cssText;
  return vu(e);
})(i) : i;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: _u, defineProperty: wu, getOwnPropertyDescriptor: xu, getOwnPropertyNames: $u, getOwnPropertySymbols: Cu, getPrototypeOf: Au } = Object, Ct = globalThis, Uo = Ct.trustedTypes, Eu = Uo ? Uo.emptyScript : "", en = Ct.reactiveElementPolyfillSupport, Te = (i, t) => i, $i = { toAttribute(i, t) {
  switch (t) {
    case Boolean:
      i = i ? Eu : null;
      break;
    case Object:
    case Array:
      i = i == null ? i : JSON.stringify(i);
  }
  return i;
}, fromAttribute(i, t) {
  let e = i;
  switch (t) {
    case Boolean:
      e = i !== null;
      break;
    case Number:
      e = i === null ? null : Number(i);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(i);
      } catch {
        e = null;
      }
  }
  return e;
} }, Un = (i, t) => !_u(i, t), Vo = { attribute: !0, type: String, converter: $i, reflect: !1, hasChanged: Un };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), Ct.litPropertyMetadata ?? (Ct.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
class Jt extends HTMLElement {
  static addInitializer(t) {
    this._$Ei(), (this.l ?? (this.l = [])).push(t);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t, e = Vo) {
    if (e.state && (e.attribute = !1), this._$Ei(), this.elementProperties.set(t, e), !e.noAccessor) {
      const n = Symbol(), o = this.getPropertyDescriptor(t, n, e);
      o !== void 0 && wu(this.prototype, t, o);
    }
  }
  static getPropertyDescriptor(t, e, n) {
    const { get: o, set: s } = xu(this.prototype, t) ?? { get() {
      return this[e];
    }, set(r) {
      this[e] = r;
    } };
    return { get() {
      return o == null ? void 0 : o.call(this);
    }, set(r) {
      const a = o == null ? void 0 : o.call(this);
      s.call(this, r), this.requestUpdate(t, a, n);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) ?? Vo;
  }
  static _$Ei() {
    if (this.hasOwnProperty(Te("elementProperties")))
      return;
    const t = Au(this);
    t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(Te("finalized")))
      return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(Te("properties"))) {
      const e = this.properties, n = [...$u(e), ...Cu(e)];
      for (const o of n)
        this.createProperty(o, e[o]);
    }
    const t = this[Symbol.metadata];
    if (t !== null) {
      const e = litPropertyMetadata.get(t);
      if (e !== void 0)
        for (const [n, o] of e)
          this.elementProperties.set(n, o);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [e, n] of this.elementProperties) {
      const o = this._$Eu(e, n);
      o !== void 0 && this._$Eh.set(o, e);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const n = new Set(t.flat(1 / 0).reverse());
      for (const o of n)
        e.unshift(Ho(o));
    } else
      t !== void 0 && e.push(Ho(t));
    return e;
  }
  static _$Eu(t, e) {
    const n = e.attribute;
    return n === !1 ? void 0 : typeof n == "string" ? n : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var t;
    this._$ES = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (t = this.constructor.l) == null || t.forEach((e) => e(this));
  }
  addController(t) {
    var e;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t), this.renderRoot !== void 0 && this.isConnected && ((e = t.hostConnected) == null || e.call(t));
  }
  removeController(t) {
    var e;
    (e = this._$EO) == null || e.delete(t);
  }
  _$E_() {
    const t = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;
    for (const n of e.keys())
      this.hasOwnProperty(n) && (t.set(n, this[n]), delete this[n]);
    t.size > 0 && (this._$Ep = t);
  }
  createRenderRoot() {
    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return yu(t, this.constructor.elementStyles), t;
  }
  connectedCallback() {
    var t;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (t = this._$EO) == null || t.forEach((e) => {
      var n;
      return (n = e.hostConnected) == null ? void 0 : n.call(e);
    });
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    var t;
    (t = this._$EO) == null || t.forEach((e) => {
      var n;
      return (n = e.hostDisconnected) == null ? void 0 : n.call(e);
    });
  }
  attributeChangedCallback(t, e, n) {
    this._$AK(t, n);
  }
  _$EC(t, e) {
    var s;
    const n = this.constructor.elementProperties.get(t), o = this.constructor._$Eu(t, n);
    if (o !== void 0 && n.reflect === !0) {
      const r = (((s = n.converter) == null ? void 0 : s.toAttribute) !== void 0 ? n.converter : $i).toAttribute(e, n.type);
      this._$Em = t, r == null ? this.removeAttribute(o) : this.setAttribute(o, r), this._$Em = null;
    }
  }
  _$AK(t, e) {
    var s;
    const n = this.constructor, o = n._$Eh.get(t);
    if (o !== void 0 && this._$Em !== o) {
      const r = n.getPropertyOptions(o), a = typeof r.converter == "function" ? { fromAttribute: r.converter } : ((s = r.converter) == null ? void 0 : s.fromAttribute) !== void 0 ? r.converter : $i;
      this._$Em = o, this[o] = a.fromAttribute(e, r.type), this._$Em = null;
    }
  }
  requestUpdate(t, e, n) {
    if (t !== void 0) {
      if (n ?? (n = this.constructor.getPropertyOptions(t)), !(n.hasChanged ?? Un)(this[t], e))
        return;
      this.P(t, e, n);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$ET());
  }
  P(t, e, n) {
    this._$AL.has(t) || this._$AL.set(t, e), n.reflect === !0 && this._$Em !== t && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(t);
  }
  async _$ET() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (e) {
      Promise.reject(e);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var n;
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [s, r] of this._$Ep)
          this[s] = r;
        this._$Ep = void 0;
      }
      const o = this.constructor.elementProperties;
      if (o.size > 0)
        for (const [s, r] of o)
          r.wrapped !== !0 || this._$AL.has(s) || this[s] === void 0 || this.P(s, this[s], r);
    }
    let t = !1;
    const e = this._$AL;
    try {
      t = this.shouldUpdate(e), t ? (this.willUpdate(e), (n = this._$EO) == null || n.forEach((o) => {
        var s;
        return (s = o.hostUpdate) == null ? void 0 : s.call(o);
      }), this.update(e)) : this._$EU();
    } catch (o) {
      throw t = !1, this._$EU(), o;
    }
    t && this._$AE(e);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    var e;
    (e = this._$EO) == null || e.forEach((n) => {
      var o;
      return (o = n.hostUpdated) == null ? void 0 : o.call(n);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((e) => this._$EC(e, this[e]))), this._$EU();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
}
Jt.elementStyles = [], Jt.shadowRootOptions = { mode: "open" }, Jt[Te("elementProperties")] = /* @__PURE__ */ new Map(), Jt[Te("finalized")] = /* @__PURE__ */ new Map(), en == null || en({ ReactiveElement: Jt }), (Ct.reactiveElementVersions ?? (Ct.reactiveElementVersions = [])).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
class jt extends Jt {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this.o = void 0;
  }
  createRenderRoot() {
    var e;
    const t = super.createRenderRoot();
    return (e = this.renderOptions).renderBefore ?? (e.renderBefore = t.firstChild), t;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this.o = ou(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this.o) == null || t.setConnected(!0);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this.o) == null || t.setConnected(!1);
  }
  render() {
    return re;
  }
}
var Wo;
jt._$litElement$ = !0, jt.finalized = !0, (Wo = globalThis.litElementHydrateSupport) == null || Wo.call(globalThis, { LitElement: jt });
const nn = globalThis.litElementPolyfillSupport;
nn == null || nn({ LitElement: jt });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.1.0");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Su = { attribute: !0, type: String, converter: $i, reflect: !1, hasChanged: Un }, ku = (i = Su, t, e) => {
  const { kind: n, metadata: o } = e;
  let s = globalThis.litPropertyMetadata.get(o);
  if (s === void 0 && globalThis.litPropertyMetadata.set(o, s = /* @__PURE__ */ new Map()), s.set(e.name, i), n === "accessor") {
    const { name: r } = e;
    return { set(a) {
      const l = t.get.call(this);
      t.set.call(this, a), this.requestUpdate(r, l, i);
    }, init(a) {
      return a !== void 0 && this.P(r, void 0, i), a;
    } };
  }
  if (n === "setter") {
    const { name: r } = e;
    return function(a) {
      const l = this[r];
      t.call(this, a), this.requestUpdate(r, l, i);
    };
  }
  throw Error("Unsupported decorator location: " + n);
};
function Q(i) {
  return (t, e) => typeof e == "object" ? ku(i, t, e) : ((n, o, s) => {
    const r = o.hasOwnProperty(s);
    return o.constructor.createProperty(s, r ? { ...n, wrapped: !0 } : n), r ? Object.getOwnPropertyDescriptor(o, s) : void 0;
  })(i, t, e);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function Tu(i) {
  return Q({ ...i, state: !0, attribute: !1 });
}
class Ou extends jr {
  constructor(t = document.createElement("div")) {
    super(), this.isCSS2DObject = !0, this.element = t, this.element.style.position = "absolute", this.element.style.userSelect = "none", this.element.setAttribute("draggable", !1), this.center = new Br(0.5, 0.5), this.addEventListener("removed", function() {
      this.traverse(function(e) {
        e.element instanceof Element && e.element.parentNode !== null && e.element.parentNode.removeChild(e.element);
      });
    });
  }
  copy(t, e) {
    return super.copy(t, e), this.element = t.element.cloneNode(!0), this.center = t.center, this;
  }
}
new wn();
new Go();
new Go();
new wn();
new wn();
class Iu {
  constructor(t, e) {
    this._group = new N.Group(), this._frustum = new N.Frustum(), this._frustumMat = new N.Matrix4(), this._regenerateDelay = 200, this._regenerateCounter = 0, this.material = new N.LineBasicMaterial({ color: "#2e3338" }), this.numbers = new N.Group(), this.maxRegenerateRetrys = 4, this.gridsFactor = 5, this._scaleX = 1, this._scaleY = 1, this._offsetX = 0, this._offsetY = 0, this._camera = t, this._container = e;
    const n = this.newGrid(-1), o = this.newGrid(-2);
    this.grids = { main: n, secondary: o }, this._group.add(o, n, this.numbers);
  }
  set scaleX(t) {
    this._scaleX = t, this.regenerate();
  }
  get scaleX() {
    return this._scaleX;
  }
  set scaleY(t) {
    this._scaleY = t, this.regenerate();
  }
  get scaleY() {
    return this._scaleY;
  }
  set offsetX(t) {
    this._offsetX = t, this.regenerate();
  }
  get offsetX() {
    return this._offsetX;
  }
  set offsetY(t) {
    this._offsetY = t, this.regenerate();
  }
  get offsetY() {
    return this._offsetY;
  }
  get() {
    return this._group;
  }
  dispose() {
    const { main: t, secondary: e } = this.grids;
    t.removeFromParent(), e.removeFromParent(), t.geometry.dispose(), t.material.dispose(), e.geometry.dispose(), e.material.dispose();
  }
  regenerate() {
    if (!this.isGridReady()) {
      if (this._regenerateCounter++, this._regenerateCounter > this.maxRegenerateRetrys)
        throw new Error("Grid could not be regenerated");
      setTimeout(() => this.regenerate, this._regenerateDelay);
      return;
    }
    this._regenerateCounter = 0, this._camera.updateMatrix(), this._camera.updateMatrixWorld();
    const e = this._frustumMat.multiplyMatrices(
      this._camera.projectionMatrix,
      this._camera.matrixWorldInverse
    );
    this._frustum.setFromProjectionMatrix(e);
    const { planes: n } = this._frustum, o = n[0].constant * -n[0].normal.x, s = n[1].constant * -n[1].normal.x, r = n[2].constant * -n[2].normal.y, a = n[3].constant * -n[3].normal.y, l = Math.abs(o - s), c = Math.abs(a - r), { clientWidth: h, clientHeight: u } = this._container, p = Math.max(h, u), m = Math.max(l, c) / p, v = Math.ceil(Math.log10(l / this.scaleX)), w = Math.ceil(Math.log10(c / this.scaleY)), C = 10 ** (v - 2) * this.scaleX, x = 10 ** (w - 2) * this.scaleY, g = C * this.gridsFactor, y = x * this.gridsFactor, $ = Math.ceil(c / y), _ = Math.ceil(l / g), E = Math.ceil(c / x), L = Math.ceil(l / C), D = C * Math.ceil(s / C), T = x * Math.ceil(r / x), M = g * Math.ceil(s / g), S = y * Math.ceil(r / y), P = [...this.numbers.children];
    for (const G of P)
      G.removeFromParent();
    this.numbers.children = [];
    const k = [], tt = 9 * m, B = 1e4, X = M + this._offsetX, et = Math.round(Math.abs(X / this.scaleX) * B) / B, dt = (_ - 1) * g, Fi = Math.round(Math.abs((X + dt) / this.scaleX) * B) / B, Nr = Math.max(et, Fi).toString().length * tt;
    let zi = Math.ceil(Nr / g) * g;
    for (let G = 0; G < _; G++) {
      let U = M + G * g;
      k.push(U, a, 0, U, r, 0), U = Math.round(U * B) / B, zi = Math.round(zi * B) / B;
      const ge = U % zi;
      if (!(g < 1 || y < 1) && Math.abs(ge) > 0.01)
        continue;
      const Hi = this.newNumber((U + this._offsetX) / this.scaleX), zr = 12 * m;
      Hi.position.set(U, r + zr, 0);
    }
    for (let G = 0; G < $; G++) {
      const U = S + G * y;
      k.push(s, U, 0, o, U, 0);
      const ge = this.newNumber(U / this.scaleY);
      let Bi = 12;
      ge.element.textContent && (Bi += 4 * ge.element.textContent.length);
      const Hi = Bi * m;
      ge.position.set(s + Hi, U, 0);
    }
    const ji = [];
    for (let G = 0; G < L; G++) {
      const U = D + G * C;
      ji.push(U, a, 0, U, r, 0);
    }
    for (let G = 0; G < E; G++) {
      const U = T + G * x;
      ji.push(s, U, 0, o, U, 0);
    }
    const Mr = new N.BufferAttribute(new Float32Array(k), 3), Lr = new N.BufferAttribute(new Float32Array(ji), 3), { main: Dr, secondary: Fr } = this.grids;
    Dr.geometry.setAttribute("position", Mr), Fr.geometry.setAttribute("position", Lr);
  }
  newNumber(t) {
    const e = document.createElement("bim-label");
    e.textContent = String(Math.round(t * 100) / 100);
    const n = new Ou(e);
    return this.numbers.add(n), n;
  }
  newGrid(t) {
    const e = new N.BufferGeometry(), n = new N.LineSegments(e, this.material);
    return n.frustumCulled = !1, n.renderOrder = t, n;
  }
  isGridReady() {
    const t = this._camera.projectionMatrix.elements;
    for (let e = 0; e < t.length; e++) {
      const n = t[e];
      if (Number.isNaN(n))
        return !1;
    }
    return !0;
  }
}
var Ru = Object.defineProperty, Pu = Object.getOwnPropertyDescriptor, Ke = (i, t, e, n) => {
  for (var o = Pu(t, e), s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = r(t, e, o) || o);
  return o && Ru(t, e, o), o;
};
const Vn = class Vn extends jt {
  constructor() {
    super(...arguments), this._grid = null, this._world = null, this.resize = () => {
      this._world && this._grid && this._grid.regenerate();
    };
  }
  set gridColor(t) {
    if (this._gridColor = t, !(t && this._grid))
      return;
    const e = Number(t.replace("#", "0x"));
    Number.isNaN(e) || this._grid.material.color.setHex(e);
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridScaleX(t) {
    this._gridScaleX = t, t && this._grid && (this._grid.scaleX = t);
  }
  get gridScaleX() {
    return this._gridScaleX;
  }
  set gridScaleY(t) {
    this._gridScaleY = t, t && this._grid && (this._grid.scaleY = t);
  }
  get gridScaleY() {
    return this._gridScaleY;
  }
  get gridOffsetX() {
    var t;
    return ((t = this._grid) == null ? void 0 : t.offsetX) || 0;
  }
  set gridOffsetX(t) {
    this._grid && (this._grid.offsetX = t);
  }
  get gridOffsetY() {
    var t;
    return ((t = this._grid) == null ? void 0 : t.offsetY) || 0;
  }
  set gridOffsetY(t) {
    this._grid && (this._grid.offsetY = t);
  }
  set components(t) {
    this.dispose();
    const n = t.get(A.Worlds).create();
    this._world = n, n.scene = new A.SimpleScene(t), n.scene.setup(), n.renderer = new z.RendererWith2D(t, this);
    const o = new A.OrthoPerspectiveCamera(t);
    n.camera = o;
    const s = new Iu(o.threeOrtho, this);
    this._grid = s, n.scene.three.add(s.get()), o.controls.addEventListener(
      "update",
      () => s.regenerate()
    ), setTimeout(async () => {
      n.camera.updateAspect(), o.set("Plan"), await o.controls.setLookAt(0, 0, 100, 0, 0, 0), await o.projection.set("Orthographic"), o.controls.dollySpeed = 3, o.controls.draggingSmoothTime = 0.085, o.controls.maxZoom = 1e3, o.controls.zoom(4);
    });
  }
  get world() {
    return this._world;
  }
  dispose() {
    var t;
    (t = this.world) == null || t.dispose(), this._world = null, this._grid = null;
  }
  connectedCallback() {
    super.connectedCallback(), new ResizeObserver(this.resize).observe(this);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.dispose();
  }
  render() {
    return zn`<slot></slot>`;
  }
};
Vn.styles = Hn`
    :host {
      position: relative;
      display: flex;
      min-width: 0px;
      height: 100%;
      background-color: var(--bim-ui_bg-base);
    }
  `;
let kt = Vn;
Ke([
  Q({ type: String, attribute: "grid-color", reflect: !0 })
], kt.prototype, "gridColor");
Ke([
  Q({ type: Number, attribute: "grid-scale-x", reflect: !0 })
], kt.prototype, "gridScaleX");
Ke([
  Q({ type: Number, attribute: "grid-scale-y", reflect: !0 })
], kt.prototype, "gridScaleY");
Ke([
  Q({ type: Number, attribute: "grid-offset-x", reflect: !0 })
], kt.prototype, "gridOffsetX");
Ke([
  Q({ type: Number, attribute: "grid-offset-y", reflect: !0 })
], kt.prototype, "gridOffsetY");
var Nu = Object.defineProperty, Pt = (i, t, e, n) => {
  for (var o = void 0, s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = r(t, e, o) || o);
  return o && Nu(t, e, o), o;
};
const Wn = class Wn extends jt {
  constructor() {
    super(...arguments), this._defaults = {
      size: 60
    }, this._cssMatrix3D = "", this._matrix = new N.Matrix4(), this._onRightClick = new Event("rightclick"), this._onLeftClick = new Event("leftclick"), this._onTopClick = new Event("topclick"), this._onBottomClick = new Event("bottomclick"), this._onFrontClick = new Event("frontclick"), this._onBackClick = new Event("backclick"), this._camera = null, this._epsilon = (t) => Math.abs(t) < 1e-10 ? 0 : t;
  }
  set camera(t) {
    this._camera = t, this.updateOrientation();
  }
  get camera() {
    return this._camera;
  }
  updateOrientation() {
    if (!this.camera)
      return;
    this._matrix.extractRotation(this.camera.matrixWorldInverse);
    const { elements: t } = this._matrix;
    this._cssMatrix3D = `matrix3d(
      ${this._epsilon(t[0])},
      ${this._epsilon(-t[1])},
      ${this._epsilon(t[2])},
      ${this._epsilon(t[3])},
      ${this._epsilon(t[4])},
      ${this._epsilon(-t[5])},
      ${this._epsilon(t[6])},
      ${this._epsilon(t[7])},
      ${this._epsilon(t[8])},
      ${this._epsilon(-t[9])},
      ${this._epsilon(t[10])},
      ${this._epsilon(t[11])},
      ${this._epsilon(t[12])},
      ${this._epsilon(-t[13])},
      ${this._epsilon(t[14])},
      ${this._epsilon(t[15])})
    `;
  }
  render() {
    const t = this.size ?? this._defaults.size;
    return zn`
      <style>
        .face,
        .cube {
          width: ${t}px;
          height: ${t}px;
          transform: translateZ(-300px) ${this._cssMatrix3D};
        }

        .face-right {
          translate: ${t / 2}px 0 0;
        }

        .face-left {
          translate: ${-t / 2}px 0 0;
        }

        .face-top {
          translate: 0 ${t / 2}px 0;
        }

        .face-bottom {
          translate: 0 ${-t / 2}px 0;
        }

        .face-front {
          translate: 0 0 ${t / 2}px;
        }

        .face-back {
          translate: 0 0 ${-t / 2}px;
        }
      </style>
      <div class="parent">
        <div class="cube">
          <div
            class="face x-direction face-right"
            @click=${() => this.dispatchEvent(this._onRightClick)}
          >
            ${this.rightText}
          </div>
          <div
            class="face x-direction face-left"
            @click=${() => this.dispatchEvent(this._onLeftClick)}
          >
            ${this.leftText}
          </div>
          <div
            class="face y-direction face-top"
            @click=${() => this.dispatchEvent(this._onTopClick)}
          >
            ${this.topText}
          </div>
          <div
            class="face y-direction face-bottom"
            @click=${() => this.dispatchEvent(this._onBottomClick)}
          >
            ${this.bottomText}
          </div>
          <div
            class="face z-direction face-front"
            @click=${() => this.dispatchEvent(this._onFrontClick)}
          >
            ${this.frontText}
          </div>
          <div
            class="face z-direction face-back"
            @click=${() => this.dispatchEvent(this._onBackClick)}
          >
            ${this.backText}
          </div>
        </div>
      </div>
    `;
  }
};
Wn.styles = Hn`
    :host {
      position: absolute;
      z-index: 999;
      bottom: 1rem;
      right: 1rem;
    }

    .parent {
      perspective: 400px;
    }

    .cube {
      position: relative;
      transform-style: preserve-3d;
    }

    .face {
      position: absolute;
      display: flex;
      justify-content: center;
      user-select: none;
      align-items: center;
      cursor: pointer;
      text-align: center;
      transition: all 0.2s;
      color: var(--bim-view-cube--c, white);
      font-size: var(--bim-view-cube--fz, --bim-ui_size-2xl);
    }

    .x-direction {
      // background-color: var(--bim-view-cube_x--bgc, #c93830DD);
      background-color: var(--bim-view-cube_x--bgc, #01a6bcde);
    }

    .x-direction:hover {
      background-color: var(--bim-ui_accent-base, white);
    }

    .y-direction {
      // background-color: var(--bim-view-cube_y--bgc, #54ff19DD);
      background-color: var(--bim-view-cube_y--bgc, #8d0ec8de);
    }

    .y-direction:hover {
      background-color: var(--bim-ui_accent-base, white);
    }

    .z-direction {
      // background-color: var(--bim-view-cube_z--bgc, #3041c9DD);
      background-color: var(--bim-view-cube_z--bgc, #2718afde);
    }

    .z-direction:hover {
      background-color: var(--bim-ui_accent-base, white);
    }

    .face-front {
      transform: rotateX(180deg);
    }

    .face-back {
      transform: rotateZ(180deg);
    }

    .face-top {
      transform: rotateX(90deg);
    }

    .face-bottom {
      transform: rotateX(270deg);
    }

    .face-right {
      transform: rotateY(-270deg) rotateX(180deg);
    }

    .face-left {
      transform: rotateY(-90deg) rotateX(180deg);
    }
  `;
let at = Wn;
Pt([
  Q({ type: Number, reflect: !0 })
], at.prototype, "size");
Pt([
  Q({ type: String, attribute: "right-text", reflect: !0 })
], at.prototype, "rightText");
Pt([
  Q({ type: String, attribute: "left-text", reflect: !0 })
], at.prototype, "leftText");
Pt([
  Q({ type: String, attribute: "top-text", reflect: !0 })
], at.prototype, "topText");
Pt([
  Q({ type: String, attribute: "bottom-text", reflect: !0 })
], at.prototype, "bottomText");
Pt([
  Q({ type: String, attribute: "front-text", reflect: !0 })
], at.prototype, "frontText");
Pt([
  Q({ type: String, attribute: "back-text", reflect: !0 })
], at.prototype, "backText");
Pt([
  Tu()
], at.prototype, "_cssMatrix3D");
var Mu = Object.defineProperty, Lu = (i, t, e, n) => {
  for (var o = void 0, s = i.length - 1, r; s >= 0; s--)
    (r = i[s]) && (o = r(t, e, o) || o);
  return o && Mu(t, e, o), o;
};
const Gn = class Gn extends jt {
  constructor() {
    super(...arguments), this.world = null, this._components = null, this._viewport = _n();
  }
  set components(t) {
    var e;
    if (this._components = t, this.components) {
      const n = this.components.get(A.Worlds);
      this.world = n.create(), this.world.name = this.name;
    } else
      (e = this.world) == null || e.dispose(), this.world = null;
  }
  get components() {
    return this._components;
  }
  connectedCallback() {
    super.connectedCallback(), this.world && (this.world.enabled = !0);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.world && (this.world.enabled = !1);
  }
  firstUpdated() {
    const { value: t } = this._viewport;
    if (!(this.components && t && this.world))
      return;
    const e = new A.SimpleScene(this.components);
    this.world.scene = e, e.setup(), e.three.background = null;
    const n = new z.PostproductionRenderer(
      this.components,
      t
    );
    this.world.renderer = n;
    const { postproduction: o } = n, s = new A.OrthoPerspectiveCamera(this.components);
    this.world.camera = s;
    const r = this.components.get(A.Grids).create(this.world);
    r.material.uniforms.uColor.value = new N.Color(4342338), r.material.uniforms.uSize1.value = 2, r.material.uniforms.uSize2.value = 8, o.enabled = !0, o.customEffects.excludedMeshes.push(r.three), o.setPasses({ custom: !0, ao: !0, gamma: !0 }), o.customEffects.lineColor = 1513756;
  }
  render() {
    return zn`<bim-viewport ${mu(this._viewport)}
      ><slot></slot
    ></bim-viewport>`;
  }
};
Gn.styles = Hn``;
let Ci = Gn;
Lu([
  Q({ type: String, reflect: !0 })
], Ci.prototype, "name");
class vh {
  /**
   * Initializes the custom elements for the BIM application.
   *
   * @remarks
   * This method should be called once during the application's initialization.
   *
   */
  static init() {
    Ee.defineCustomElement("bim-view-cube", at), Ee.defineCustomElement("bim-world-2d", kt), Ee.defineCustomElement("bim-world", Ci);
  }
}
export {
  vh as Manager,
  at as ViewCube,
  Ci as World,
  kt as World2D,
  hh as buttons,
  bh as forms,
  ph as panels,
  mh as tables
};
